using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Text.Json;
using System.Text.RegularExpressions;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Processing;
using Telegram.Bot;
using Telegram.Bot.Requests;
using Telegram.Bot.Types;
using Telegram.Bot.Types.Enums;
using TelegramGroupsAdmin.Configuration;
using TelegramGroupsAdmin.Telegram.Helpers;
using TelegramGroupsAdmin.Telegram.Models;
using TelegramGroupsAdmin.Core.Models;

using TelegramGroupsAdmin.Telegram.Repositories;
using TelegramGroupsAdmin.Telegram.Services.BotCommands;

namespace TelegramGroupsAdmin.Telegram.Services.BackgroundServices;

/// <summary>
/// Handles message processing: new messages, edits, spam detection, image download
/// </summary>
public partial class MessageProcessingService(
    IServiceScopeFactory scopeFactory,
    IOptions<MessageHistoryOptions> historyOptions,
    CommandRouter commandRouter,
    ChatManagementService chatManagementService,
    SpamActionService spamActionService,
    TelegramPhotoService telegramPhotoService,
    IServiceProvider serviceProvider,
    ILogger<MessageProcessingService> logger)
{
    private readonly IServiceScopeFactory _scopeFactory = scopeFactory;
    private readonly MessageHistoryOptions _historyOptions = historyOptions.Value;
    private readonly TelegramPhotoService _photoService = telegramPhotoService;

    // Events for real-time UI updates
    public event Action<MessageRecord>? OnNewMessage;
    public event Action<MessageEditRecord>? OnMessageEdited;

    /// <summary>
    /// Handle new messages: save to database, execute commands, run spam detection
    /// Only processes group/supergroup messages - private DMs are handled by commands only
    /// </summary>
    public async Task HandleNewMessageAsync(ITelegramBotClient botClient, Message message, CancellationToken cancellationToken = default)
    {
        // Skip private chats - only process group messages for history/spam detection
        if (message.Chat.Type == ChatType.Private)
        {
            // Private DMs are only for bot commands (/start, /help, etc)
            // Execute command if present, but don't save to message history
            if (commandRouter.IsCommand(message))
            {
                try
                {
                    var commandResult = await commandRouter.RouteCommandAsync(botClient, message, cancellationToken);
                    if (commandResult?.Response != null && !string.IsNullOrWhiteSpace(commandResult.Response))
                    {
                        await botClient.SendMessage(
                            chatId: message.Chat.Id,
                            text: commandResult.Response,
                            parseMode: ParseMode.Markdown,
                            cancellationToken: cancellationToken);
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error executing command in private chat {ChatId}", message.Chat.Id);
                }
            }
            return; // Don't process private messages further
        }

        // Detect Group â†’ Supergroup migration
        // When a Group is upgraded to Supergroup (e.g., when granting admin), Telegram:
        // 1. Creates a new Supergroup with different chat ID
        // 2. Sends a migration message with MigrateToChatId pointing to new chat
        if (message.MigrateToChatId.HasValue)
        {
            var oldChatId = message.Chat.Id;
            var newChatId = message.MigrateToChatId.Value;

            logger.LogWarning(
                "ðŸ”„ Chat migration detected: Group {OldChatId} upgraded to Supergroup {NewChatId}",
                oldChatId,
                newChatId);

            await chatManagementService.HandleChatMigrationAsync(oldChatId, newChatId, cancellationToken);
            return; // Don't process migration message further
        }

        // Delete service messages (join/leave, photo changes, title changes, etc.)
        // These are automatically generated by Telegram and clutter the chat
        // Use property-based detection instead of MessageType enum for broader coverage
        var isServiceMessage = message.NewChatMembers != null ||
                               message.LeftChatMember != null ||
                               message.NewChatPhoto != null ||
                               message.DeleteChatPhoto == true ||
                               message.NewChatTitle != null ||
                               message.PinnedMessage != null ||
                               message.GroupChatCreated == true ||
                               message.SupergroupChatCreated == true ||
                               message.ChannelChatCreated == true;

        if (isServiceMessage)
        {
            logger.LogInformation(
                "Detected service message: Type={Type}, MessageId={MessageId}, ChatId={ChatId}",
                message.Type,
                message.MessageId,
                message.Chat.Id);

            try
            {
                await botClient.DeleteMessage(
                    chatId: message.Chat.Id,
                    messageId: message.MessageId,
                    cancellationToken: cancellationToken);

                logger.LogInformation(
                    "Deleted service message (type: {Type}) in chat {ChatId}",
                    message.Type,
                    message.Chat.Id);
            }
            catch (Exception ex)
            {
                logger.LogWarning(
                    ex,
                    "Failed to delete service message {MessageId} in chat {ChatId}",
                    message.MessageId,
                    message.Chat.Id);
            }
            return; // Don't process service messages further
        }

        // Process messages from all group chats where bot is added
        try
        {
            var now = DateTimeOffset.UtcNow;

            // Update last_seen_at for this chat (also auto-adds chat if it doesn't exist)
            // Then refresh admin cache for newly discovered chats OR chats with empty admin cache
            using var scope = serviceProvider.CreateScope();
            var managedChatsRepository = scope.ServiceProvider.GetRequiredService<IManagedChatsRepository>();
            var existingChat = await managedChatsRepository.GetByChatIdAsync(message.Chat.Id, cancellationToken);
            var isNewChat = existingChat == null;

            await managedChatsRepository.UpdateLastSeenAsync(message.Chat.Id, now, cancellationToken);

            // Check if we need to refresh admin cache (only for groups/supergroups, not private DMs)
            if (message.Chat.Type == ChatType.Group || message.Chat.Type == ChatType.Supergroup)
            {
                bool shouldRefreshAdmins = false;
                string refreshReason = "";

                if (isNewChat)
                {
                    shouldRefreshAdmins = true;
                    refreshReason = "newly discovered chat";
                }
                else
                {
                    // Check if admin cache is empty for this chat
                    var chatAdminsRepository = scope.ServiceProvider.GetRequiredService<IChatAdminsRepository>();
                    var adminCount = await chatAdminsRepository.GetAdminCountAsync(message.Chat.Id, cancellationToken);

                    if (adminCount == 0)
                    {
                        shouldRefreshAdmins = true;
                        refreshReason = "admin cache is empty";
                    }
                }

                if (shouldRefreshAdmins)
                {
                    logger.LogInformation(
                        "Refreshing admin cache for chat {ChatId} ({Reason})",
                        message.Chat.Id,
                        refreshReason);

                    try
                    {
                        await chatManagementService.RefreshChatAdminsAsync(botClient, message.Chat.Id, cancellationToken);
                    }
                    catch (Exception ex)
                    {
                        logger.LogWarning(ex, "Failed to refresh admins for chat {ChatId}", message.Chat.Id);
                    }
                }
            }
            else
            {
                if (isNewChat)
                {
                    logger.LogDebug("Discovered new private chat {ChatId}, skipping admin cache refresh", message.Chat.Id);
                }
            }

            // Check if message is a bot command (execute first, then save to history)
            // Note: Errors are caught to ensure message history is always saved
            CommandResult? commandResult = null;
            if (commandRouter.IsCommand(message))
            {
                try
                {
                    commandResult = await commandRouter.RouteCommandAsync(botClient, message, cancellationToken);
                    if (commandResult != null)
                    {
                        // Send response if there is one (and it's not empty)
                        if (commandResult.Response != null && !string.IsNullOrWhiteSpace(commandResult.Response))
                        {
                            var responseMessage = await botClient.SendMessage(
                                chatId: message.Chat.Id,
                                text: commandResult.Response,
                                parseMode: ParseMode.Markdown,
                                replyParameters: new ReplyParameters { MessageId = message.MessageId },
                                cancellationToken: cancellationToken);

                            // Schedule auto-delete if requested
                            if (commandResult.DeleteResponseAfterSeconds.HasValue)
                            {
                                await ScheduleMessageDeleteAsync(
                                    message.Chat.Id,
                                    responseMessage.MessageId,
                                    commandResult.DeleteResponseAfterSeconds.Value,
                                    "command_response",
                                    cancellationToken);
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError(ex,
                        "Error executing command in chat {ChatId}, message will still be saved to history",
                        message.Chat.Id);
                    // Continue to save message to history regardless of command error
                }
                // Continue to save command message to history (don't return early)
            }

            // Check for @admin mentions (independent of commands)
            // Note: Errors are caught to ensure message history is always saved
            var text = message.Text ?? message.Caption;
            if (!string.IsNullOrWhiteSpace(text))
            {
                try
                {
                    using var mentionScope = serviceProvider.CreateScope();
                    var adminMentionHandler = mentionScope.ServiceProvider.GetRequiredService<AdminMentionHandler>();
                    if (adminMentionHandler.ContainsAdminMention(text))
                    {
                        await adminMentionHandler.NotifyAdminsAsync(botClient, message, cancellationToken);
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError(ex,
                        "Error handling @admin mention in chat {ChatId}, message will still be saved to history",
                        message.Chat.Id);
                    // Continue to save message to history regardless of error
                }
            }

            // Extract URLs from message text
            var urls = text != null ? ExtractUrls(text) : null;

            // Get photo file ID if present and download image
            string? photoFileId = null;
            int? photoFileSize = null;
            string? photoLocalPath = null;
            string? photoThumbnailPath = null;

            if (message.Photo is { Length: > 0 } photos)
            {
                var largestPhoto = photos.OrderByDescending(p => p.FileSize).First();
                photoFileId = largestPhoto.FileId;
                photoFileSize = largestPhoto.FileSize.HasValue ? (int)largestPhoto.FileSize.Value : null;

                // Download and process image
                (photoLocalPath, photoThumbnailPath) = await DownloadAndProcessImageAsync(
                    botClient,
                    photoFileId,
                    message.Chat.Id,
                    message.MessageId,
                    cancellationToken);
            }

            // Calculate content hash for spam correlation
            var urlsJson = urls != null ? JsonSerializer.Serialize(urls) : "";
            var contentHash = ComputeContentHash(text ?? "", urlsJson);

            // Check if chat icon is cached on disk
            var chatIconFileName = $"{Math.Abs(message.Chat.Id)}.jpg";
            var chatIconCachedPath = Path.Combine(_historyOptions.ImageStoragePath, "chat_icons", chatIconFileName);
            var chatIconPath = File.Exists(chatIconCachedPath) ? $"chat_icons/{chatIconFileName}" : null;

            // User photo will be fetched asynchronously after message save (non-blocking)
            var messageRecord = new MessageRecord(
                message.MessageId,
                message.From!.Id,
                message.From.Username,
                message.From.FirstName,
                message.Chat.Id,
                now,
                text,
                photoFileId,
                photoFileSize,
                urlsJson != "" ? urlsJson : null,
                EditDate: message.EditDate.HasValue ? new DateTimeOffset(message.EditDate.Value, TimeSpan.Zero) : null,
                ContentHash: contentHash,
                ChatName: message.Chat.Title ?? message.Chat.Username,
                PhotoLocalPath: photoLocalPath,
                PhotoThumbnailPath: photoThumbnailPath,
                ChatIconPath: chatIconPath,
                UserPhotoPath: null, // Will be populated by background task
                DeletedAt: null,
                DeletionSource: null,
                ReplyToMessageId: message.ReplyToMessage?.MessageId,
                ReplyToUser: null, // Populated by repository queries via JOIN
                ReplyToText: null // Populated by repository queries via JOIN
            );

            // Save message to database using a scoped repository
            using var messageScope = _scopeFactory.CreateScope();
            var repository = messageScope.ServiceProvider.GetRequiredService<MessageHistoryRepository>();
            await repository.InsertMessageAsync(messageRecord, cancellationToken);

            // Upsert user into telegram_users table (centralized user tracking)
            var telegramUserRepo = messageScope.ServiceProvider.GetRequiredService<TelegramUserRepository>();
            var telegramUser = new TelegramGroupsAdmin.Telegram.Models.TelegramUser(
                TelegramUserId: message.From!.Id,
                Username: message.From.Username,
                FirstName: message.From.FirstName,
                LastName: message.From.LastName,
                UserPhotoPath: null, // Will be populated by FetchUserPhotoJob
                PhotoHash: null,
                IsTrusted: false,
                BotDmEnabled: false, // Will be set to true when user sends /start in private chat
                FirstSeenAt: now,
                LastSeenAt: now,
                CreatedAt: now,
                UpdatedAt: now
            );
            await telegramUserRepo.UpsertAsync(telegramUser, cancellationToken);

            // Phase 4.10: Check for impersonation (name + photo similarity vs admins)
            // Check users on their first N messages
            var impersonationService = messageScope.ServiceProvider.GetRequiredService<IImpersonationDetectionService>();
            var shouldCheck = await impersonationService.ShouldCheckUserAsync(message.From!.Id, message.Chat.Id);

            if (shouldCheck)
            {
                logger.LogDebug(
                    "Checking user {UserId} for impersonation on message #{MessageCount}",
                    message.From.Id,
                    message.MessageId);

                // Get cached user photo path (may be null if not fetched yet)
                var existingUser = await telegramUserRepo.GetByTelegramIdAsync(message.From.Id, cancellationToken);
                var photoPath = existingUser?.UserPhotoPath;

                // Check for impersonation
                var impersonationResult = await impersonationService.CheckUserAsync(
                    message.From.Id,
                    message.Chat.Id,
                    message.From.FirstName,
                    message.From.LastName,
                    photoPath);

                if (impersonationResult != null)
                {
                    logger.LogWarning(
                        "Impersonation detected for user {UserId} in chat {ChatId} (score: {Score}, risk: {Risk})",
                        message.From.Id,
                        message.Chat.Id,
                        impersonationResult.TotalScore,
                        impersonationResult.RiskLevel);

                    // Execute action (create alert, auto-ban if score >= 100)
                    await impersonationService.ExecuteActionAsync(impersonationResult);

                    // If auto-banned, message will remain in history for audit trail
                    // User will be banned from all chats immediately
                    if (impersonationResult.ShouldAutoBan)
                    {
                        logger.LogInformation(
                            "User {UserId} auto-banned for impersonation (score: {Score})",
                            message.From.Id,
                            impersonationResult.TotalScore);
                    }
                }
            }

            // Raise event for real-time UI updates
            OnNewMessage?.Invoke(messageRecord);

            logger.LogDebug(
                "Cached message {MessageId} from user {UserId} in chat {ChatId} (photo: {HasPhoto}, text: {HasText})",
                message.MessageId,
                message.From.Id,
                message.Chat.Id,
                photoFileId != null,
                text != null);

            // Delete command message if requested (AFTER saving to database for FK integrity)
            if (commandResult?.DeleteCommandMessage == true)
            {
                try
                {
                    await botClient.DeleteMessage(
                        chatId: message.Chat.Id,
                        messageId: message.MessageId,
                        cancellationToken: cancellationToken);

                    logger.LogDebug("Deleted command message {MessageId} in chat {ChatId}", message.MessageId, message.Chat.Id);
                }
                catch (Exception ex)
                {
                    logger.LogWarning(ex, "Failed to delete command message {MessageId} in chat {ChatId}", message.MessageId, message.Chat.Id);
                }
            }

            // Fetch user profile photo via TickerQ (0s delay for instant execution, with persistence/retry)
            if (message.From?.Id != null)
            {
                await ScheduleUserPhotoFetchAsync(message.MessageId, message.From.Id, cancellationToken);
            }

            // Phase 2.6: Automatic spam detection with detection result storage
            // Skip spam detection for command messages (already processed by CommandRouter)
            if (commandResult == null && !string.IsNullOrWhiteSpace(text))
            {
                _ = Task.Run(async () =>
                {
                    await RunSpamDetectionAsync(botClient, message, text, editVersion: 0, CancellationToken.None);
                }, CancellationToken.None);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Error caching message {MessageId} from user {UserId} in chat {ChatId}",
                message.MessageId,
                message.From?.Id,
                message.Chat?.Id);
        }
    }

    /// <summary>
    /// Handle edited messages: save edit history, update message, re-scan for spam
    /// </summary>
    public async Task HandleEditedMessageAsync(ITelegramBotClient botClient, Message editedMessage, CancellationToken cancellationToken = default)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var repository = scope.ServiceProvider.GetRequiredService<MessageHistoryRepository>();

            // Get the old message from the database
            var oldMessage = await repository.GetMessageAsync(editedMessage.MessageId, cancellationToken);
            if (oldMessage == null)
            {
                logger.LogWarning(
                    "Received edit for unknown message {MessageId}",
                    editedMessage.MessageId);
                return;
            }

            var oldText = oldMessage.MessageText;
            var newText = editedMessage.Text ?? editedMessage.Caption;

            // Skip if text hasn't actually changed
            if (oldText == newText)
            {
                logger.LogDebug(
                    "Edit event for message {MessageId} but text unchanged, skipping",
                    editedMessage.MessageId);
                return;
            }

            var editDate = editedMessage.EditDate.HasValue
                ? new DateTimeOffset(editedMessage.EditDate.Value, TimeSpan.Zero)
                : DateTimeOffset.UtcNow;

            // Extract URLs and calculate content hashes
            var oldUrls = oldText != null ? ExtractUrls(oldText) : null;
            var newUrls = newText != null ? ExtractUrls(newText) : null;

            var oldContentHash = ComputeContentHash(oldText ?? "", oldUrls != null ? JsonSerializer.Serialize(oldUrls) : "");
            var newContentHash = ComputeContentHash(newText ?? "", newUrls != null ? JsonSerializer.Serialize(newUrls) : "");

            // Create edit record
            var editRecord = new MessageEditRecord(
                Id: 0, // Will be set by INSERT
                MessageId: editedMessage.MessageId,
                EditDate: editDate,
                OldText: oldText,
                NewText: newText,
                OldContentHash: oldContentHash,
                NewContentHash: newContentHash
            );

            await repository.InsertMessageEditAsync(editRecord, cancellationToken);

            // Update the message in the messages table with new text and edit date
            var updatedMessage = oldMessage with
            {
                MessageText = newText,
                EditDate = editDate,
                Urls = newUrls != null ? JsonSerializer.Serialize(newUrls) : null,
                ContentHash = newContentHash
            };
            await repository.UpdateMessageAsync(updatedMessage, cancellationToken);

            // Raise event for real-time UI updates
            OnMessageEdited?.Invoke(editRecord);

            logger.LogInformation(
                "Recorded edit for message {MessageId} in chat {ChatId}",
                editedMessage.MessageId,
                editedMessage.Chat.Id);

            // Phase 2.7: Re-scan edited message for spam (detect "post innocent, edit to spam" tactic)
            if (!string.IsNullOrWhiteSpace(newText))
            {
                _ = Task.Run(async () =>
                {
                    try
                    {
                        using var scope = serviceProvider.CreateScope();
                        var detectionResultsRepo = scope.ServiceProvider.GetRequiredService<IDetectionResultsRepository>();

                        // Get the latest edit_version for this message
                        var existingResults = await detectionResultsRepo.GetByMessageIdAsync(editedMessage.MessageId, CancellationToken.None);
                        var maxEditVersion = existingResults.Any()
                            ? existingResults.Max(r => r.EditVersion)
                            : 0;

                        await RunSpamDetectionAsync(botClient, editedMessage, newText, editVersion: maxEditVersion + 1, CancellationToken.None);
                    }
                    catch (Exception ex)
                    {
                        logger.LogError(ex, "Failed to re-scan edited message {MessageId} for spam", editedMessage.MessageId);
                    }
                }, CancellationToken.None);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Error handling edit for message {MessageId}",
                editedMessage.MessageId);
        }
    }

    /// <summary>
    /// Run spam detection on a message and take appropriate actions
    /// </summary>
    private async Task RunSpamDetectionAsync(ITelegramBotClient botClient, Message message, string text, int editVersion, CancellationToken cancellationToken = default)
    {
        try
        {
            using var scope = serviceProvider.CreateScope();
            var coordinator = scope.ServiceProvider.GetRequiredService<IContentCheckCoordinator>();
            var detectionResultsRepo = scope.ServiceProvider.GetRequiredService<IDetectionResultsRepository>();
            var spamDetectionEngine = scope.ServiceProvider.GetRequiredService<TelegramGroupsAdmin.ContentDetection.Services.IContentDetectionEngine>();

            var request = new TelegramGroupsAdmin.ContentDetection.Models.ContentCheckRequest
            {
                Message = text,
                UserId = message.From?.Id ?? 0,
                UserName = message.From?.Username,
                ChatId = message.Chat.Id
            };

            var result = await coordinator.CheckAsync(request, cancellationToken);

            // Phase 4.14: Handle critical check violations FIRST (before regular spam)
            // Critical violations apply to ALL users (trusted/admin included)
            if (result.HasCriticalViolations)
            {
                logger.LogWarning(
                    "Critical check violations detected for message {MessageId} from user {UserId}: {Violations}",
                    message.MessageId,
                    message.From?.Id,
                    string.Join("; ", result.CriticalCheckViolations));

                // Use SpamActionService to handle critical violations
                // Policy: Delete + DM notice, NO ban/warn for trusted/admin users
                await spamActionService.HandleCriticalCheckViolationAsync(
                    botClient,
                    message,
                    result.CriticalCheckViolations,
                    cancellationToken).ConfigureAwait(false);

                // If critical violations found, don't process regular spam (already handled)
                return;
            }

            // Store detection result (spam or ham) for analytics and training
            // Only store if spam detection actually ran (not skipped for trusted/admin users)
            if (!result.SpamCheckSkipped && result.SpamResult != null)
            {
                var reasonPrefix = editVersion > 0 ? $"[Edit #{editVersion}] " : "";

                var detectionResult = new DetectionResultRecord
                {
                    MessageId = message.MessageId,
                    DetectedAt = DateTimeOffset.UtcNow,
                    DetectionSource = "auto",
                    DetectionMethod = result.SpamResult.CheckResults.Count > 0
                        ? string.Join(", ", result.SpamResult.CheckResults.Select(c => c.CheckName))
                        : "Unknown",
                    // IsSpam is computed from net_confidence (don't set it here)
                    Confidence = result.SpamResult.MaxConfidence,
                    Reason = $"{reasonPrefix}{result.SpamResult.PrimaryReason}",
                    AddedBy = Actor.FromSystem("auto_detection"), // Phase 4.19: Actor system
                    UsedForTraining = SpamActionService.DetermineIfTrainingWorthy(result.SpamResult),
                    NetConfidence = result.SpamResult.NetConfidence,
                    CheckResultsJson = spamDetectionEngine.GetType()
                        .GetMethod("SerializeCheckResults", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)
                        ?.Invoke(null, new object[] { result.SpamResult.CheckResults }) as string,
                    EditVersion = editVersion
                };

                await detectionResultsRepo.InsertAsync(detectionResult, cancellationToken);

                var editInfo = editVersion > 0 ? $" (edit #{editVersion})" : "";
                logger.LogInformation(
                    "Stored detection result for message {MessageId}{EditInfo}: {IsSpam} (net: {NetConfidence}, training: {UsedForTraining})",
                    message.MessageId,
                    editInfo,
                    result.SpamResult.IsSpam ? "spam" : "ham",
                    result.SpamResult.NetConfidence,
                    detectionResult.UsedForTraining);

                // Check for auto-trust after storing non-spam detection result
                if (!result.SpamResult.IsSpam && message.From?.Id != null)
                {
                    var autoTrustService = scope.ServiceProvider.GetRequiredService<UserAutoTrustService>();
                    await autoTrustService.CheckAndApplyAutoTrustAsync(message.From.Id, message.Chat.Id, cancellationToken);
                }

                // Phase 2.7: Handle spam actions based on net confidence
                await spamActionService.HandleSpamDetectionActionsAsync(
                    message,
                    result.SpamResult,
                    detectionResult,
                    cancellationToken);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to run spam detection for message {MessageId}", message.MessageId);
        }
    }

    /// <summary>
    /// Extract URLs from message text
    /// </summary>
    private static List<string>? ExtractUrls(string text)
    {
        var matches = UrlRegex().Matches(text);
        return matches.Count > 0
            ? matches.Select(m => m.Value).ToList()
            : null;
    }

    [GeneratedRegex(@"https?://[^\s\]\)\>]+", RegexOptions.IgnoreCase | RegexOptions.Compiled)]
    private static partial Regex UrlRegex();

    /// <summary>
    /// Download and process image from Telegram (full + thumbnail)
    /// </summary>
    private async Task<(string? fullPath, string? thumbPath)> DownloadAndProcessImageAsync(
        ITelegramBotClient botClient,
        string photoFileId,
        long chatId,
        long messageId,
        CancellationToken cancellationToken = default)
    {
        try
        {
            // Create directory structure: {ImageStoragePath}/full/{chat_id}/ and thumbs/{chat_id}/
            var basePath = _historyOptions.ImageStoragePath;
            var fullDir = Path.Combine(basePath, "full", chatId.ToString());
            var thumbDir = Path.Combine(basePath, "thumbs", chatId.ToString());

            Directory.CreateDirectory(fullDir);
            Directory.CreateDirectory(thumbDir);

            var fileName = $"{messageId}.jpg";
            var fullPath = Path.Combine(fullDir, fileName);
            var thumbPath = Path.Combine(thumbDir, fileName);

            // Download file from Telegram
            var file = await botClient.GetFile(photoFileId, cancellationToken);
            if (file.FilePath == null)
            {
                logger.LogWarning("Unable to get file path for photo {FileId}", photoFileId);
                return (null, null);
            }

            // Download to temp file first
            var tempPath = Path.GetTempFileName();
            try
            {
                await using (var fileStream = System.IO.File.Create(tempPath))
                {
                    await botClient.DownloadFile(file.FilePath, fileStream, cancellationToken);
                }

                // Copy to full image location
                System.IO.File.Copy(tempPath, fullPath, overwrite: true);

                // Generate thumbnail using ImageSharp
                using (var image = await Image.LoadAsync(tempPath, cancellationToken))
                {
                    var thumbnailSize = _historyOptions.ThumbnailSize;
                    image.Mutate(x => x.Resize(new ResizeOptions
                    {
                        Size = new Size(thumbnailSize, thumbnailSize),
                        Mode = ResizeMode.Max // Maintain aspect ratio
                    }));

                    await image.SaveAsJpegAsync(thumbPath, cancellationToken);
                }

                logger.LogDebug(
                    "Downloaded and processed image for message {MessageId} in chat {ChatId}",
                    messageId, chatId);

                // Return relative paths for storage in database
                return ($"full/{chatId}/{fileName}", $"thumbs/{chatId}/{fileName}");
            }
            finally
            {
                // Clean up temp file
                if (System.IO.File.Exists(tempPath))
                    System.IO.File.Delete(tempPath);
            }
        }
        catch (IOException ioEx)
        {
            // Disk full or permissions error - fail open (don't block message, just skip image)
            logger.LogWarning(ioEx,
                "Filesystem error downloading image for message {MessageId} in chat {ChatId}. Message will be stored without image.",
                messageId, chatId);
            return (null, null);
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Error downloading/processing image for message {MessageId} in chat {ChatId}",
                messageId, chatId);
            return (null, null);
        }
    }

    /// <summary>
    /// Compute content hash for message (used for spam correlation)
    /// </summary>
    private static string ComputeContentHash(string messageText, string urls)
    {
        var normalized = $"{messageText.ToLowerInvariant().Trim()}{urls.ToLowerInvariant().Trim()}";
        using var sha256 = System.Security.Cryptography.SHA256.Create();
        var hashBytes = sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(normalized));
        return Convert.ToHexString(hashBytes);
    }

    /// <summary>
    /// Schedule a message for deletion via TickerQ
    /// </summary>
    private async Task ScheduleMessageDeleteAsync(long chatId, int messageId, int delaySeconds, string reason, CancellationToken cancellationToken = default)
    {
        var deletePayload = new TelegramGroupsAdmin.Telegram.Abstractions.Jobs.DeleteMessagePayload(
            chatId,
            messageId,
            reason
        );

        await TickerQHelper.ScheduleJobAsync(
            serviceProvider,
            logger,
            "DeleteMessage",
            deletePayload,
            delaySeconds,
            retries: 0);
    }

    /// <summary>
    /// Schedule user photo fetch via TickerQ with 0s delay (instant execution with persistence/retry)
    /// </summary>
    private async Task ScheduleUserPhotoFetchAsync(long messageId, long userId, CancellationToken cancellationToken = default)
    {
        var photoPayload = new TelegramGroupsAdmin.Telegram.Abstractions.Jobs.FetchUserPhotoPayload(
            messageId,
            userId
        );

        await TickerQHelper.ScheduleJobAsync(
            serviceProvider,
            logger,
            "FetchUserPhoto",
            photoPayload,
            delaySeconds: 0,
            retries: 2);
    }
}
