using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Text.Json;
using System.Text.RegularExpressions;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Processing;
using Telegram.Bot;
using Telegram.Bot.Requests;
using Telegram.Bot.Types;
using Telegram.Bot.Types.Enums;
using TelegramGroupsAdmin.Configuration;
using TelegramGroupsAdmin.Core.BackgroundJobs;
using TelegramGroupsAdmin.Telegram.Models;
using TelegramGroupsAdmin.Core.Models;
using TelegramGroupsAdmin.Core.Utilities;
using TelegramGroupsAdmin.Telegram.Repositories;
using TelegramGroupsAdmin.Telegram.Services.BotCommands;

namespace TelegramGroupsAdmin.Telegram.Services.BackgroundServices;

/// <summary>
/// Handles message processing: new messages, edits, spam detection, image download
/// </summary>
public partial class MessageProcessingService(
    IServiceScopeFactory scopeFactory,
    IOptions<MessageHistoryOptions> historyOptions,
    CommandRouter commandRouter,
    ChatManagementService chatManagementService,
    SpamActionService spamActionService,
    TelegramPhotoService telegramPhotoService,
    TelegramMediaService telegramMediaService,
    IServiceProvider serviceProvider,
    ILogger<MessageProcessingService> logger)
{
    private readonly IServiceScopeFactory _scopeFactory = scopeFactory;
    private readonly MessageHistoryOptions _historyOptions = historyOptions.Value;
    private readonly TelegramPhotoService _photoService = telegramPhotoService;
    private readonly TelegramMediaService _mediaService = telegramMediaService;

    // Events for real-time UI updates
    public event Action<MessageRecord>? OnNewMessage;
    public event Action<MessageEditRecord>? OnMessageEdited;

    /// <summary>
    /// Handle new messages: save to database, execute commands, run spam detection
    /// Only processes group/supergroup messages - private DMs are handled by commands only
    /// </summary>
    public async Task HandleNewMessageAsync(ITelegramBotClient botClient, Message message, CancellationToken cancellationToken = default)
    {
        // Skip private chats - only process group messages for history/spam detection
        if (message.Chat.Type == ChatType.Private)
        {
            // Private DMs are only for bot commands (/start, /help, etc)
            // Execute command if present, but don't save to message history
            if (commandRouter.IsCommand(message))
            {
                try
                {
                    var commandResult = await commandRouter.RouteCommandAsync(botClient, message, cancellationToken);
                    if (commandResult?.Response != null && !string.IsNullOrWhiteSpace(commandResult.Response))
                    {
                        await botClient.SendMessage(
                            chatId: message.Chat.Id,
                            text: commandResult.Response,
                            parseMode: ParseMode.Markdown,
                            cancellationToken: cancellationToken);
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error executing command in private chat {ChatId}", message.Chat.Id);
                }
            }
            return; // Don't process private messages further
        }

        // Detect Group â†’ Supergroup migration
        // When a Group is upgraded to Supergroup (e.g., when granting admin), Telegram:
        // 1. Creates a new Supergroup with different chat ID
        // 2. Sends a migration message with MigrateToChatId pointing to new chat
        if (message.MigrateToChatId.HasValue)
        {
            var oldChatId = message.Chat.Id;
            var newChatId = message.MigrateToChatId.Value;

            logger.LogWarning(
                "ðŸ”„ Chat migration detected: Group {OldChatId} upgraded to Supergroup {NewChatId}",
                oldChatId,
                newChatId);

            await chatManagementService.HandleChatMigrationAsync(oldChatId, newChatId, cancellationToken);
            return; // Don't process migration message further
        }

        // Delete service messages (join/leave, photo changes, title changes, etc.)
        // These are automatically generated by Telegram and clutter the chat
        // Use property-based detection instead of MessageType enum for broader coverage
        var isServiceMessage = message.NewChatMembers != null ||
                               message.LeftChatMember != null ||
                               message.NewChatPhoto != null ||
                               message.DeleteChatPhoto == true ||
                               message.NewChatTitle != null ||
                               message.PinnedMessage != null ||
                               message.GroupChatCreated == true ||
                               message.SupergroupChatCreated == true ||
                               message.ChannelChatCreated == true;

        if (isServiceMessage)
        {
            logger.LogInformation(
                "Detected service message: Type={Type}, MessageId={MessageId}, ChatId={ChatId}",
                message.Type,
                message.MessageId,
                message.Chat.Id);

            try
            {
                await botClient.DeleteMessage(
                    chatId: message.Chat.Id,
                    messageId: message.MessageId,
                    cancellationToken: cancellationToken);

                logger.LogInformation(
                    "Deleted service message (type: {Type}) in chat {ChatId}",
                    message.Type,
                    message.Chat.Id);
            }
            catch (Exception ex)
            {
                logger.LogWarning(
                    ex,
                    "Failed to delete service message {MessageId} in chat {ChatId}",
                    message.MessageId,
                    message.Chat.Id);
            }
            return; // Don't process service messages further
        }

        // Process messages from all group chats where bot is added
        try
        {
            var now = DateTimeOffset.UtcNow;

            // Update last_seen_at for this chat (also auto-adds chat if it doesn't exist)
            // Then refresh admin cache for newly discovered chats OR chats with empty admin cache
            using var scope = serviceProvider.CreateScope();
            var managedChatsRepository = scope.ServiceProvider.GetRequiredService<IManagedChatsRepository>();
            var existingChat = await managedChatsRepository.GetByChatIdAsync(message.Chat.Id, cancellationToken);
            var isNewChat = existingChat == null;

            await managedChatsRepository.UpdateLastSeenAsync(message.Chat.Id, now, cancellationToken);

            // Check if we need to refresh admin cache (only for groups/supergroups, not private DMs)
            if (message.Chat.Type == ChatType.Group || message.Chat.Type == ChatType.Supergroup)
            {
                bool shouldRefreshAdmins = false;
                string refreshReason = "";

                if (isNewChat)
                {
                    shouldRefreshAdmins = true;
                    refreshReason = "newly discovered chat";
                }
                else
                {
                    // Check if admin cache is empty for this chat
                    var chatAdminsRepository = scope.ServiceProvider.GetRequiredService<IChatAdminsRepository>();
                    var adminCount = await chatAdminsRepository.GetAdminCountAsync(message.Chat.Id, cancellationToken);

                    if (adminCount == 0)
                    {
                        shouldRefreshAdmins = true;
                        refreshReason = "admin cache is empty";
                    }
                }

                if (shouldRefreshAdmins)
                {
                    logger.LogInformation(
                        "Refreshing admin cache for chat {ChatId} ({Reason})",
                        message.Chat.Id,
                        refreshReason);

                    try
                    {
                        await chatManagementService.RefreshChatAdminsAsync(botClient, message.Chat.Id, cancellationToken);
                    }
                    catch (Exception ex)
                    {
                        logger.LogWarning(ex, "Failed to refresh admins for chat {ChatId}", message.Chat.Id);
                    }
                }
            }
            else
            {
                if (isNewChat)
                {
                    logger.LogDebug("Discovered new private chat {ChatId}, skipping admin cache refresh", message.Chat.Id);
                }
            }

            // Check if message is a bot command (execute first, then save to history)
            // Note: Errors are caught to ensure message history is always saved
            CommandResult? commandResult = null;
            if (commandRouter.IsCommand(message))
            {
                try
                {
                    commandResult = await commandRouter.RouteCommandAsync(botClient, message, cancellationToken);
                    if (commandResult != null)
                    {
                        // Send response if there is one (and it's not empty)
                        if (commandResult.Response != null && !string.IsNullOrWhiteSpace(commandResult.Response))
                        {
                            var responseMessage = await botClient.SendMessage(
                                chatId: message.Chat.Id,
                                text: commandResult.Response,
                                parseMode: ParseMode.Markdown,
                                replyParameters: new ReplyParameters { MessageId = message.MessageId },
                                cancellationToken: cancellationToken);

                            // Schedule auto-delete if requested
                            if (commandResult.DeleteResponseAfterSeconds.HasValue)
                            {
                                await ScheduleMessageDeleteAsync(
                                    message.Chat.Id,
                                    responseMessage.MessageId,
                                    commandResult.DeleteResponseAfterSeconds.Value,
                                    "command_response",
                                    cancellationToken);
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError(ex,
                        "Error executing command in chat {ChatId}, message will still be saved to history",
                        message.Chat.Id);
                    // Continue to save message to history regardless of command error
                }
                // Continue to save command message to history (don't return early)
            }

            // Check for @admin mentions (independent of commands)
            // Note: Errors are caught to ensure message history is always saved
            var text = message.Text ?? message.Caption;
            if (!string.IsNullOrWhiteSpace(text))
            {
                try
                {
                    using var mentionScope = serviceProvider.CreateScope();
                    var adminMentionHandler = mentionScope.ServiceProvider.GetRequiredService<AdminMentionHandler>();
                    if (adminMentionHandler.ContainsAdminMention(text))
                    {
                        await adminMentionHandler.NotifyAdminsAsync(botClient, message, cancellationToken);
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError(ex,
                        "Error handling @admin mention in chat {ChatId}, message will still be saved to history",
                        message.Chat.Id);
                    // Continue to save message to history regardless of error
                }
            }

            // Extract URLs from message text
            var urls = UrlUtilities.ExtractUrls(text);

            // Get photo file ID if present and download image
            string? photoFileId = null;
            int? photoFileSize = null;
            string? photoLocalPath = null;
            string? photoThumbnailPath = null;

            if (message.Photo is { Length: > 0 } photos)
            {
                var largestPhoto = photos.OrderByDescending(p => p.FileSize).First();
                photoFileId = largestPhoto.FileId;
                photoFileSize = largestPhoto.FileSize.HasValue ? (int)largestPhoto.FileSize.Value : null;

                // Download and process image
                (photoLocalPath, photoThumbnailPath) = await DownloadAndProcessImageAsync(
                    botClient,
                    photoFileId,
                    message.Chat.Id,
                    message.MessageId,
                    cancellationToken);
            }

            // Phase 4.X: Download and save media attachments (GIF, Video, Audio, Voice, Sticker, VideoNote)
            MediaType? mediaType = null;
            string? mediaFileId = null;
            long? mediaFileSize = null;
            string? mediaFileName = null;
            string? mediaMimeType = null;
            string? mediaLocalPath = null;
            int? mediaDuration = null;

            var mediaInfo = DetectMediaAttachment(message);
            if (mediaInfo.HasValue)
            {
                mediaType = mediaInfo.Value.MediaType;
                mediaFileId = mediaInfo.Value.FileId;
                mediaFileSize = mediaInfo.Value.FileSize;
                mediaFileName = mediaInfo.Value.FileName;
                mediaMimeType = mediaInfo.Value.MimeType;
                mediaDuration = mediaInfo.Value.Duration;

                // Download and save media file (EXCEPT Documents - metadata only for Documents)
                // Document files are only downloaded temporarily by the file scanner for malware detection
                if (mediaInfo.Value.MediaType != MediaType.Document)
                {
                    mediaLocalPath = await _mediaService.DownloadAndSaveMediaAsync(
                        mediaInfo.Value.FileId,
                        mediaInfo.Value.MediaType,
                        mediaInfo.Value.FileName,
                        message.Chat.Id,
                        message.MessageId,
                        cancellationToken);
                }
                // For Documents: mediaLocalPath stays null, UI will show filename/icon only
            }

            // Phase 4.14: Schedule file scanning for Document attachments only
            // Photos are handled separately above (image spam detection via OpenAI Vision)
            // Media files (GIF/Video/Audio/Voice/Sticker) are NOT scanned (cannot contain executable malware)
            if (HasFileAttachment(message, out var fileId, out var fileSize, out var fileName, out var contentType))
            {
                await ScheduleFileScanJobAsync(
                    message.MessageId,
                    message.Chat.Id,
                    message.From!.Id,
                    fileId!,
                    fileSize,
                    fileName,
                    contentType,
                    cancellationToken);
            }

            // Calculate content hash for spam correlation
            var urlsJson = urls != null ? JsonSerializer.Serialize(urls) : "";
            var contentHash = HashUtilities.ComputeContentHash(text ?? "", urlsJson);

            // Check if chat icon is cached on disk
            var chatIconFileName = $"{Math.Abs(message.Chat.Id)}.jpg";
            var chatIconCachedPath = Path.Combine(_historyOptions.ImageStoragePath, "chat_icons", chatIconFileName);
            var chatIconPath = File.Exists(chatIconCachedPath) ? $"chat_icons/{chatIconFileName}" : null;

            // User photo will be fetched asynchronously after message save (non-blocking)
            var messageRecord = new MessageRecord(
                message.MessageId,
                message.From!.Id,
                message.From.Username,
                message.From.FirstName,
                message.Chat.Id,
                now,
                text,
                photoFileId,
                photoFileSize,
                urlsJson != "" ? urlsJson : null,
                EditDate: message.EditDate.HasValue ? new DateTimeOffset(message.EditDate.Value, TimeSpan.Zero) : null,
                ContentHash: contentHash,
                ChatName: message.Chat.Title ?? message.Chat.Username,
                PhotoLocalPath: photoLocalPath,
                PhotoThumbnailPath: photoThumbnailPath,
                ChatIconPath: chatIconPath,
                UserPhotoPath: null, // Will be populated by background task
                DeletedAt: null,
                DeletionSource: null,
                ReplyToMessageId: message.ReplyToMessage?.MessageId,
                ReplyToUser: null, // Populated by repository queries via JOIN
                ReplyToText: null, // Populated by repository queries via JOIN
                // Media attachment fields (Phase 4.X)
                MediaType: mediaType,
                MediaFileId: mediaFileId,
                MediaFileSize: mediaFileSize,
                MediaFileName: mediaFileName,
                MediaMimeType: mediaMimeType,
                MediaLocalPath: mediaLocalPath,
                MediaDuration: mediaDuration
            );

            // Save message to database using a scoped repository
            using var messageScope = _scopeFactory.CreateScope();
            var repository = messageScope.ServiceProvider.GetRequiredService<IMessageHistoryRepository>();
            await repository.InsertMessageAsync(messageRecord, cancellationToken);

            // Upsert user into telegram_users table (centralized user tracking)
            var telegramUserRepo = messageScope.ServiceProvider.GetRequiredService<ITelegramUserRepository>();
            var telegramUser = new TelegramGroupsAdmin.Telegram.Models.TelegramUser(
                TelegramUserId: message.From!.Id,
                Username: message.From.Username,
                FirstName: message.From.FirstName,
                LastName: message.From.LastName,
                UserPhotoPath: null, // Will be populated by FetchUserPhotoJob
                PhotoHash: null,
                IsTrusted: false,
                BotDmEnabled: false, // Will be set to true when user sends /start in private chat
                FirstSeenAt: now,
                LastSeenAt: now,
                CreatedAt: now,
                UpdatedAt: now
            );
            await telegramUserRepo.UpsertAsync(telegramUser, cancellationToken);

            // Phase 4.10: Check for impersonation (name + photo similarity vs admins)
            // Check users on their first N messages
            var impersonationService = messageScope.ServiceProvider.GetRequiredService<IImpersonationDetectionService>();
            var shouldCheck = await impersonationService.ShouldCheckUserAsync(message.From!.Id, message.Chat.Id);

            if (shouldCheck)
            {
                logger.LogDebug(
                    "Checking user {UserId} for impersonation on message #{MessageCount}",
                    message.From.Id,
                    message.MessageId);

                // Get cached user photo path (may be null if not fetched yet)
                var existingUser = await telegramUserRepo.GetByTelegramIdAsync(message.From.Id, cancellationToken);
                var photoPath = existingUser?.UserPhotoPath;

                // Check for impersonation
                var impersonationResult = await impersonationService.CheckUserAsync(
                    message.From.Id,
                    message.Chat.Id,
                    message.From.FirstName,
                    message.From.LastName,
                    photoPath);

                if (impersonationResult != null)
                {
                    logger.LogWarning(
                        "Impersonation detected for user {UserId} in chat {ChatId} (score: {Score}, risk: {Risk})",
                        message.From.Id,
                        message.Chat.Id,
                        impersonationResult.TotalScore,
                        impersonationResult.RiskLevel);

                    // Execute action (create alert, auto-ban if score >= 100)
                    await impersonationService.ExecuteActionAsync(impersonationResult);

                    // If auto-banned, message will remain in history for audit trail
                    // User will be banned from all chats immediately
                    if (impersonationResult.ShouldAutoBan)
                    {
                        logger.LogInformation(
                            "User {UserId} auto-banned for impersonation (score: {Score})",
                            message.From.Id,
                            impersonationResult.TotalScore);
                    }
                }
            }

            // Raise event for real-time UI updates
            OnNewMessage?.Invoke(messageRecord);

            logger.LogDebug(
                "Cached message {MessageId} from user {UserId} in chat {ChatId} (photo: {HasPhoto}, text: {HasText})",
                message.MessageId,
                message.From.Id,
                message.Chat.Id,
                photoFileId != null,
                text != null);

            // Delete command message if requested (AFTER saving to database for FK integrity)
            if (commandResult?.DeleteCommandMessage == true)
            {
                try
                {
                    await botClient.DeleteMessage(
                        chatId: message.Chat.Id,
                        messageId: message.MessageId,
                        cancellationToken: cancellationToken);

                    logger.LogDebug("Deleted command message {MessageId} in chat {ChatId}", message.MessageId, message.Chat.Id);
                }
                catch (Exception ex)
                {
                    logger.LogWarning(ex, "Failed to delete command message {MessageId} in chat {ChatId}", message.MessageId, message.Chat.Id);
                }
            }

            // Fetch user profile photo via TickerQ (0s delay for instant execution, with persistence/retry)
            if (message.From?.Id != null)
            {
                await ScheduleUserPhotoFetchAsync(message.MessageId, message.From.Id, cancellationToken);
            }

            // Phase 2.6: Automatic spam detection with detection result storage
            // Skip spam detection for command messages (already processed by CommandRouter)
            if (commandResult == null && !string.IsNullOrWhiteSpace(text))
            {
                _ = Task.Run(async () =>
                {
                    await RunSpamDetectionAsync(botClient, message, text, editVersion: 0, CancellationToken.None);
                }, CancellationToken.None);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Error caching message {MessageId} from user {UserId} in chat {ChatId}",
                message.MessageId,
                message.From?.Id,
                message.Chat?.Id);
        }
    }

    /// <summary>
    /// Handle edited messages: save edit history, update message, re-scan for spam
    /// </summary>
    public async Task HandleEditedMessageAsync(ITelegramBotClient botClient, Message editedMessage, CancellationToken cancellationToken = default)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var repository = scope.ServiceProvider.GetRequiredService<IMessageHistoryRepository>();

            // Get the old message from the database
            var oldMessage = await repository.GetMessageAsync(editedMessage.MessageId, cancellationToken);
            if (oldMessage == null)
            {
                logger.LogWarning(
                    "Received edit for unknown message {MessageId}",
                    editedMessage.MessageId);
                return;
            }

            var oldText = oldMessage.MessageText;
            var newText = editedMessage.Text ?? editedMessage.Caption;

            // Skip if text hasn't actually changed
            if (oldText == newText)
            {
                logger.LogDebug(
                    "Edit event for message {MessageId} but text unchanged, skipping",
                    editedMessage.MessageId);
                return;
            }

            var editDate = editedMessage.EditDate.HasValue
                ? new DateTimeOffset(editedMessage.EditDate.Value, TimeSpan.Zero)
                : DateTimeOffset.UtcNow;

            // Extract URLs and calculate content hashes
            var oldUrls = UrlUtilities.ExtractUrls(oldText);
            var newUrls = UrlUtilities.ExtractUrls(newText);

            var oldContentHash = HashUtilities.ComputeContentHash(oldText ?? "", oldUrls != null ? JsonSerializer.Serialize(oldUrls) : "");
            var newContentHash = HashUtilities.ComputeContentHash(newText ?? "", newUrls != null ? JsonSerializer.Serialize(newUrls) : "");

            // Create edit record
            var editRecord = new MessageEditRecord(
                Id: 0, // Will be set by INSERT
                MessageId: editedMessage.MessageId,
                EditDate: editDate,
                OldText: oldText,
                NewText: newText,
                OldContentHash: oldContentHash,
                NewContentHash: newContentHash
            );

            await repository.InsertMessageEditAsync(editRecord, cancellationToken);

            // Update the message in the messages table with new text and edit date
            var updatedMessage = oldMessage with
            {
                MessageText = newText,
                EditDate = editDate,
                Urls = newUrls != null ? JsonSerializer.Serialize(newUrls) : null,
                ContentHash = newContentHash
            };
            await repository.UpdateMessageAsync(updatedMessage, cancellationToken);

            // Raise event for real-time UI updates
            OnMessageEdited?.Invoke(editRecord);

            logger.LogInformation(
                "Recorded edit for message {MessageId} in chat {ChatId}",
                editedMessage.MessageId,
                editedMessage.Chat.Id);

            // Phase 2.7: Re-scan edited message for spam (detect "post innocent, edit to spam" tactic)
            if (!string.IsNullOrWhiteSpace(newText))
            {
                _ = Task.Run(async () =>
                {
                    try
                    {
                        using var scope = serviceProvider.CreateScope();
                        var detectionResultsRepo = scope.ServiceProvider.GetRequiredService<IDetectionResultsRepository>();

                        // Get the latest edit_version for this message
                        var existingResults = await detectionResultsRepo.GetByMessageIdAsync(editedMessage.MessageId, CancellationToken.None);
                        var maxEditVersion = existingResults.Any()
                            ? existingResults.Max(r => r.EditVersion)
                            : 0;

                        await RunSpamDetectionAsync(botClient, editedMessage, newText, editVersion: maxEditVersion + 1, CancellationToken.None);
                    }
                    catch (Exception ex)
                    {
                        logger.LogError(ex, "Failed to re-scan edited message {MessageId} for spam", editedMessage.MessageId);
                    }
                }, CancellationToken.None);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Error handling edit for message {MessageId}",
                editedMessage.MessageId);
        }
    }

    /// <summary>
    /// Run spam detection on a message and take appropriate actions
    /// </summary>
    private async Task RunSpamDetectionAsync(ITelegramBotClient botClient, Message message, string text, int editVersion, CancellationToken cancellationToken = default)
    {
        try
        {
            using var scope = serviceProvider.CreateScope();
            var coordinator = scope.ServiceProvider.GetRequiredService<IContentCheckCoordinator>();
            var detectionResultsRepo = scope.ServiceProvider.GetRequiredService<IDetectionResultsRepository>();
            var spamDetectionEngine = scope.ServiceProvider.GetRequiredService<TelegramGroupsAdmin.ContentDetection.Services.IContentDetectionEngine>();

            var request = new TelegramGroupsAdmin.ContentDetection.Models.ContentCheckRequest
            {
                Message = text,
                UserId = message.From?.Id ?? 0,
                UserName = message.From?.Username,
                ChatId = message.Chat.Id
            };

            var result = await coordinator.CheckAsync(request, cancellationToken);

            // Phase 4.14: Handle critical check violations FIRST (before regular spam)
            // Critical violations apply to ALL users (trusted/admin included)
            if (result.HasCriticalViolations)
            {
                logger.LogWarning(
                    "Critical check violations detected for message {MessageId} from user {UserId}: {Violations}",
                    message.MessageId,
                    message.From?.Id,
                    string.Join("; ", result.CriticalCheckViolations));

                // Use SpamActionService to handle critical violations
                // Policy: Delete + DM notice, NO ban/warn for trusted/admin users
                await spamActionService.HandleCriticalCheckViolationAsync(
                    botClient,
                    message,
                    result.CriticalCheckViolations,
                    cancellationToken).ConfigureAwait(false);

                // If critical violations found, don't process regular spam (already handled)
                return;
            }

            // Store detection result (spam or ham) for analytics and training
            // Only store if spam detection actually ran (not skipped for trusted/admin users)
            if (!result.SpamCheckSkipped && result.SpamResult != null)
            {
                var reasonPrefix = editVersion > 0 ? $"[Edit #{editVersion}] " : "";

                var detectionResult = new DetectionResultRecord
                {
                    MessageId = message.MessageId,
                    DetectedAt = DateTimeOffset.UtcNow,
                    DetectionSource = "auto",
                    DetectionMethod = result.SpamResult.CheckResults.Count > 0
                        ? string.Join(", ", result.SpamResult.CheckResults.Select(c => c.CheckName))
                        : "Unknown",
                    // IsSpam is computed from net_confidence (don't set it here)
                    Confidence = result.SpamResult.MaxConfidence,
                    Reason = $"{reasonPrefix}{result.SpamResult.PrimaryReason}",
                    AddedBy = Actor.AutoDetection, // Phase 4.19: Actor system
                    UsedForTraining = SpamActionService.DetermineIfTrainingWorthy(result.SpamResult),
                    NetConfidence = result.SpamResult.NetConfidence,
                    CheckResultsJson = spamDetectionEngine.GetType()
                        .GetMethod("SerializeCheckResults", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)
                        ?.Invoke(null, new object[] { result.SpamResult.CheckResults }) as string,
                    EditVersion = editVersion
                };

                await detectionResultsRepo.InsertAsync(detectionResult, cancellationToken);

                var editInfo = editVersion > 0 ? $" (edit #{editVersion})" : "";
                logger.LogInformation(
                    "Stored detection result for message {MessageId}{EditInfo}: {IsSpam} (net: {NetConfidence}, training: {UsedForTraining})",
                    message.MessageId,
                    editInfo,
                    result.SpamResult.IsSpam ? "spam" : "ham",
                    result.SpamResult.NetConfidence,
                    detectionResult.UsedForTraining);

                // Check for auto-trust after storing non-spam detection result
                if (!result.SpamResult.IsSpam && message.From?.Id != null)
                {
                    var autoTrustService = scope.ServiceProvider.GetRequiredService<UserAutoTrustService>();
                    await autoTrustService.CheckAndApplyAutoTrustAsync(message.From.Id, message.Chat.Id, cancellationToken);
                }

                // Phase 2.7: Handle spam actions based on net confidence
                await spamActionService.HandleSpamDetectionActionsAsync(
                    message,
                    result.SpamResult,
                    detectionResult,
                    cancellationToken);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to run spam detection for message {MessageId}", message.MessageId);
        }
    }


    /// <summary>
    /// Download and process image from Telegram (full + thumbnail)
    /// </summary>
    private async Task<(string? fullPath, string? thumbPath)> DownloadAndProcessImageAsync(
        ITelegramBotClient botClient,
        string photoFileId,
        long chatId,
        long messageId,
        CancellationToken cancellationToken = default)
    {
        try
        {
            // Create directory structure: {ImageStoragePath}/full/{chat_id}/ and thumbs/{chat_id}/
            var basePath = _historyOptions.ImageStoragePath;
            var fullDir = Path.Combine(basePath, "full", chatId.ToString());
            var thumbDir = Path.Combine(basePath, "thumbs", chatId.ToString());

            Directory.CreateDirectory(fullDir);
            Directory.CreateDirectory(thumbDir);

            var fileName = $"{messageId}.jpg";
            var fullPath = Path.Combine(fullDir, fileName);
            var thumbPath = Path.Combine(thumbDir, fileName);

            // Download file from Telegram
            var file = await botClient.GetFile(photoFileId, cancellationToken);
            if (file.FilePath == null)
            {
                logger.LogWarning("Unable to get file path for photo {FileId}", photoFileId);
                return (null, null);
            }

            // Download to temp file first
            var tempPath = Path.GetTempFileName();
            try
            {
                await using (var fileStream = System.IO.File.Create(tempPath))
                {
                    await botClient.DownloadFile(file.FilePath, fileStream, cancellationToken);
                }

                // Copy to full image location
                System.IO.File.Copy(tempPath, fullPath, overwrite: true);

                // Generate thumbnail using ImageSharp
                using (var image = await Image.LoadAsync(tempPath, cancellationToken))
                {
                    var thumbnailSize = _historyOptions.ThumbnailSize;
                    image.Mutate(x => x.Resize(new ResizeOptions
                    {
                        Size = new Size(thumbnailSize, thumbnailSize),
                        Mode = ResizeMode.Max // Maintain aspect ratio
                    }));

                    await image.SaveAsJpegAsync(thumbPath, cancellationToken);
                }

                logger.LogDebug(
                    "Downloaded and processed image for message {MessageId} in chat {ChatId}",
                    messageId, chatId);

                // Return relative paths for storage in database
                return ($"full/{chatId}/{fileName}", $"thumbs/{chatId}/{fileName}");
            }
            finally
            {
                // Clean up temp file
                if (System.IO.File.Exists(tempPath))
                    System.IO.File.Delete(tempPath);
            }
        }
        catch (IOException ioEx)
        {
            // Disk full or permissions error - fail open (don't block message, just skip image)
            logger.LogWarning(ioEx,
                "Filesystem error downloading image for message {MessageId} in chat {ChatId}. Message will be stored without image.",
                messageId, chatId);
            return (null, null);
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Error downloading/processing image for message {MessageId} in chat {ChatId}",
                messageId, chatId);
            return (null, null);
        }
    }


    /// <summary>
    /// Schedule a message for deletion via TickerQ
    /// </summary>
    private async Task ScheduleMessageDeleteAsync(long chatId, int messageId, int delaySeconds, string reason, CancellationToken cancellationToken = default)
    {
        var deletePayload = new TelegramGroupsAdmin.Telegram.Abstractions.Jobs.DeleteMessagePayload(
            chatId,
            messageId,
            reason
        );

        await TickerQUtilities.ScheduleJobAsync(
            serviceProvider,
            logger,
            "DeleteMessage",
            deletePayload,
            delaySeconds,
            retries: 0);
    }

    /// <summary>
    /// Schedule user photo fetch via TickerQ with 0s delay (instant execution with persistence/retry)
    /// </summary>
    private async Task ScheduleUserPhotoFetchAsync(long messageId, long userId, CancellationToken cancellationToken = default)
    {
        var photoPayload = new TelegramGroupsAdmin.Telegram.Abstractions.Jobs.FetchUserPhotoPayload(
            messageId,
            userId
        );

        await TickerQUtilities.ScheduleJobAsync(
            serviceProvider,
            logger,
            "FetchUserPhoto",
            photoPayload,
            delaySeconds: 0,
            retries: 2);
    }

    /// <summary>
    /// Schedule file scanning via TickerQ with 0s delay for instant execution
    /// Phase 4.14: Downloads file to temp, scans with ClamAV+VirusTotal, deletes if infected
    /// Temp file deleted after scan (no persistent storage)
    /// </summary>
    private async Task ScheduleFileScanJobAsync(
        long messageId,
        long chatId,
        long userId,
        string fileId,
        long fileSize,
        string? fileName,
        string? contentType,
        CancellationToken cancellationToken = default)
    {
        var scanPayload = new TelegramGroupsAdmin.Telegram.Abstractions.Jobs.FileScanJobPayload(
            MessageId: messageId,
            ChatId: chatId,
            UserId: userId,
            FileId: fileId,
            FileSize: fileSize,
            FileName: fileName,
            ContentType: contentType
        );

        logger.LogInformation(
            "Scheduling file scan for '{FileName}' ({FileSize} bytes) from user {UserId} in chat {ChatId}",
            fileName ?? "unknown",
            fileSize,
            userId,
            chatId);

        await TickerQUtilities.ScheduleJobAsync(
            serviceProvider,
            logger,
            "FileScan",
            scanPayload,
            delaySeconds: 0,
            retries: 3); // Higher retries than photo fetch (ClamAV restart, VT rate limit scenarios)
    }

    /// <summary>
    /// Check if message has a scannable file attachment (Document type only)
    /// Phase 4.14: Only scan documents (PDF, EXE, ZIP, Office files, etc.)
    /// Excludes: Animation/GIF, Video, Audio, Voice, Sticker, VideoNote (media files cannot contain executable malware)
    /// Photos are handled separately via image spam detection (OpenAI Vision)
    /// Returns true if scannable document found, with out parameters for file metadata
    ///
    /// IMPORTANT: Telegram sends GIFs with BOTH Animation and Document properties set.
    /// We must check for media properties first to avoid scanning GIFs as documents.
    /// </summary>
    private static bool HasFileAttachment(
        Message message,
        out string? fileId,
        out long fileSize,
        out string? fileName,
        out string? contentType)
    {
        fileId = null;
        fileSize = 0;
        fileName = null;
        contentType = null;

        // CRITICAL: Check if this is actually a media file BEFORE checking Document
        // Telegram populates BOTH Animation+Document for GIFs, Video+Document for videos, etc.
        // We only want to scan pure Document attachments (PDFs, executables, Office files)
        if (message.Animation != null ||
            message.Video != null ||
            message.Audio != null ||
            message.Voice != null ||
            message.Sticker != null ||
            message.VideoNote != null)
        {
            return false; // This is a media file, not a scannable document
        }

        // Only scan pure Document type (PDF, DOCX, EXE, ZIP, APK, etc.)
        // Media files cannot contain executable malware
        if (message.Document != null)
        {
            fileId = message.Document.FileId;
            fileSize = message.Document.FileSize ?? 0;
            fileName = message.Document.FileName;
            contentType = message.Document.MimeType;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Detect media attachment in message and extract metadata
    /// Phase 4.X: Handles Animation (GIF), Video, Audio, Voice, Sticker, VideoNote, Document
    /// Documents: Metadata saved (filename, size) but NOT downloaded (file scanner handles temporary download for scanning only)
    /// Returns null if no media attachment found, otherwise returns media info struct
    /// </summary>
    private static (MediaType MediaType, string FileId, long FileSize, string? FileName, string? MimeType, int? Duration)? DetectMediaAttachment(Message message)
    {
        // Animation (GIF)
        if (message.Animation != null)
        {
            return (
                MediaType.Animation,
                message.Animation.FileId,
                message.Animation.FileSize ?? 0,
                message.Animation.FileName,
                message.Animation.MimeType ?? "video/mp4",
                message.Animation.Duration
            );
        }

        // Video
        if (message.Video != null)
        {
            return (
                MediaType.Video,
                message.Video.FileId,
                message.Video.FileSize ?? 0,
                message.Video.FileName,
                message.Video.MimeType ?? "video/mp4",
                message.Video.Duration
            );
        }

        // Audio (music files with metadata)
        if (message.Audio != null)
        {
            return (
                MediaType.Audio,
                message.Audio.FileId,
                message.Audio.FileSize ?? 0,
                message.Audio.FileName ?? message.Audio.Title ?? $"audio_{message.Audio.FileUniqueId}.mp3",
                message.Audio.MimeType ?? "audio/mpeg",
                message.Audio.Duration
            );
        }

        // Voice message (OGG format voice note)
        if (message.Voice != null)
        {
            return (
                MediaType.Voice,
                message.Voice.FileId,
                message.Voice.FileSize ?? 0,
                $"voice_{message.Voice.FileUniqueId}.ogg",
                message.Voice.MimeType ?? "audio/ogg",
                message.Voice.Duration
            );
        }

        // Sticker (WebP format)
        if (message.Sticker != null)
        {
            return (
                MediaType.Sticker,
                message.Sticker.FileId,
                message.Sticker.FileSize ?? 0,
                $"sticker_{message.Sticker.FileUniqueId}.webp",
                "image/webp",
                null // Stickers don't have duration
            );
        }

        // Video note (circular video message)
        if (message.VideoNote != null)
        {
            return (
                MediaType.VideoNote,
                message.VideoNote.FileId,
                message.VideoNote.FileSize ?? 0,
                $"videonote_{message.VideoNote.FileUniqueId}.mp4",
                "video/mp4",
                message.VideoNote.Duration
            );
        }

        // Document attachments: Save metadata ONLY (filename, size, MIME type)
        // DON'T download for display - file scanner handles temporary download for malware scanning
        // UI will show document icon with filename but no preview/download link
        if (message.Document != null)
        {
            return (
                MediaType.Document,
                message.Document.FileId,
                message.Document.FileSize ?? 0,
                message.Document.FileName ?? "document",
                message.Document.MimeType,
                null // Documents don't have duration
            );
        }

        return null;
    }
}
