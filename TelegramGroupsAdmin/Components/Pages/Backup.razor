@page "/backup"
@using TelegramGroupsAdmin.Services.Backup
@inject IBackupService BackupService
@inject ISnackbar Snackbar
@inject IJSRuntime JS
@attribute [Authorize]

<PageTitle>System Backup</PageTitle>

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4">
    <MudText Typo="Typo.h4" GutterBottom="true">System Backup</MudText>
    <MudText Typo="Typo.body1" Color="Color.Secondary" Class="mb-4">
        Export a complete backup of all system data (users, messages, spam config, TOTP secrets, etc.)
    </MudText>

    <MudPaper Class="pa-4 mb-4">
        <MudText Typo="Typo.h6" Class="mb-2">Create Backup</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
            This will create a compressed backup file (tar.gz) containing all system data. The file is unencrypted - secure it properly.
        </MudText>

        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   StartIcon="@Icons.Material.Filled.Download"
                   OnClick="ExportBackup"
                   Disabled="@_isExporting">
            @if (_isExporting)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <span>Creating backup...</span>
            }
            else
            {
                <span>Create & Download Backup</span>
            }
        </MudButton>

        @if (_lastBackupSize > 0)
        {
            <MudAlert Severity="Severity.Success" Class="mt-4">
                Backup created successfully! Size: @FormatBytes(_lastBackupSize)
            </MudAlert>
        }
    </MudPaper>

    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h6" Class="mb-2">What's Included</MudText>
        <MudList T="string" Dense="true">
            <MudListItem T="string" Icon="@Icons.Material.Filled.People">Users (with TOTP secrets and passwords)</MudListItem>
            <MudListItem T="string" Icon="@Icons.Material.Filled.Message">Messages and message history</MudListItem>
            <MudListItem T="string" Icon="@Icons.Material.Filled.Security">Spam detection configuration and data</MudListItem>
            <MudListItem T="string" Icon="@Icons.Material.Filled.Block">User actions (bans, warnings, trust)</MudListItem>
            <MudListItem T="string" Icon="@Icons.Material.Filled.Link">Telegram user mappings</MudListItem>
            <MudListItem T="string" Icon="@Icons.Material.Filled.Chat">Managed chats and admins</MudListItem>
            <MudListItem T="string" Icon="@Icons.Material.Filled.Report">User reports</MudListItem>
            <MudListItem T="string" Icon="@Icons.Material.Filled.History">Audit logs</MudListItem>
        </MudList>

        <MudAlert Severity="Severity.Warning" Class="mt-4">
            <MudText Typo="Typo.body2">
                <strong>Security Notice:</strong> This backup contains sensitive data including TOTP secrets and password hashes.
                Store it securely and delete it after transferring to your destination machine.
            </MudText>
        </MudAlert>
    </MudPaper>
</MudContainer>

@code {
    private bool _isExporting = false;
    private long _lastBackupSize = 0;

    private async Task ExportBackup()
    {
        _isExporting = true;
        _lastBackupSize = 0;
        StateHasChanged();

        try
        {
            var backupBytes = await BackupService.ExportAsync();
            _lastBackupSize = backupBytes.Length;

            // Trigger file download
            var fileName = $"telegram_groups_admin_backup_{DateTimeOffset.UtcNow:yyyyMMdd_HHmmss}.tar.gz";
            await JS.InvokeVoidAsync("downloadFile", fileName, Convert.ToBase64String(backupBytes));

            Snackbar.Add($"Backup created successfully! ({FormatBytes(backupBytes.Length)})", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Backup failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isExporting = false;
            StateHasChanged();
        }
    }

    private static string FormatBytes(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }
}
