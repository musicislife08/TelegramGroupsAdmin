@page "/reports"
@using TelegramGroupsAdmin.ContentDetection.Models
@using TelegramGroupsAdmin.ContentDetection.Repositories
@using TelegramGroupsAdmin.Core.Models
@using TelegramGroupsAdmin.Data.Models
@using TelegramGroupsAdmin.Telegram.Services.Moderation
@using TelegramGroupsAdmin.Services
@using TelegramGroupsAdmin.Telegram.Repositories
@using TelegramGroupsAdmin.Telegram.Services
@using TelegramGroupsAdmin.Telegram.Services.Bot
@using TelegramGroupsAdmin.Telegram.Models
@using TelegramGroupsAdmin.Components.Reports
@using TelegramGroupsAdmin.Telegram.Constants
@using TelegramGroupsAdmin.Core.Repositories
@inject IReportsRepository ReportsRepository
@inject IReportActionsService ReportActionsService
@inject IManagedChatsRepository ManagedChatsRepository
@inject IBotModerationService ModerationOrchestrator
@inject IBlazorAuthHelper AuthHelper
@inject ISnackbar Snackbar
@inject ILogger<Reports> Logger
@inject IExamFlowService ExamFlowService
@attribute [Authorize]

<PageTitle>Reports Queue - TelegramGroupsAdmin</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">Reports Queue</MudText>

    @* Filters *@
    <MudPaper Class="pa-3 mb-4" Elevation="1">
        <MudStack Row="true" Spacing="3" AlignItems="AlignItems.Center">
            <MudSelect T="ReportTypeFilter"
                       id="type-filter"
                       Label="Type"
                       Value="_selectedTypeFilter"
                       ValueChanged="OnTypeFilterChanged"
                       Variant="Variant.Outlined"
                       Dense="true">
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.All">All Types</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.Spam">Moderation Reports</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.Impersonation">Impersonation Alerts</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.ExamFailure">Exam Reviews</MudSelectItem>
            </MudSelect>

            <MudSelect T="StatusFilter"
                       id="status-filter"
                       Label="Status"
                       Value="_selectedStatusFilter"
                       ValueChanged="OnStatusFilterChanged"
                       Variant="Variant.Outlined"
                       Dense="true">
                <MudSelectItem T="StatusFilter" Value="@StatusFilter.Pending">Pending Only</MudSelectItem>
                <MudSelectItem T="StatusFilter" Value="@StatusFilter.All">All Statuses</MudSelectItem>
            </MudSelect>

            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Material.Filled.Refresh"
                       OnClick="@LoadReportsAsync"
                       Disabled="_loading">
                Refresh
            </MudButton>

            <MudSpacer />

            <MudStack Row="true" Spacing="2">
                @if (_pendingSpamCount > 0)
                {
                    <MudChip T="string" Color="Color.Warning" Size="Size.Small" Icon="@Icons.Material.Filled.Report">
                        @_pendingSpamCount Moderation
                    </MudChip>
                }
                @if (_pendingImpersonationCount > 0)
                {
                    <MudChip T="string" Color="Color.Error" Size="Size.Small" Icon="@Icons.Material.Filled.Warning">
                        @_pendingImpersonationCount Impersonation
                    </MudChip>
                }
                @if (_pendingExamCount > 0)
                {
                    <MudChip T="string" Color="Color.Info" Size="Size.Small" Icon="@Icons.Material.Filled.Quiz">
                        @_pendingExamCount Exam
                    </MudChip>
                }
            </MudStack>
        </MudStack>
    </MudPaper>

    @* Loading State *@
    @if (_loading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4" />
    }

    @* Unified Reports Queue (Cards) *@
    @if (_filteredReports.Any())
    {
        <MudStack Spacing="3">
            @foreach (var item in _filteredReports)
            {
                @if (item.SpamReport != null)
                {
                    <ModerationReportCard Report="@item.SpamReport"
                                          OnAction="@HandleSpamAction" />
                }
                else if (item.ImpersonationAlert != null)
                {
                    <ImpersonationAlertCard Alert="@item.ImpersonationAlert"
                                            OnAction="@HandleImpersonationAction" />
                }
                else if (item.ExamFailure != null)
                {
                    <ExamReviewCard ExamFailure="@item.ExamFailure"
                                    OnAction="@HandleExamAction" />
                }
            }
        </MudStack>
    }
    else if (!_loading)
    {
        <MudPaper Class="pa-8" Elevation="0">
            <MudStack AlignItems="AlignItems.Center" Spacing="3">
                <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Large" Color="Color.Success" />
                <MudText Typo="Typo.h6" Color="Color.Secondary">No reports found</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">
                    @if (_selectedStatusFilter == StatusFilter.Pending)
                    {
                        <text>All reports have been reviewed!</text>
                    }
                    else
                    {
                        <text>No reports match the selected filters.</text>
                    }
                </MudText>
            </MudStack>
        </MudPaper>
    }
</MudContainer>

@implements IDisposable

@code {
    private enum ReportTypeFilter { All, Spam, Impersonation, ExamFailure }
    private enum StatusFilter { Pending, All }

    private List<ReportQueueItem> _allReports = [];
    private List<ReportQueueItem> _filteredReports = [];
    private ReportTypeFilter _selectedTypeFilter = ReportTypeFilter.All;
    private StatusFilter _selectedStatusFilter = StatusFilter.Pending;
    private bool _loading = true;
    private int _pendingSpamCount;
    private int _pendingImpersonationCount;
    private int _pendingExamCount;
    private string _currentUserId = string.Empty;
    private string _currentUserDisplayName = string.Empty;
    private readonly CancellationTokenSource _cts = new();

    protected override async Task OnInitializedAsync()
    {
        // Get current user ID and display name using auth helper
        _currentUserId = await AuthHelper.GetCurrentUserIdAsync() ?? string.Empty;
        _currentUserDisplayName = await AuthHelper.GetCurrentUserEmailAsync() ?? _currentUserId;

        await LoadReportsAsync();
    }

    protected override void OnParametersSet()
    {
        ApplyFilters();
    }

    private async Task LoadReportsAsync()
    {
        _loading = true;
        StateHasChanged();

        try
        {
            // Get accessible chats for current user (Admin users only see their chats)
            var userId = await AuthHelper.GetCurrentUserIdAsync();
            var permissionLevel = await AuthHelper.GetCurrentPermissionLevelAsync();

            if (string.IsNullOrEmpty(userId))
            {
                Snackbar.Add("Unable to identify current user", Severity.Error);
                return;
            }

            var accessibleChats = await ManagedChatsRepository.GetUserAccessibleChatsAsync(
                userId,
                permissionLevel,
                cancellationToken: _cts.Token);
            var accessibleChatIds = accessibleChats.Select(c => c.Chat.Id).ToHashSet();

            var unifiedQueue = new List<ReportQueueItem>();

            // Load each type using type-specific repository methods
            // This returns properly hydrated models without exposing internal mappings

            // Load moderation reports
            var reports = await ReportsRepository.GetContentReportsAsync(
                chatId: null,
                status: null,
                limit: 100,
                cancellationToken: _cts.Token);

            foreach (var report in reports.Where(r => accessibleChatIds.Contains(r.Chat.Id)))
            {
                unifiedQueue.Add(new ReportQueueItem
                {
                    Type = ReportType.ContentReport,
                    Timestamp = report.ReportedAt,
                    Priority = CalculateReportPriority(report),
                    IsPending = report.Status == ReportStatus.Pending,
                    SpamReport = report,
                    ImpersonationAlert = null,
                    ExamFailure = null,
                    DisplayTitle = "Moderation Report",
                    UserId = report.ReportedByUserId ?? 0,
                    UserName = report.ReportedByUserName
                });
            }

            // Load all impersonation alerts (filter by status is done client-side in ApplyFilters)
            var alerts = await ReportsRepository.GetImpersonationAlertsAsync(
                pendingOnly: false, cancellationToken: _cts.Token);
            foreach (var alert in alerts.Where(a => accessibleChatIds.Contains(a.Chat.Id)))
            {
                unifiedQueue.Add(new ReportQueueItem
                {
                    Type = ReportType.ImpersonationAlert,
                    Timestamp = alert.DetectedAt,
                    Priority = CalculateImpersonationPriority(alert),
                    IsPending = !alert.ReviewedAt.HasValue,
                    SpamReport = null,
                    ImpersonationAlert = alert,
                    ExamFailure = null,
                    DisplayTitle = "Impersonation Alert",
                    UserId = alert.SuspectedUser.Id,
                    UserName = alert.SuspectedUser.Username
                });
            }

            // Load all exam failures (filter by status is done client-side in ApplyFilters)
            var examFailures = await ReportsRepository.GetExamFailuresAsync(
                pendingOnly: false, cancellationToken: _cts.Token);
            foreach (var examFailure in examFailures.Where(e => accessibleChatIds.Contains(e.Chat.Id)))
            {
                unifiedQueue.Add(new ReportQueueItem
                {
                    Type = ReportType.ExamFailure,
                    Timestamp = examFailure.FailedAt,
                    Priority = CalculateExamPriority(examFailure),
                    IsPending = !examFailure.ReviewedAt.HasValue,
                    SpamReport = null,
                    ImpersonationAlert = null,
                    ExamFailure = examFailure,
                    DisplayTitle = "Exam Review",
                    UserId = examFailure.User.Id,
                    UserName = examFailure.User.Username
                });
            }

            // Sort by priority (high → low), then timestamp (new → old)
            _allReports = unifiedQueue
                .OrderByDescending(x => x.Priority)
                .ThenByDescending(x => x.Timestamp)
                .ToList();

            // Update counts
            _pendingSpamCount = unifiedQueue.Count(x => x.Type == ReportType.ContentReport && x.IsPending);
            _pendingImpersonationCount = unifiedQueue.Count(x => x.Type == ReportType.ImpersonationAlert && x.IsPending);
            _pendingExamCount = unifiedQueue.Count(x => x.Type == ReportType.ExamFailure && x.IsPending);

            ApplyFilters();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading reports queue");
            Snackbar.Add("Failed to load reports", Severity.Error);
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private void ApplyFilters()
    {
        var filtered = _allReports.AsEnumerable();

        // Type filter
        if (_selectedTypeFilter != ReportTypeFilter.All)
        {
            var targetType = _selectedTypeFilter switch
            {
                ReportTypeFilter.Spam => ReportType.ContentReport,
                ReportTypeFilter.Impersonation => ReportType.ImpersonationAlert,
                ReportTypeFilter.ExamFailure => ReportType.ExamFailure,
                _ => ReportType.ContentReport
            };
            filtered = filtered.Where(x => x.Type == targetType);
        }

        // Status filter
        if (_selectedStatusFilter == StatusFilter.Pending)
        {
            filtered = filtered.Where(x => x.IsPending);
        }

        _filteredReports = filtered.ToList();
    }

    private void OnTypeFilterChanged(ReportTypeFilter newValue)
    {
        _selectedTypeFilter = newValue;
        ApplyFilters();
        StateHasChanged();
    }

    private void OnStatusFilterChanged(StatusFilter newValue)
    {
        _selectedStatusFilter = newValue;
        ApplyFilters();
        StateHasChanged();
    }

    private int CalculateReportPriority(Report report)
    {
        if (report.Status != ReportStatus.Pending) return 0;
        // Higher priority for newer reports
        var age = (DateTimeOffset.UtcNow - report.ReportedAt).TotalHours;
        return (int)(100 - age); // Newer = higher priority
    }

    private int CalculateImpersonationPriority(ImpersonationAlertRecord alert)
    {
        if (alert.ReviewedAt.HasValue) return 0;

        // Critical impersonation (100 points, auto-banned) = highest priority
        if (alert.RiskLevel == ImpersonationRiskLevel.Critical)
            return 1000 + alert.TotalScore;

        // Medium risk = medium priority
        return 500 + alert.TotalScore;
    }

    private int CalculateExamPriority(ExamFailureRecord examFailure)
    {
        if (examFailure.ReviewedAt.HasValue) return 0;

        // Higher priority for recent failures (users waiting for approval)
        var age = (DateTimeOffset.UtcNow - examFailure.FailedAt).TotalHours;
        return (int)(200 - age); // Higher base priority than reports
    }

    private async Task HandleSpamAction((Report Report, ReportAction Action) args)
    {
        try
        {
            var executor = Actor.FromWebUser(_currentUserId, _currentUserDisplayName);

            switch (args.Action)
            {
                case ReportAction.Spam:
                    await ReportActionsService.HandleSpamActionAsync(args.Report.Id, executor);
                    Snackbar.Add($"Report #{args.Report.Id} processed: Message deleted as spam", Severity.Success);
                    break;

                case ReportAction.Ban:
                    await ReportActionsService.HandleBanActionAsync(args.Report.Id, executor);
                    Snackbar.Add($"Report #{args.Report.Id} processed: User banned", Severity.Success);
                    break;

                case ReportAction.Warn:
                    await ReportActionsService.HandleWarnActionAsync(args.Report.Id, executor);
                    Snackbar.Add($"Report #{args.Report.Id} processed: Warning issued", Severity.Success);
                    break;

                case ReportAction.Dismiss:
                    await ReportActionsService.HandleDismissActionAsync(args.Report.Id, executor);
                    Snackbar.Add($"Report #{args.Report.Id} dismissed", Severity.Info);
                    break;
            }

            await LoadReportsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling spam action {Action} for report {ReportId}", args.Action, args.Report.Id);
            Snackbar.Add($"Failed to process report: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleImpersonationAction((ImpersonationAlertRecord Alert, ImpersonationAction Action) args)
    {
        try
        {
            var executor = Actor.FromWebUser(_currentUserId, _currentUserDisplayName);

            switch (args.Action)
            {
                case ImpersonationAction.Confirm:
                    // Ban the suspected impersonator globally
                    var banResult = await ModerationOrchestrator.BanUserAsync(
                        new BanIntent
                        {
                            User = args.Alert.SuspectedUser,
                            Executor = executor,
                            Reason = $"Impersonation alert #{args.Alert.Id} confirmed - impersonating {args.Alert.TargetUser.DisplayName}"
                        });

                    await ReportsRepository.UpdateStatusAsync(
                        args.Alert.Id,
                        ReportStatus.Reviewed,
                        _currentUserDisplayName,
                        "confirm",
                        $"Confirmed impersonation, banned from {banResult.ChatsAffected} chats");

                    Snackbar.Add($"Impersonation confirmed: User banned from {banResult.ChatsAffected} chats", Severity.Success);
                    break;

                case ImpersonationAction.Dismiss:
                    // Mark as false positive
                    await ReportsRepository.UpdateStatusAsync(
                        args.Alert.Id,
                        ReportStatus.Dismissed,
                        _currentUserDisplayName,
                        "dismiss",
                        "Dismissed as false positive");

                    Snackbar.Add("Alert dismissed", Severity.Info);
                    break;

                case ImpersonationAction.Trust:
                    // Trust the suspected user (they're legitimate)
                    await ModerationOrchestrator.TrustUserAsync(
                        new TrustIntent
                        {
                            User = args.Alert.SuspectedUser,
                            Executor = executor,
                            Reason = $"Trusted after impersonation review #{args.Alert.Id}"
                        });

                    await ReportsRepository.UpdateStatusAsync(
                        args.Alert.Id,
                        ReportStatus.Dismissed,
                        _currentUserDisplayName,
                        "trust",
                        "User trusted - not impersonation");

                    Snackbar.Add("User marked as trusted", Severity.Success);
                    break;
            }

            await LoadReportsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling impersonation action {Action} for alert {AlertId}", args.Action, args.Alert.Id);
            Snackbar.Add($"Failed to process alert: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleExamAction((ExamFailureRecord ExamFailure, ExamAction Action) args)
    {
        Logger.LogInformation("HandleExamAction called: Action={Action}, ExamFailureId={Id}, UserId={UserId}",
            args.Action, args.ExamFailure.Id, args.ExamFailure.User.Id);

        try
        {
            var executor = Actor.FromWebUser(_currentUserId, _currentUserDisplayName);

            switch (args.Action)
            {
                case ExamAction.Approve:
                    // Approve via service (restores permissions, deletes teaser, updates welcome response)
                    var approveResult = await ExamFlowService.ApproveExamFailureAsync(
                        args.ExamFailure.User,
                        args.ExamFailure.Chat,
                        args.ExamFailure.Id,
                        executor);

                    if (!approveResult.Success)
                    {
                        Snackbar.Add($"Failed to approve: {approveResult.ErrorMessage}", Severity.Error);
                        return;
                    }

                    await ReportsRepository.UpdateStatusAsync(
                        args.ExamFailure.Id,
                        ReportStatus.Reviewed,
                        _currentUserDisplayName,
                        "approve",
                        "Manually approved after exam failure");

                    Snackbar.Add("User approved - permissions restored", Severity.Success);
                    break;

                case ExamAction.Deny:
                    // Deny via service (deletes teaser, updates welcome response, kicks user, sends DM)
                    var denyResult = await ExamFlowService.DenyExamFailureAsync(
                        args.ExamFailure.User,
                        args.ExamFailure.Chat,
                        executor);

                    if (!denyResult.Success)
                    {
                        Snackbar.Add($"Failed to deny: {denyResult.ErrorMessage}", Severity.Error);
                        return;
                    }

                    await ReportsRepository.UpdateStatusAsync(
                        args.ExamFailure.Id,
                        ReportStatus.Reviewed,
                        _currentUserDisplayName,
                        "deny",
                        "Denied entry after exam review");

                    Snackbar.Add("User denied - they can re-join to try again", Severity.Warning);
                    break;

                case ExamAction.DenyAndBan:
                    // Deny and ban via service (deletes teaser, updates welcome response, bans globally, sends DM)
                    var denyBanResult = await ExamFlowService.DenyAndBanExamFailureAsync(
                        args.ExamFailure.User,
                        args.ExamFailure.Chat,
                        executor);

                    if (!denyBanResult.Success)
                    {
                        Snackbar.Add($"Failed to deny and ban: {denyBanResult.ErrorMessage}", Severity.Error);
                        return;
                    }

                    await ReportsRepository.UpdateStatusAsync(
                        args.ExamFailure.Id,
                        ReportStatus.Reviewed,
                        _currentUserDisplayName,
                        "deny_ban",
                        "Denied and banned after exam review");

                    Snackbar.Add("User denied and banned globally", Severity.Error);
                    break;
            }

            await LoadReportsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling exam action {Action} for exam failure {ExamId}", args.Action, args.ExamFailure.Id);
            Snackbar.Add($"Failed to process exam review: {ex.Message}", Severity.Error);
        }
    }

    public void Dispose()
    {
        _cts.Cancel();
        _cts.Dispose();
    }
}
