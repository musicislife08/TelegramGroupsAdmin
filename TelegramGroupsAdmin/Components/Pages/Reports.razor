@page "/reports"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using TelegramGroupsAdmin.Auth
@using TelegramGroupsAdmin.Services
@using TelegramGroupsAdmin.Telegram.Models
@using TelegramGroupsAdmin.Telegram.Repositories
@using TelegramGroupsAdmin.Components.Reports
@inject IReportsRepository ReportsRepository
@inject IImpersonationAlertsRepository ImpersonationAlertsRepository
@inject IReportActionsService ReportActionsService
@inject ISnackbar Snackbar
@inject AuthenticationStateProvider AuthStateProvider
@inject ILogger<Reports> Logger
@attribute [Authorize(Roles = "Admin,Owner")]

<PageTitle>Reports Queue - TelegramGroupsAdmin</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">Reports Queue</MudText>

    @* Filters *@
    <MudPaper Class="pa-3 mb-4" Elevation="1">
        <MudStack Row="true" Spacing="3" AlignItems="AlignItems.Center">
            <MudSelect T="ReportTypeFilter"
                       Label="Type"
                       Value="_selectedTypeFilter"
                       ValueChanged="OnTypeFilterChanged"
                       Variant="Variant.Outlined"
                       Dense="true">
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.All">All Types</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.Spam">Moderation Reports</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.Impersonation">Impersonation Alerts</MudSelectItem>
            </MudSelect>

            <MudSelect T="StatusFilter"
                       Label="Status"
                       Value="_selectedStatusFilter"
                       ValueChanged="OnStatusFilterChanged"
                       Variant="Variant.Outlined"
                       Dense="true">
                <MudSelectItem T="StatusFilter" Value="@StatusFilter.Pending">Pending Only</MudSelectItem>
                <MudSelectItem T="StatusFilter" Value="@StatusFilter.All">All Statuses</MudSelectItem>
            </MudSelect>

            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Material.Filled.Refresh"
                       OnClick="LoadReportsAsync"
                       Disabled="_loading">
                Refresh
            </MudButton>

            <MudSpacer />

            <MudStack Row="true" Spacing="2">
                @if (_pendingSpamCount > 0)
                {
                    <MudChip T="string" Color="Color.Warning" Size="Size.Small" Icon="@Icons.Material.Filled.Report">
                        @_pendingSpamCount Moderation
                    </MudChip>
                }
                @if (_pendingImpersonationCount > 0)
                {
                    <MudChip T="string" Color="Color.Error" Size="Size.Small" Icon="@Icons.Material.Filled.Warning">
                        @_pendingImpersonationCount Impersonation
                    </MudChip>
                }
            </MudStack>
        </MudStack>
    </MudPaper>

    @* Loading State *@
    @if (_loading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4" />
    }

    @* Unified Reports Queue (Cards) *@
    @if (_filteredReports.Any())
    {
        <MudStack Spacing="3">
            @foreach (var item in _filteredReports)
            {
                @if (item.SpamReport != null)
                {
                    <ModerationReportCard Report="@item.SpamReport"
                                          OnAction="@HandleSpamAction" />
                }
                else if (item.ImpersonationAlert != null)
                {
                    <ImpersonationAlertCard Alert="@item.ImpersonationAlert"
                                            OnAction="@HandleImpersonationAction" />
                }
            }
        </MudStack>
    }
    else if (!_loading)
    {
        <MudPaper Class="pa-8" Elevation="0">
            <MudStack AlignItems="AlignItems.Center" Spacing="3">
                <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Large" Color="Color.Success" />
                <MudText Typo="Typo.h6" Color="Color.Secondary">No reports found</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">
                    @if (_selectedStatusFilter == StatusFilter.Pending)
                    {
                        <text>All reports have been reviewed!</text>
                    }
                    else
                    {
                        <text>No reports match the selected filters.</text>
                    }
                </MudText>
            </MudStack>
        </MudPaper>
    }
</MudContainer>

@code {
    private enum ReportTypeFilter { All, Spam, Impersonation }
    private enum StatusFilter { Pending, All }

    private List<ReportQueueItem> _allReports = new();
    private List<ReportQueueItem> _filteredReports = new();
    private ReportTypeFilter _selectedTypeFilter = ReportTypeFilter.All;
    private StatusFilter _selectedStatusFilter = StatusFilter.Pending;
    private bool _loading = true;
    private int _pendingSpamCount = 0;
    private int _pendingImpersonationCount = 0;
    private string _currentUserId = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        // Get current user ID
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated == true)
        {
            var userIdClaim = user.FindFirst("sub");
            if (userIdClaim != null)
            {
                _currentUserId = userIdClaim.Value;
            }
        }

        await LoadReportsAsync();
    }

    protected override void OnParametersSet()
    {
        ApplyFilters();
    }

    private async Task LoadReportsAsync()
    {
        _loading = true;
        StateHasChanged();

        try
        {
            var unifiedQueue = new List<ReportQueueItem>();

            // Load spam reports
            var spamReports = await ReportsRepository.GetReportsAsync(
                chatId: null,
                status: null, // Load all, filter client-side
                limit: 100,
                offset: 0);

            foreach (var report in spamReports)
            {
                unifiedQueue.Add(new ReportQueueItem
                {
                    Type = ReportType.Spam,
                    Timestamp = report.ReportedAt,
                    Priority = CalculateSpamPriority(report),
                    IsPending = report.Status == DataModels.ReportStatus.Pending,
                    SpamReport = report,
                    ImpersonationAlert = null,
                    DisplayTitle = "Moderation Report",
                    UserId = report.ReportedByUserId ?? 0,
                    UserName = report.ReportedByUserName
                });
            }

            // Load impersonation alerts
            var impersonationAlerts = await ImpersonationAlertsRepository.GetPendingAlertsAsync(
                chatId: null,
                cancellationToken: default);

            foreach (var alert in impersonationAlerts)
            {
                unifiedQueue.Add(new ReportQueueItem
                {
                    Type = ReportType.Impersonation,
                    Timestamp = alert.DetectedAt,
                    Priority = CalculateImpersonationPriority(alert),
                    IsPending = !alert.ReviewedAt.HasValue,
                    SpamReport = null,
                    ImpersonationAlert = alert,
                    DisplayTitle = "Impersonation Alert",
                    UserId = alert.SuspectedUserId,
                    UserName = alert.SuspectedUserName
                });
            }

            // Sort by priority (high → low), then timestamp (new → old)
            _allReports = unifiedQueue
                .OrderByDescending(x => x.Priority)
                .ThenByDescending(x => x.Timestamp)
                .ToList();

            // Update counts
            _pendingSpamCount = spamReports.Count(r => r.Status == DataModels.ReportStatus.Pending);
            _pendingImpersonationCount = impersonationAlerts.Count(a => !a.ReviewedAt.HasValue);

            ApplyFilters();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading reports queue");
            Snackbar.Add("Failed to load reports", Severity.Error);
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private void ApplyFilters()
    {
        var filtered = _allReports.AsEnumerable();

        // Type filter
        if (_selectedTypeFilter != ReportTypeFilter.All)
        {
            filtered = filtered.Where(x => x.Type == (_selectedTypeFilter == ReportTypeFilter.Spam ? ReportType.Spam : ReportType.Impersonation));
        }

        // Status filter
        if (_selectedStatusFilter == StatusFilter.Pending)
        {
            filtered = filtered.Where(x => x.IsPending);
        }

        _filteredReports = filtered.ToList();
    }

    private void OnTypeFilterChanged(ReportTypeFilter newValue)
    {
        _selectedTypeFilter = newValue;
        ApplyFilters();
        StateHasChanged();
    }

    private void OnStatusFilterChanged(StatusFilter newValue)
    {
        _selectedStatusFilter = newValue;
        ApplyFilters();
        StateHasChanged();
    }

    private int CalculateSpamPriority(Report report)
    {
        if (report.Status != DataModels.ReportStatus.Pending) return 0;
        // Higher priority for newer reports
        var age = (DateTimeOffset.UtcNow - report.ReportedAt).TotalHours;
        return (int)(100 - age); // Newer = higher priority
    }

    private int CalculateImpersonationPriority(ImpersonationAlertRecord alert)
    {
        if (alert.ReviewedAt.HasValue) return 0;

        // Critical impersonation (100 points, auto-banned) = highest priority
        if (alert.RiskLevel == Data.Models.ImpersonationRiskLevel.Critical)
            return 1000 + alert.TotalScore;

        // Medium risk = medium priority
        return 500 + alert.TotalScore;
    }

    private async Task HandleSpamAction((Report Report, string Action) args)
    {
        try
        {
            switch (args.Action)
            {
                case "spam":
                    await ReportActionsService.HandleSpamActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} processed: Message deleted as spam", Severity.Success);
                    break;

                case "ban":
                    await ReportActionsService.HandleBanActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} processed: User banned", Severity.Success);
                    break;

                case "warn":
                    await ReportActionsService.HandleWarnActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} processed: Warning issued", Severity.Success);
                    break;

                case "dismiss":
                    await ReportActionsService.HandleDismissActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} dismissed", Severity.Info);
                    break;

                default:
                    Snackbar.Add($"Unknown action: {args.Action}", Severity.Error);
                    return;
            }

            await LoadReportsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling spam action {Action} for report {ReportId}", args.Action, args.Report.Id);
            Snackbar.Add($"Failed to process report: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleImpersonationAction((ImpersonationAlertRecord Alert, string Action) args)
    {
        try
        {
            switch (args.Action)
            {
                case "confirm":
                    // Confirm as scam (Phase 4.10)
                    await ImpersonationAlertsRepository.UpdateVerdictAsync(
                        args.Alert.Id,
                        Data.Models.ImpersonationVerdict.ConfirmedScam,
                        _currentUserId);
                    Snackbar.Add($"Impersonation confirmed for user {args.Alert.SuspectedUserId}", Severity.Success);
                    break;

                case "unban":
                    // Unban + mark as false positive (Phase 4.10)
                    await ImpersonationAlertsRepository.UpdateVerdictAsync(
                        args.Alert.Id,
                        Data.Models.ImpersonationVerdict.FalsePositive,
                        _currentUserId);
                    Snackbar.Add($"User {args.Alert.SuspectedUserId} marked as false positive (unban pending)", Severity.Info);
                    break;

                case "dismiss":
                    // Whitelist (not scam, but also not false positive)
                    await ImpersonationAlertsRepository.UpdateVerdictAsync(
                        args.Alert.Id,
                        Data.Models.ImpersonationVerdict.Whitelisted,
                        _currentUserId);
                    Snackbar.Add($"User whitelisted", Severity.Info);
                    break;

                default:
                    Snackbar.Add($"Unknown action: {args.Action}", Severity.Error);
                    return;
            }

            await LoadReportsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling impersonation action {Action} for alert {AlertId}", args.Action, args.Alert.Id);
            Snackbar.Add($"Failed to process alert: {ex.Message}", Severity.Error);
        }
    }
}
