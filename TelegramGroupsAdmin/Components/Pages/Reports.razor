@page "/reports"
@using Microsoft.AspNetCore.Components.Authorization
@using TelegramGroupsAdmin.ContentDetection.Models
@using TelegramGroupsAdmin.ContentDetection.Repositories
@using TelegramGroupsAdmin.Core.Models
@using TelegramGroupsAdmin.Services
@using TelegramGroupsAdmin.Telegram.Repositories
@using TelegramGroupsAdmin.Components.Reports
@inject IReportsRepository ReportsRepository
@* TODO Phase 2.9: Replace with IReviewsRepository for unified reviews UI *@
@* @inject IReviewsRepository ReviewsRepository *@
@inject IReportActionsService ReportActionsService
@inject IManagedChatsRepository ManagedChatsRepository
@inject IBlazorAuthHelper AuthHelper
@inject ISnackbar Snackbar
@inject AuthenticationStateProvider AuthStateProvider
@inject ILogger<Reports> Logger
@attribute [Authorize]

<PageTitle>Reports Queue - TelegramGroupsAdmin</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">Reports Queue</MudText>

    @* Filters *@
    <MudPaper Class="pa-3 mb-4" Elevation="1">
        <MudStack Row="true" Spacing="3" AlignItems="AlignItems.Center">
            <MudSelect T="ReportTypeFilter"
                       id="type-filter"
                       Label="Type"
                       Value="_selectedTypeFilter"
                       ValueChanged="OnTypeFilterChanged"
                       Variant="Variant.Outlined"
                       Dense="true">
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.All">All Types</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.Spam">Moderation Reports</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.Impersonation">Impersonation Alerts</MudSelectItem>
            </MudSelect>

            <MudSelect T="StatusFilter"
                       id="status-filter"
                       Label="Status"
                       Value="_selectedStatusFilter"
                       ValueChanged="OnStatusFilterChanged"
                       Variant="Variant.Outlined"
                       Dense="true">
                <MudSelectItem T="StatusFilter" Value="@StatusFilter.Pending">Pending Only</MudSelectItem>
                <MudSelectItem T="StatusFilter" Value="@StatusFilter.All">All Statuses</MudSelectItem>
            </MudSelect>

            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Material.Filled.Refresh"
                       OnClick="@LoadReportsAsync"
                       Disabled="_loading">
                Refresh
            </MudButton>

            <MudSpacer />

            <MudStack Row="true" Spacing="2">
                @if (_pendingSpamCount > 0)
                {
                    <MudChip T="string" Color="Color.Warning" Size="Size.Small" Icon="@Icons.Material.Filled.Report">
                        @_pendingSpamCount Moderation
                    </MudChip>
                }
                @if (_pendingImpersonationCount > 0)
                {
                    <MudChip T="string" Color="Color.Error" Size="Size.Small" Icon="@Icons.Material.Filled.Warning">
                        @_pendingImpersonationCount Impersonation
                    </MudChip>
                }
            </MudStack>
        </MudStack>
    </MudPaper>

    @* Loading State *@
    @if (_loading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4" />
    }

    @* Unified Reports Queue (Cards) *@
    @if (_filteredReports.Any())
    {
        <MudStack Spacing="3">
            @foreach (var item in _filteredReports)
            {
                @if (item.SpamReport != null)
                {
                    <ModerationReportCard Report="@item.SpamReport"
                                          OnAction="@HandleSpamAction" />
                }
                else if (item.ImpersonationAlert != null)
                {
                    <ImpersonationAlertCard Alert="@item.ImpersonationAlert"
                                            OnAction="@HandleImpersonationAction" />
                }
            }
        </MudStack>
    }
    else if (!_loading)
    {
        <MudPaper Class="pa-8" Elevation="0">
            <MudStack AlignItems="AlignItems.Center" Spacing="3">
                <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Large" Color="Color.Success" />
                <MudText Typo="Typo.h6" Color="Color.Secondary">No reports found</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">
                    @if (_selectedStatusFilter == StatusFilter.Pending)
                    {
                        <text>All reports have been reviewed!</text>
                    }
                    else
                    {
                        <text>No reports match the selected filters.</text>
                    }
                </MudText>
            </MudStack>
        </MudPaper>
    }
</MudContainer>

@code {
    private enum ReportTypeFilter { All, Spam, Impersonation }
    private enum StatusFilter { Pending, All }

    private List<ReportQueueItem> _allReports = [];
    private List<ReportQueueItem> _filteredReports = [];
    private ReportTypeFilter _selectedTypeFilter = ReportTypeFilter.All;
    private StatusFilter _selectedStatusFilter = StatusFilter.Pending;
    private bool _loading = true;
    private int _pendingSpamCount;
    private int _pendingImpersonationCount;
    private string _currentUserId = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        // Get current user ID
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated == true)
        {
            var userIdClaim = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier);
            if (userIdClaim != null)
            {
                _currentUserId = userIdClaim.Value;
            }
        }

        await LoadReportsAsync();
    }

    protected override void OnParametersSet()
    {
        ApplyFilters();
    }

    private async Task LoadReportsAsync()
    {
        _loading = true;
        StateHasChanged();

        try
        {
            // Get accessible chats for current user (Admin users only see their chats)
            var userId = await AuthHelper.GetCurrentUserIdAsync();
            var permissionLevel = await AuthHelper.GetCurrentPermissionLevelAsync();

            if (string.IsNullOrEmpty(userId))
            {
                Snackbar.Add("Unable to identify current user", Severity.Error);
                return;
            }

            var accessibleChats = await ManagedChatsRepository.GetUserAccessibleChatsAsync(
                userId,
                permissionLevel,
                cancellationToken: CancellationToken.None);
            var accessibleChatIds = accessibleChats.Select(c => c.ChatId).ToHashSet();

            var unifiedQueue = new List<ReportQueueItem>();

            // Load spam reports
            var spamReports = await ReportsRepository.GetReportsAsync(
                chatId: null,
                status: null, // Load all, filter client-side
                limit: 100,
                offset: 0);

            // Filter to accessible chats only
            var filteredSpamReports = spamReports
                .Where(r => accessibleChatIds.Contains(r.ChatId))
                .ToList();

            foreach (var report in filteredSpamReports)
            {
                unifiedQueue.Add(new ReportQueueItem
                {
                    Type = ReportType.Spam,
                    Timestamp = report.ReportedAt,
                    Priority = CalculateSpamPriority(report),
                    IsPending = report.Status == DataModels.ReportStatus.Pending,
                    SpamReport = report,
                    ImpersonationAlert = null,
                    DisplayTitle = "Moderation Report",
                    UserId = report.ReportedByUserId ?? 0,
                    UserName = report.ReportedByUserName
                });
            }

            // TODO Phase 2.9: Load impersonation alerts from unified ReviewsRepository
            // var impersonationAlerts = await ReviewsRepository.GetPendingImpersonationAlertsAsync(
            //     chatId: null,
            //     cancellationToken: CancellationToken.None);
            var filteredImpersonationAlerts = new List<ImpersonationAlertRecord>();

            // // Filter to accessible chats only
            // var filteredImpersonationAlerts = impersonationAlerts
            //     .Where(a => accessibleChatIds.Contains(a.ChatId))
            //     .ToList();
            //
            // foreach (var alert in filteredImpersonationAlerts)
            // {
            //     unifiedQueue.Add(new ReportQueueItem
            //     {
            //         Type = ReportType.Impersonation,
            //         Timestamp = alert.DetectedAt,
            //         Priority = CalculateImpersonationPriority(alert),
            //         IsPending = !alert.ReviewedAt.HasValue,
            //         SpamReport = null,
            //         ImpersonationAlert = alert,
            //         DisplayTitle = "Impersonation Alert",
            //         UserId = alert.SuspectedUserId,
            //         UserName = alert.SuspectedUserName
            //     });
            // }

            // Sort by priority (high → low), then timestamp (new → old)
            _allReports = unifiedQueue
                .OrderByDescending(x => x.Priority)
                .ThenByDescending(x => x.Timestamp)
                .ToList();

            // Update counts (based on filtered reports)
            _pendingSpamCount = filteredSpamReports.Count(r => r.Status == DataModels.ReportStatus.Pending);
            _pendingImpersonationCount = filteredImpersonationAlerts.Count(a => !a.ReviewedAt.HasValue);

            ApplyFilters();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading reports queue");
            Snackbar.Add("Failed to load reports", Severity.Error);
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private void ApplyFilters()
    {
        var filtered = _allReports.AsEnumerable();

        // Type filter
        if (_selectedTypeFilter != ReportTypeFilter.All)
        {
            filtered = filtered.Where(x => x.Type == (_selectedTypeFilter == ReportTypeFilter.Spam ? ReportType.Spam : ReportType.Impersonation));
        }

        // Status filter
        if (_selectedStatusFilter == StatusFilter.Pending)
        {
            filtered = filtered.Where(x => x.IsPending);
        }

        _filteredReports = filtered.ToList();
    }

    private void OnTypeFilterChanged(ReportTypeFilter newValue)
    {
        _selectedTypeFilter = newValue;
        ApplyFilters();
        StateHasChanged();
    }

    private void OnStatusFilterChanged(StatusFilter newValue)
    {
        _selectedStatusFilter = newValue;
        ApplyFilters();
        StateHasChanged();
    }

    private int CalculateSpamPriority(Report report)
    {
        if (report.Status != DataModels.ReportStatus.Pending) return 0;
        // Higher priority for newer reports
        var age = (DateTimeOffset.UtcNow - report.ReportedAt).TotalHours;
        return (int)(100 - age); // Newer = higher priority
    }

    private int CalculateImpersonationPriority(ImpersonationAlertRecord alert)
    {
        if (alert.ReviewedAt.HasValue) return 0;

        // Critical impersonation (100 points, auto-banned) = highest priority
        if (alert.RiskLevel == Data.Models.ImpersonationRiskLevel.Critical)
            return 1000 + alert.TotalScore;

        // Medium risk = medium priority
        return 500 + alert.TotalScore;
    }

    private async Task HandleSpamAction((Report Report, string Action) args)
    {
        try
        {
            switch (args.Action)
            {
                case "spam":
                    await ReportActionsService.HandleSpamActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} processed: Message deleted as spam", Severity.Success);
                    break;

                case "ban":
                    await ReportActionsService.HandleBanActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} processed: User banned", Severity.Success);
                    break;

                case "warn":
                    await ReportActionsService.HandleWarnActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} processed: Warning issued", Severity.Success);
                    break;

                case "dismiss":
                    await ReportActionsService.HandleDismissActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} dismissed", Severity.Info);
                    break;

                default:
                    Snackbar.Add($"Unknown action: {args.Action}", Severity.Error);
                    return;
            }

            await LoadReportsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling spam action {Action} for report {ReportId}", args.Action, args.Report.Id);
            Snackbar.Add($"Failed to process report: {ex.Message}", Severity.Error);
        }
    }

    // TODO Phase 2.9: Implement HandleImpersonationAction using unified ReviewsRepository
    private Task HandleImpersonationAction((ImpersonationAlertRecord Alert, string Action) args)
    {
        Snackbar.Add("Impersonation actions temporarily disabled - Phase 2.9 will implement unified reviews UI", Severity.Warning);
        return Task.CompletedTask;
    }
}
