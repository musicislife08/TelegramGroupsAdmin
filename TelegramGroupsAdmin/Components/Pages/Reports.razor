@page "/reports"
@using Microsoft.AspNetCore.Components.Authorization
@using TelegramGroupsAdmin.ContentDetection.Models
@using TelegramGroupsAdmin.ContentDetection.Repositories
@using TelegramGroupsAdmin.Core.Models
@using TelegramGroupsAdmin.Data.Models
@using TelegramGroupsAdmin.Services
@using TelegramGroupsAdmin.Telegram.Repositories
@using TelegramGroupsAdmin.Telegram.Services.Moderation
@using TelegramGroupsAdmin.Telegram.Models
@using TelegramGroupsAdmin.Components.Reports
@inject IReviewsRepository ReviewsRepository
@inject IReportActionsService ReportActionsService
@inject IManagedChatsRepository ManagedChatsRepository
@inject IModerationOrchestrator ModerationOrchestrator
@inject IBlazorAuthHelper AuthHelper
@inject ISnackbar Snackbar
@inject AuthenticationStateProvider AuthStateProvider
@inject ILogger<Reports> Logger
@attribute [Authorize]

<PageTitle>Reports Queue - TelegramGroupsAdmin</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">Reports Queue</MudText>

    @* Filters *@
    <MudPaper Class="pa-3 mb-4" Elevation="1">
        <MudStack Row="true" Spacing="3" AlignItems="AlignItems.Center">
            <MudSelect T="ReportTypeFilter"
                       id="type-filter"
                       Label="Type"
                       Value="_selectedTypeFilter"
                       ValueChanged="OnTypeFilterChanged"
                       Variant="Variant.Outlined"
                       Dense="true">
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.All">All Types</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.Spam">Moderation Reports</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.Impersonation">Impersonation Alerts</MudSelectItem>
                <MudSelectItem T="ReportTypeFilter" Value="@ReportTypeFilter.ExamFailure">Exam Reviews</MudSelectItem>
            </MudSelect>

            <MudSelect T="StatusFilter"
                       id="status-filter"
                       Label="Status"
                       Value="_selectedStatusFilter"
                       ValueChanged="OnStatusFilterChanged"
                       Variant="Variant.Outlined"
                       Dense="true">
                <MudSelectItem T="StatusFilter" Value="@StatusFilter.Pending">Pending Only</MudSelectItem>
                <MudSelectItem T="StatusFilter" Value="@StatusFilter.All">All Statuses</MudSelectItem>
            </MudSelect>

            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Material.Filled.Refresh"
                       OnClick="@LoadReportsAsync"
                       Disabled="_loading">
                Refresh
            </MudButton>

            <MudSpacer />

            <MudStack Row="true" Spacing="2">
                @if (_pendingSpamCount > 0)
                {
                    <MudChip T="string" Color="Color.Warning" Size="Size.Small" Icon="@Icons.Material.Filled.Report">
                        @_pendingSpamCount Moderation
                    </MudChip>
                }
                @if (_pendingImpersonationCount > 0)
                {
                    <MudChip T="string" Color="Color.Error" Size="Size.Small" Icon="@Icons.Material.Filled.Warning">
                        @_pendingImpersonationCount Impersonation
                    </MudChip>
                }
                @if (_pendingExamCount > 0)
                {
                    <MudChip T="string" Color="Color.Info" Size="Size.Small" Icon="@Icons.Material.Filled.Quiz">
                        @_pendingExamCount Exam
                    </MudChip>
                }
            </MudStack>
        </MudStack>
    </MudPaper>

    @* Loading State *@
    @if (_loading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4" />
    }

    @* Unified Reports Queue (Cards) *@
    @if (_filteredReports.Any())
    {
        <MudStack Spacing="3">
            @foreach (var item in _filteredReports)
            {
                @if (item.SpamReport != null)
                {
                    <ModerationReportCard Report="@item.SpamReport"
                                          OnAction="@HandleSpamAction" />
                }
                else if (item.ImpersonationAlert != null)
                {
                    <ImpersonationAlertCard Alert="@item.ImpersonationAlert"
                                            OnAction="@HandleImpersonationAction" />
                }
                else if (item.ExamFailure != null)
                {
                    <ExamReviewCard ExamFailure="@item.ExamFailure"
                                    OnAction="@HandleExamAction" />
                }
            }
        </MudStack>
    }
    else if (!_loading)
    {
        <MudPaper Class="pa-8" Elevation="0">
            <MudStack AlignItems="AlignItems.Center" Spacing="3">
                <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Large" Color="Color.Success" />
                <MudText Typo="Typo.h6" Color="Color.Secondary">No reports found</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">
                    @if (_selectedStatusFilter == StatusFilter.Pending)
                    {
                        <text>All reports have been reviewed!</text>
                    }
                    else
                    {
                        <text>No reports match the selected filters.</text>
                    }
                </MudText>
            </MudStack>
        </MudPaper>
    }
</MudContainer>

@code {
    private enum ReportTypeFilter { All, Spam, Impersonation, ExamFailure }
    private enum StatusFilter { Pending, All }

    private List<ReportQueueItem> _allReports = [];
    private List<ReportQueueItem> _filteredReports = [];
    private ReportTypeFilter _selectedTypeFilter = ReportTypeFilter.All;
    private StatusFilter _selectedStatusFilter = StatusFilter.Pending;
    private bool _loading = true;
    private int _pendingSpamCount;
    private int _pendingImpersonationCount;
    private int _pendingExamCount;
    private string _currentUserId = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        // Get current user ID
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated == true)
        {
            var userIdClaim = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier);
            if (userIdClaim != null)
            {
                _currentUserId = userIdClaim.Value;
            }
        }

        await LoadReportsAsync();
    }

    protected override void OnParametersSet()
    {
        ApplyFilters();
    }

    private async Task LoadReportsAsync()
    {
        _loading = true;
        StateHasChanged();

        try
        {
            // Get accessible chats for current user (Admin users only see their chats)
            var userId = await AuthHelper.GetCurrentUserIdAsync();
            var permissionLevel = await AuthHelper.GetCurrentPermissionLevelAsync();

            if (string.IsNullOrEmpty(userId))
            {
                Snackbar.Add("Unable to identify current user", Severity.Error);
                return;
            }

            var accessibleChats = await ManagedChatsRepository.GetUserAccessibleChatsAsync(
                userId,
                permissionLevel,
                cancellationToken: CancellationToken.None);
            var accessibleChatIds = accessibleChats.Select(c => c.ChatId).ToHashSet();

            var unifiedQueue = new List<ReportQueueItem>();

            // Load each type using type-specific repository methods
            // This returns properly hydrated models without exposing internal mappings

            // Load moderation reports
            var reports = await ReviewsRepository.GetReportsAsync(
                chatId: null,
                status: null,
                limit: 100);

            foreach (var report in reports.Where(r => accessibleChatIds.Contains(r.ChatId)))
            {
                unifiedQueue.Add(new ReportQueueItem
                {
                    Type = ReportType.Spam,
                    Timestamp = report.ReportedAt,
                    Priority = CalculateReportPriority(report),
                    IsPending = report.Status == ReportStatus.Pending,
                    SpamReport = report,
                    ImpersonationAlert = null,
                    ExamFailure = null,
                    DisplayTitle = "Moderation Report",
                    UserId = report.ReportedByUserId ?? 0,
                    UserName = report.ReportedByUserName
                });
            }

            // Load impersonation alerts
            var alerts = await ReviewsRepository.GetPendingImpersonationAlertsAsync();
            foreach (var alert in alerts.Where(a => accessibleChatIds.Contains(a.ChatId)))
            {
                unifiedQueue.Add(new ReportQueueItem
                {
                    Type = ReportType.Impersonation,
                    Timestamp = alert.DetectedAt,
                    Priority = CalculateImpersonationPriority(alert),
                    IsPending = !alert.ReviewedAt.HasValue,
                    SpamReport = null,
                    ImpersonationAlert = alert,
                    ExamFailure = null,
                    DisplayTitle = "Impersonation Alert",
                    UserId = alert.SuspectedUserId,
                    UserName = alert.SuspectedUserName
                });
            }

            // Load exam failures
            var examFailures = await ReviewsRepository.GetPendingExamFailuresAsync();
            foreach (var examFailure in examFailures.Where(e => accessibleChatIds.Contains(e.ChatId)))
            {
                unifiedQueue.Add(new ReportQueueItem
                {
                    Type = ReportType.ExamFailure,
                    Timestamp = examFailure.FailedAt,
                    Priority = CalculateExamPriority(examFailure),
                    IsPending = !examFailure.ReviewedAt.HasValue,
                    SpamReport = null,
                    ImpersonationAlert = null,
                    ExamFailure = examFailure,
                    DisplayTitle = "Exam Review",
                    UserId = examFailure.UserId,
                    UserName = examFailure.UserName
                });
            }

            // Sort by priority (high → low), then timestamp (new → old)
            _allReports = unifiedQueue
                .OrderByDescending(x => x.Priority)
                .ThenByDescending(x => x.Timestamp)
                .ToList();

            // Update counts
            _pendingSpamCount = unifiedQueue.Count(x => x.Type == ReportType.Spam && x.IsPending);
            _pendingImpersonationCount = unifiedQueue.Count(x => x.Type == ReportType.Impersonation && x.IsPending);
            _pendingExamCount = unifiedQueue.Count(x => x.Type == ReportType.ExamFailure && x.IsPending);

            ApplyFilters();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading reports queue");
            Snackbar.Add("Failed to load reports", Severity.Error);
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private void ApplyFilters()
    {
        var filtered = _allReports.AsEnumerable();

        // Type filter
        if (_selectedTypeFilter != ReportTypeFilter.All)
        {
            var targetType = _selectedTypeFilter switch
            {
                ReportTypeFilter.Spam => ReportType.Spam,
                ReportTypeFilter.Impersonation => ReportType.Impersonation,
                ReportTypeFilter.ExamFailure => ReportType.ExamFailure,
                _ => ReportType.Spam
            };
            filtered = filtered.Where(x => x.Type == targetType);
        }

        // Status filter
        if (_selectedStatusFilter == StatusFilter.Pending)
        {
            filtered = filtered.Where(x => x.IsPending);
        }

        _filteredReports = filtered.ToList();
    }

    private void OnTypeFilterChanged(ReportTypeFilter newValue)
    {
        _selectedTypeFilter = newValue;
        ApplyFilters();
        StateHasChanged();
    }

    private void OnStatusFilterChanged(StatusFilter newValue)
    {
        _selectedStatusFilter = newValue;
        ApplyFilters();
        StateHasChanged();
    }

    private int CalculateReportPriority(Report report)
    {
        if (report.Status != ReportStatus.Pending) return 0;
        // Higher priority for newer reports
        var age = (DateTimeOffset.UtcNow - report.ReportedAt).TotalHours;
        return (int)(100 - age); // Newer = higher priority
    }

    private int CalculateImpersonationPriority(ImpersonationAlertRecord alert)
    {
        if (alert.ReviewedAt.HasValue) return 0;

        // Critical impersonation (100 points, auto-banned) = highest priority
        if (alert.RiskLevel == ImpersonationRiskLevel.Critical)
            return 1000 + alert.TotalScore;

        // Medium risk = medium priority
        return 500 + alert.TotalScore;
    }

    private int CalculateExamPriority(ExamFailureRecord examFailure)
    {
        if (examFailure.ReviewedAt.HasValue) return 0;

        // Higher priority for recent failures (users waiting for approval)
        var age = (DateTimeOffset.UtcNow - examFailure.FailedAt).TotalHours;
        return (int)(200 - age); // Higher base priority than reports
    }

    private async Task HandleSpamAction((Report Report, string Action) args)
    {
        try
        {
            switch (args.Action)
            {
                case "spam":
                    await ReportActionsService.HandleSpamActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} processed: Message deleted as spam", Severity.Success);
                    break;

                case "ban":
                    await ReportActionsService.HandleBanActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} processed: User banned", Severity.Success);
                    break;

                case "warn":
                    await ReportActionsService.HandleWarnActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} processed: Warning issued", Severity.Success);
                    break;

                case "dismiss":
                    await ReportActionsService.HandleDismissActionAsync(args.Report.Id, _currentUserId);
                    Snackbar.Add($"Report #{args.Report.Id} dismissed", Severity.Info);
                    break;

                default:
                    Snackbar.Add($"Unknown action: {args.Action}", Severity.Error);
                    return;
            }

            await LoadReportsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling spam action {Action} for report {ReportId}", args.Action, args.Report.Id);
            Snackbar.Add($"Failed to process report: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleImpersonationAction((ImpersonationAlertRecord Alert, string Action) args)
    {
        try
        {
            var executor = Actor.FromWebUser(_currentUserId);

            switch (args.Action)
            {
                case "confirm":
                    // Ban the suspected impersonator globally
                    var banResult = await ModerationOrchestrator.BanUserAsync(
                        userId: args.Alert.SuspectedUserId,
                        messageId: null,
                        executor: executor,
                        reason: $"Impersonation alert #{args.Alert.Id} confirmed - impersonating {args.Alert.TargetDisplayName}");

                    await ReviewsRepository.UpdateStatusAsync(
                        args.Alert.Id,
                        ReportStatus.Reviewed,
                        _currentUserId,
                        "confirm_scam",
                        $"Confirmed impersonation, banned from {banResult.ChatsAffected} chats");

                    Snackbar.Add($"Impersonation confirmed: User banned from {banResult.ChatsAffected} chats", Severity.Success);
                    break;

                case "dismiss":
                    // Mark as false positive
                    await ReviewsRepository.UpdateStatusAsync(
                        args.Alert.Id,
                        ReportStatus.Dismissed,
                        _currentUserId,
                        "false_positive",
                        "Marked as false positive");

                    Snackbar.Add("Alert dismissed as false positive", Severity.Info);
                    break;

                case "trust":
                    // Trust the suspected user (they're legitimate)
                    await ModerationOrchestrator.TrustUserAsync(
                        args.Alert.SuspectedUserId,
                        executor,
                        $"Trusted after impersonation review #{args.Alert.Id}");

                    await ReviewsRepository.UpdateStatusAsync(
                        args.Alert.Id,
                        ReportStatus.Dismissed,
                        _currentUserId,
                        "trust",
                        "User trusted - not impersonation");

                    Snackbar.Add("User marked as trusted", Severity.Success);
                    break;

                default:
                    Snackbar.Add($"Unknown action: {args.Action}", Severity.Error);
                    return;
            }

            await LoadReportsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling impersonation action {Action} for alert {AlertId}", args.Action, args.Alert.Id);
            Snackbar.Add($"Failed to process alert: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleExamAction((ExamFailureRecord ExamFailure, string Action) args)
    {
        try
        {
            var executor = Actor.FromWebUser(_currentUserId);

            switch (args.Action)
            {
                case "approve":
                    // Restore user permissions (they passed admin review)
                    var restoreResult = await ModerationOrchestrator.RestoreUserPermissionsAsync(
                        userId: args.ExamFailure.UserId,
                        chatId: args.ExamFailure.ChatId,
                        executor: executor,
                        reason: $"Exam failure #{args.ExamFailure.Id} - manually approved after review");

                    if (!restoreResult.Success)
                    {
                        Snackbar.Add($"Failed to restore permissions: {restoreResult.ErrorMessage}", Severity.Error);
                        return;
                    }

                    await ReviewsRepository.UpdateStatusAsync(
                        args.ExamFailure.Id,
                        ReportStatus.Reviewed,
                        _currentUserId,
                        "approve",
                        "Manually approved after exam failure");

                    Snackbar.Add("User approved - permissions restored", Severity.Success);
                    break;

                case "deny":
                    // Kick user from chat (they can re-join and try again)
                    var kickResult = await ModerationOrchestrator.KickUserFromChatAsync(
                        userId: args.ExamFailure.UserId,
                        chatId: args.ExamFailure.ChatId,
                        executor: executor,
                        reason: $"Exam failure #{args.ExamFailure.Id} - denied after review");

                    if (!kickResult.Success)
                    {
                        Snackbar.Add($"Failed to kick user: {kickResult.ErrorMessage}", Severity.Error);
                        return;
                    }

                    await ReviewsRepository.UpdateStatusAsync(
                        args.ExamFailure.Id,
                        ReportStatus.Reviewed,
                        _currentUserId,
                        "deny",
                        "Denied entry after exam review");

                    Snackbar.Add("User denied - they can re-join to try again", Severity.Warning);
                    break;

                case "deny_ban":
                    // Ban user globally (prevents repeat spam joins across all chats)
                    var banResult = await ModerationOrchestrator.BanUserAsync(
                        userId: args.ExamFailure.UserId,
                        messageId: null,
                        executor: executor,
                        reason: $"Exam failure #{args.ExamFailure.Id} - denied and banned after review");

                    if (!banResult.Success)
                    {
                        Snackbar.Add($"Failed to ban user: {banResult.ErrorMessage}", Severity.Error);
                        return;
                    }

                    await ReviewsRepository.UpdateStatusAsync(
                        args.ExamFailure.Id,
                        ReportStatus.Reviewed,
                        _currentUserId,
                        "deny_ban",
                        $"Denied and banned from {banResult.ChatsAffected} chats");

                    Snackbar.Add($"User denied and banned from {banResult.ChatsAffected} chats", Severity.Error);
                    break;

                default:
                    Snackbar.Add($"Unknown action: {args.Action}", Severity.Error);
                    return;
            }

            await LoadReportsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling exam action {Action} for exam failure {ExamId}", args.Action, args.ExamFailure.Id);
            Snackbar.Add($"Failed to process exam review: {ex.Message}", Severity.Error);
        }
    }
}
