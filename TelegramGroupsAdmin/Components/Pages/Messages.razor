@page "/messages"
@using TelegramGroupsAdmin.Telegram.Services
@using TelegramGroupsAdmin.Telegram.Services.Media
@using static TelegramGroupsAdmin.Components.Shared.MessageFilters
@inject IMessageHistoryRepository MessageRepository
@inject IMessageQueryService MessageQueryService
@inject IMessageEditService MessageEditService
@inject IMessageTranslationService MessageTranslationService
@inject IManagedChatsRepository ChatsRepository
@inject IJSRuntime Js
@inject IDialogService DialogService
@inject IMessageHistoryService MessageHistoryService
@inject BlazorAuthHelper AuthHelper
@inject IDetectionResultsRepository DetectionResultsRepository
@inject ModerationActionService ModerationService
@inject ITelegramUserMappingRepository TelegramMappingRepository
@inject NavigationManager NavigationManager
@inject ILogger<Messages> Logger
@inject ISnackbar Snackbar
@inject IMediaRefetchQueueService MediaRefetchQueue
@inject TelegramGroupsAdmin.ContentDetection.Services.IOpenAITranslationService TranslationService
@inject IWebBotMessagingService WebBotMessagingService
@attribute [Authorize]
@implements IDisposable

<PageTitle>Messages - TelegramGroupsAdmin</PageTitle>

@* Telegram Desktop Clone Layout *@
<div class="telegram-layout">
    @* Left Sidebar - Chat List *@
    <div class="telegram-sidebar @(_selectedChatId.HasValue ? "has-selection" : "")">
        <div class="sidebar-header">
            <div class="sidebar-title">Chats</div>
            <input type="text"
                   class="sidebar-search"
                   placeholder="Search chats..."
                   @bind="_chatSearchText"
                   @bind:event="oninput" />
        </div>

        <ChatList Chats="_filteredChats"
                  SelectedChatId="_selectedChatId"
                  MessageCounts="_chatMessageCounts"
                  UnreadCounts="_chatUnreadCounts"
                  LastMessagePreviews="_lastMessagePreviews"
                  OnChatSelected="HandleChatSelected" />
    </div>

    @* Main Chat View *@
    <div class="telegram-main @(_selectedChatId.HasValue ? "active" : "")">
        @if (_selectedChatId.HasValue)
        {
            var selectedChat = _managedChats.FirstOrDefault(c => c.ChatId == _selectedChatId.Value);
            if (selectedChat != null)
            {
                @* Chat Header *@
                <ChatHeader ChatName="@selectedChat.ChatName"
                            ChatIconPath="@selectedChat.ChatIconPath"
                            ChatDescription="@GetChatDescription(selectedChat)"
                            ShowBackButton="true"
                            ShowMenuButton="false"
                            OnBackClicked="HandleBackToChats" />

                @* Messages Container *@
                <div class="messages-container" @ref="_messagesContainer">
                    @if (_loading)
                    {
                        <div class="empty-state">
                            <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
                        </div>
                    }
                    else if (_filteredMessages.Any())
                    {
                        <MudVirtualize Items="_filteredMessages" Context="messageWrapper" OverscanCount="10">
                            <MessageBubbleTelegram Message="messageWrapper.Message"
                                                   SpamCheck="@GetSpamCheck(messageWrapper.Message.MessageId)"
                                                   EditCount="@GetEditCount(messageWrapper.Message.MessageId)"
                                                   ShowSpamActions="@(_userPermissionLevel >= PermissionLevel.GlobalAdmin)"
                                                   DetectionHistory="@messageWrapper.DetectionResults"
                                                   UserTags="@messageWrapper.UserTags"
                                                   UserNotes="@messageWrapper.UserNotes"
                                                   IsCurrentUser="@IsCurrentUserMessage(messageWrapper.Message.UserId)"
                                                   IsBotMessage="@IsBotMessage(messageWrapper.Message.UserId)"
                                                   OnImageClick="HandleImageClick"
                                                   OnViewEdits="HandleViewEdits"
                                                   OnMarkAsSpam="HandleMarkAsSpam"
                                                   OnMarkAsHam="HandleMarkAsHam"
                                                   OnViewDetections="HandleViewDetections"
                                                   OnFilterByUser="HandleFilterByUser"
                                                   OnFilterByChat="HandleFilterByChat"
                                                   OnDeleteMessage="HandleDeleteMessage"
                                                   OnTempBan="HandleTempBan"
                                                   OnReplyClick="HandleReplyClick"
                                                   OnReplyToClick="HandleReplyToClick"
                                                   OnEditClick="@((tuple) => HandleEditClick(tuple.MessageId, tuple.MessageText))"
                                                   OnTranslateMessage="HandleTranslateMessage" />
                        </MudVirtualize>

                        @* Scroll Sentinel - triggers loading when scrolled near top (= bottom due to flex-reverse) *@
                        @if (_hasMore)
                        {
                            <div class="scroll-sentinel" @ref="_scrollSentinel">
                                @if (_loadingMore)
                                {
                                    <div class="load-more-container">
                                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                                        <span class="loading-text">Loading older messages...</span>
                                    </div>
                                }
                            </div>
                        }
                    }
                    else
                    {
                        <div class="empty-state">
                            <div class="empty-state-icon">
                                <svg viewBox="0 0 24 24">
                                    <path fill="currentColor" d="M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M6,9H18V11H6M14,14H6V12H14M18,8H6V6H18" />
                                </svg>
                            </div>
                            <div class="empty-state-text">No messages yet</div>
                            <div class="empty-state-subtext">Messages will appear here as they are received</div>
                        </div>
                    }
                </div>

                @* Message Input (Phase 1: Bot messages) *@
                <ChatInput IsEnabled="@_isFeatureAvailable"
                           PlaceholderText="@GetChatInputPlaceholder()"
                           MaxMessageLength="@GetMaxMessageLength()"
                           CurrentText="@_editingOriginalText"
                           IsEditMode="@(_isEditingMessageId.HasValue)"
                           ReplyToMessageId="@_replyToMessageId"
                           ReplyToUser="@GetReplyToUser()"
                           ReplyToText="@GetReplyToText()"
                           OnSendMessage="@SendMessageAsync"
                           OnEditMessage="@EditMessageAsync"
                           OnCancelEdit="@CancelEdit"
                           OnCancelReply="@CancelReply"
                           OnReplyPreviewClick="@HandleReplyClick" />
            }
        }
        else
        {
            @* Empty State - No Chat Selected *@
            <div class="empty-state">
                <div class="empty-state-icon">
                    <svg viewBox="0 0 24 24">
                        <path fill="currentColor" d="M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M6,9H18V11H6M14,14H6V12H14M18,8H6V6H18" />
                    </svg>
                </div>
                <div class="empty-state-text">Select a chat to view messages</div>
                <div class="empty-state-subtext">Choose a chat from the list to start viewing its message history</div>
            </div>
        }
    </div>
</div>

@code {
    // Chat state
    private List<ManagedChatRecord> _managedChats = [];
    private List<ManagedChatRecord> _filteredChats = [];
    private string _chatSearchText = "";
    private long? _selectedChatId;
    private readonly Dictionary<long, int> _chatMessageCounts = new();
    private readonly Dictionary<long, int> _chatUnreadCounts = new();
    private readonly Dictionary<long, string> _lastMessagePreviews = new();

    // Message state (per-chat) - PERF-APP-1: Use composite model with detection history included
    private List<MessageWithDetectionHistory> _allMessages = [];
    private List<MessageWithDetectionHistory> _filteredMessages = [];
    private Dictionary<long, SpamCheckRecord> _spamChecks = new();
    private Dictionary<long, int> _editCounts = new();
    private bool _loading;
    private bool _loadingMore;
    private bool _hasMore = true;
    private bool _needsObserverInit;
    private DateTime _lastUpdate = DateTime.Now;

    // User state
    private PermissionLevel _userPermissionLevel = PermissionLevel.Admin; // Default to Admin
    private HashSet<long> _userTelegramIds = []; // Current user's linked Telegram IDs

    // Phase 1: Send & Edit Messages as Bot state
    private bool _isFeatureAvailable; // Feature enabled (bot enabled + user has linked account)
    private long? _botUserId; // Bot's Telegram user ID (for identifying bot messages)
    private string? _linkedUsername; // User's linked Telegram username (for calculating signature length)
    private string? _featureUnavailableReason; // Reason why feature is unavailable (for placeholder text)
    private long? _isEditingMessageId; // Message currently being edited
    private long? _replyToMessageId; // Message being replied to
    private string? _editingOriginalText; // Original text of message being edited

    private readonly MessageFilterState _filterState = new();
    private long? _highlightMessageId; // Message to scroll to and highlight
    private bool _firstRenderComplete; // Track if we've done the initial auto-scroll
    private long? _filterByUserId; // Track userId from query string for name lookup after load
    private const int PageSize = 50;

    // Infinite scroll state
    private ElementReference _messagesContainer;
    private ElementReference _scrollSentinel;
    private IJSObjectReference? _infiniteScrollModule;

    protected override async Task OnInitializedAsync()
    {
        // Get user permission level and ID
        var userId = await AuthHelper.GetCurrentUserIdAsync();
        _userPermissionLevel = await AuthHelper.GetCurrentPermissionLevelAsync();

        // Load current user's linked Telegram accounts for message alignment
        if (!string.IsNullOrEmpty(userId))
        {
            try
            {
                var mappings = await TelegramMappingRepository.GetByUserIdAsync(userId);
                _userTelegramIds = mappings.Select(m => m.TelegramId).ToHashSet();
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to load linked Telegram accounts for user {UserId}", userId);
            }
        }

        // Subscribe to real-time updates
        MessageHistoryService.OnNewMessage += HandleNewMessage;
        MessageHistoryService.OnMediaUpdated += HandleMediaUpdated;

        // Load managed chats
        await LoadChatsAsync();

        // Parse query string parameters to select chat if specified
        await ApplyQueryStringFiltersAsync();

        // If a chat was auto-selected from query string, load its messages
        if (_selectedChatId.HasValue)
        {
            await LoadChatMessagesAsync(_selectedChatId.Value);
        }

        // Phase 1: Check feature availability (bot enabled + linked Telegram account)
        await CheckFeatureAvailabilityAsync();
    }

    public void Dispose()
    {
        // Unsubscribe from events
        MessageHistoryService.OnNewMessage -= HandleNewMessage;
        MessageHistoryService.OnMediaUpdated -= HandleMediaUpdated;

        // Dispose JavaScript module
        _infiniteScrollModule?.DisposeAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Initialize IntersectionObserver for infinite scroll
        // Import module on first render, but re-initialize observer whenever a chat is loaded with more pages
        if (firstRender)
        {
            try
            {
                _infiniteScrollModule = await Js.InvokeAsync<IJSObjectReference>("import", "./js/infinite-scroll.js");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to import infinite scroll module");
            }
        }

        // (Re)initialize observer when needed (chat loaded with _hasMore = true)
        if (_needsObserverInit && _infiniteScrollModule != null && _selectedChatId.HasValue && _hasMore)
        {
            try
            {
                await _infiniteScrollModule.InvokeVoidAsync("initializeIntersectionObserver",
                    _scrollSentinel,
                    DotNetObjectReference.Create(this));
                _needsObserverInit = false;
                Logger.LogDebug("Infinite scroll observer initialized for chat {ChatId}", _selectedChatId);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to initialize intersection observer for infinite scroll");
            }
        }

        // Only run once after the first render, and only if we have a highlight target
        if (firstRender && _highlightMessageId.HasValue && !_firstRenderComplete)
        {
            _firstRenderComplete = true;

            try
            {
                var targetMessageId = _highlightMessageId.Value;
                Logger.LogDebug("Auto-scrolling to highlighted message: {MessageId}", targetMessageId);

                // Check if target message is in the filtered list
                var targetMessage = _filteredMessages.FirstOrDefault(mw => mw.Message.MessageId == targetMessageId);

                if (targetMessage == null)
                {
                    // Message not loaded yet, try to load it
                    Logger.LogInformation("Highlighted message {MessageId} not in current view, loading...", targetMessageId);

                    // Load the message from repository
                    var message = await MessageRepository.GetMessageAsync(targetMessageId);
                    if (message == null)
                    {
                        Logger.LogWarning("Highlighted message {MessageId} not found in database", targetMessageId);
                        return;
                    }

                    // Add to the list if not already there (wrapped in MessageWithDetectionHistory)
                    if (_allMessages.All(mw => mw.Message.MessageId != targetMessageId))
                    {
                        var messageWrapper = new MessageWithDetectionHistory { Message = message };

                        // Insert in chronological order (messages are sorted newest-first)
                        var insertIndex = _allMessages.FindIndex(mw => mw.Message.Timestamp < message.Timestamp);
                        if (insertIndex >= 0)
                        {
                            _allMessages.Insert(insertIndex, messageWrapper);
                        }
                        else
                        {
                            _allMessages.Add(messageWrapper);
                        }

                        // Load metadata for this message
                        var messageIds = new[] { targetMessageId };
                        var spamChecks = await MessageQueryService.GetSpamChecksForMessagesAsync(messageIds);
                        var editCounts = await MessageEditService.GetEditCountsForMessagesAsync(messageIds);

                        foreach (var kvp in spamChecks)
                            _spamChecks[kvp.Key] = kvp.Value;
                        foreach (var kvp in editCounts)
                            _editCounts[kvp.Key] = kvp.Value;

                        // Load detection history for Admin+ users (now included in wrapper)
                        if (_userPermissionLevel >= PermissionLevel.GlobalAdmin)
                        {
                            var history = await DetectionResultsRepository.GetByMessageIdAsync(targetMessageId);
                            messageWrapper.DetectionResults.AddRange(history);
                        }

                        ApplyFilters();
                        StateHasChanged();
                    }
                }

                // Use JavaScript to scroll to and highlight the message
                await Js.InvokeVoidAsync("scrollToMessage", targetMessageId);

                Logger.LogInformation("Successfully scrolled to highlighted message: {MessageId}", targetMessageId);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to auto-scroll to highlighted message {MessageId}", _highlightMessageId);
            }
            finally
            {
                // Clear the highlight flag to prevent repeated scrolling
                _highlightMessageId = null;
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    // ReSharper disable once AsyncVoidMethod
    private async void HandleNewMessage(MessageRecord message)
    {
        // CRITICAL: Must use InvokeAsync because HistoryBot runs on background thread
        await InvokeAsync(async () =>
        {
            try
            {
                // Only add message if it belongs to the currently selected chat
                if (!_selectedChatId.HasValue || message.ChatId != _selectedChatId.Value)
                {
                    Logger.LogTrace("Ignoring new message {MessageId} from chat {ChatId} (currently viewing chat {SelectedChatId})",
                        message.MessageId, message.ChatId, _selectedChatId);
                    return;
                }

                // Capture scroll state before adding message
                var scrollState = await Js.InvokeAsync<ScrollState>("captureScrollState", _messagesContainer);

                // Add to our list at the beginning (most recent first) wrapped in MessageWithDetectionHistory
                _allMessages.Insert(0, new MessageWithDetectionHistory { Message = message });

                // Load spam check for this new message if it exists
                var messageIds = new[] { message.MessageId };
                var newSpamChecks = await MessageQueryService.GetSpamChecksForMessagesAsync(messageIds);
                foreach (var kvp in newSpamChecks)
                {
                    _spamChecks[kvp.Key] = kvp.Value;
                }

                // Load edit count for this message
                var newEditCounts = await MessageEditService.GetEditCountsForMessagesAsync(messageIds);
                foreach (var kvp in newEditCounts)
                {
                    _editCounts[kvp.Key] = kvp.Value;
                }

                // Reapply filters and trigger re-render
                ApplyFilters();
                StateHasChanged();

                // Wait for browser to complete render cycle, then restore scroll
                await Js.InvokeVoidAsync("restoreScrollStateAfterRender", _messagesContainer, scrollState);

                Logger.LogDebug("Added new real-time message {MessageId} to chat {ChatId} view",
                    message.MessageId, message.ChatId);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to handle new message {MessageId} from real-time update", message.MessageId);
            }
        });
    }

    // ReSharper disable once AsyncVoidMethod
    private async void HandleMediaUpdated(long messageId, MediaType mediaType)
    {
        // CRITICAL: Must use InvokeAsync because worker runs on background thread
        await InvokeAsync(async () =>
        {
            try
            {
                Logger.LogInformation("ðŸ”” SignalR notification received for message {MessageId} type {MediaType}", messageId, mediaType);

                // Reload the message from database to get updated media_local_path
                var updatedMessage = await MessageRepository.GetMessageAsync(messageId);
                if (updatedMessage == null)
                {
                    Logger.LogWarning("Updated message {MessageId} not found in database", messageId);
                    return;
                }

                // Only update if message belongs to currently selected chat
                if (!_selectedChatId.HasValue || updatedMessage.ChatId != _selectedChatId.Value)
                {
                    Logger.LogTrace("Ignoring media update for message {MessageId} from chat {ChatId} (currently viewing chat {SelectedChatId})",
                        messageId, updatedMessage.ChatId, _selectedChatId);
                    return;
                }

                // Find and replace in our list (Message is init-only)
                var index = _allMessages.FindIndex(m => m.Message.MessageId == messageId);
                if (index >= 0)
                {
                    var detectionResults = _allMessages[index].DetectionResults;
                    _allMessages[index] = new MessageWithDetectionHistory
                    {
                        Message = updatedMessage,
                        DetectionResults = detectionResults
                    };

                    // Reapply filters and trigger re-render
                    ApplyFilters();
                    StateHasChanged();

                    Logger.LogInformation("âœ… UI refreshed for message {MessageId} after media download via SignalR", messageId);
                }
                else
                {
                    Logger.LogWarning("Message {MessageId} not found in _allMessages list", messageId);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling media update for message {MessageId}", messageId);
            }
        });
    }

    private async Task LoadChatsAsync()
    {
        try
        {
            // Get current user and their permission level
            var userId = await AuthHelper.GetCurrentUserIdAsync();
            var permissionLevel = await AuthHelper.GetCurrentPermissionLevelAsync();

            if (string.IsNullOrEmpty(userId))
            {
                Logger.LogWarning("Unable to identify current user for chat filtering");
                _managedChats = [];
                return;
            }

            // Load chats accessible to this user (filtered by permission level)
            _managedChats = await ChatsRepository.GetUserAccessibleChatsAsync(
                userId,
                permissionLevel);
            ApplyChatFilter();

            // Calculate message counts for each chat
            await CalculateChatStatisticsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load managed chats");
        }
    }

    private void ApplyChatFilter()
    {
        if (string.IsNullOrWhiteSpace(_chatSearchText))
        {
            _filteredChats = _managedChats;
        }
        else
        {
            var searchLower = _chatSearchText.ToLower();
            _filteredChats = _managedChats
                .Where(c => c.ChatName?.ToLower().Contains(searchLower) == true)
                .ToList();
        }
    }

    private async Task CalculateChatStatisticsAsync()
    {
        try
        {
            foreach (var chat in _managedChats)
            {
                // Get total message count for this chat
                var totalCount = await MessageRepository.GetMessageCountByChatIdAsync(chat.ChatId);
                _chatMessageCounts[chat.ChatId] = totalCount;

                // Get last message preview (only fetch 1 message for preview)
                if (totalCount > 0)
                {
                    var lastMessages = await MessageQueryService.GetMessagesByChatIdAsync(chat.ChatId, limit: 1);
                    if (lastMessages.Any())
                    {
                        var lastMessage = lastMessages.First();
                        var hasPhoto = !string.IsNullOrEmpty(lastMessage.PhotoFileId);
                        var preview = lastMessage.MessageText ?? (hasPhoto ? "ðŸ“· Photo" : "Message");
                        _lastMessagePreviews[chat.ChatId] = preview;
                    }
                }

                // TODO: Implement read tracking for unread counts
                _chatUnreadCounts[chat.ChatId] = 0; // Placeholder
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to calculate chat statistics");
        }
    }

    private async Task HandleChatSelected(long chatId)
    {
        _selectedChatId = chatId;
        await LoadChatMessagesAsync(chatId);
    }

    private void HandleBackToChats()
    {
        _selectedChatId = null;
        _allMessages.Clear();
        _filteredMessages.Clear();
        StateHasChanged();
    }

    private async Task LoadChatMessagesAsync(long chatId)
    {
        // PERF-APP-3: Set loading state without intermediate render
        _loading = true;
        _hasMore = true;
        _allMessages.Clear();
        _spamChecks.Clear();
        _editCounts.Clear();

        try
        {
            // PERF-APP-1: Load first page with detection history included (single JOIN query)
            var firstPage = _userPermissionLevel >= PermissionLevel.GlobalAdmin
                ? await MessageQueryService.GetMessagesWithDetectionHistoryAsync(chatId, limit: PageSize)
                : (await MessageQueryService.GetMessagesByChatIdAsync(chatId, limit: PageSize))
                    .Select(m => new MessageWithDetectionHistory { Message = m }).ToList();

            _allMessages = firstPage;
            _hasMore = firstPage.Count >= PageSize; // More pages available if we got a full page

            // PERF-APP-3: Load edit counts and spam checks in parallel
            if (_allMessages.Any())
            {
                var messageIds = _allMessages.Select(m => m.Message.MessageId).ToList();

                if (_userPermissionLevel >= PermissionLevel.GlobalAdmin)
                {
                    // Admin: Only load edit counts (detection history already in wrapper)
                    _editCounts = await MessageEditService.GetEditCountsForMessagesAsync(messageIds);
                }
                else
                {
                    // Non-admin: Load both edit counts and spam checks in parallel
                    var editCountsTask = MessageEditService.GetEditCountsForMessagesAsync(messageIds);
                    var spamChecksTask = MessageQueryService.GetSpamChecksForMessagesAsync(messageIds);

                    await Task.WhenAll(editCountsTask, spamChecksTask);

                    _editCounts = await editCountsTask;
                    _spamChecks = await spamChecksTask;
                }
            }

            _lastUpdate = DateTime.Now;
            ApplyFilters();

            // Detect and queue missing media for automatic re-download (Phase 4.X: Media refetch system)
            await QueueMissingMediaForRefetchAsync();

            // Request observer initialization if there are more pages to load
            if (_hasMore)
            {
                _needsObserverInit = true;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Unexpected error loading messages for chat {ChatId}", chatId);
        }
        finally
        {
            // PERF-APP-3: Single render after all data loaded
            _loading = false;
            StateHasChanged();
        }
    }

    private string GetChatDescription(ManagedChatRecord chat)
    {
        // Could show member count, last active, etc.
        return chat.IsAdmin ? "Bot is admin" : "Bot is member";
    }

    [JSInvokable]
    public async Task LoadOlderMessagesAsync()
    {
        if (_loadingMore || !_hasMore || !_selectedChatId.HasValue)
            return;

        // PERF-APP-3: Set loading state without intermediate render
        _loadingMore = true;

        try
        {
            // Get the timestamp of the oldest message currently loaded
            var oldestMessage = _allMessages.LastOrDefault();
            if (oldestMessage == null)
            {
                _hasMore = false;
                return;
            }

            // PERF-APP-1: Load older messages with detection history included
            var olderMessages = _userPermissionLevel >= PermissionLevel.GlobalAdmin
                ? await MessageQueryService.GetMessagesWithDetectionHistoryAsync(
                    _selectedChatId.Value,
                    limit: PageSize,
                    beforeTimestamp: oldestMessage.Message.Timestamp)
                : (await MessageQueryService.GetMessagesByChatIdAsync(
                    _selectedChatId.Value,
                    limit: PageSize,
                    beforeTimestamp: oldestMessage.Message.Timestamp))
                    .Select(m => new MessageWithDetectionHistory { Message = m }).ToList();

            if (olderMessages.Any())
            {
                // Append to existing messages (older messages go at the end of the list)
                _allMessages.AddRange(olderMessages);

                // PERF-APP-3: Load edit counts and spam checks in parallel
                var messageIds = olderMessages.Select(m => m.Message.MessageId).ToList();

                if (_userPermissionLevel >= PermissionLevel.GlobalAdmin)
                {
                    // Admin: Only load edit counts (detection history already in wrapper)
                    var newEditCounts = await MessageEditService.GetEditCountsForMessagesAsync(messageIds);
                    foreach (var kvp in newEditCounts)
                        _editCounts[kvp.Key] = kvp.Value;
                }
                else
                {
                    // Non-admin: Load both edit counts and spam checks in parallel
                    var editCountsTask = MessageEditService.GetEditCountsForMessagesAsync(messageIds);
                    var spamChecksTask = MessageQueryService.GetSpamChecksForMessagesAsync(messageIds);

                    await Task.WhenAll(editCountsTask, spamChecksTask);

                    var newEditCounts = await editCountsTask;
                    foreach (var kvp in newEditCounts)
                        _editCounts[kvp.Key] = kvp.Value;

                    var newSpamChecks = await spamChecksTask;
                    foreach (var kvp in newSpamChecks)
                        _spamChecks[kvp.Key] = kvp.Value;
                }

                // Check if there are more pages
                _hasMore = olderMessages.Count >= PageSize;

                ApplyFilters();

                Logger.LogDebug("Loaded {Count} older messages, hasMore: {HasMore}", olderMessages.Count, _hasMore);
            }
            else
            {
                _hasMore = false;
                Logger.LogDebug("No more older messages to load");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load older messages for chat {ChatId}", _selectedChatId);
        }
        finally
        {
            // PERF-APP-3: Single render after all data loaded
            _loadingMore = false;
            StateHasChanged();
        }
    }

    private void ApplyFilters()
    {
        _filteredMessages = _allMessages
            .Where(mw => _filterState.Matches(mw.Message, GetSpamCheck(mw.Message.MessageId)))
            .ToList(); // Keep newest-first order from repo, CSS flex-direction: column-reverse displays newest at bottom

        // Additional userId filter from query string (if set and UserName filter is still active)
        if (_filterByUserId.HasValue && !string.IsNullOrEmpty(_filterState.UserName))
        {
            _filteredMessages = _filteredMessages
                .Where(mw => mw.Message.UserId == _filterByUserId.Value)
                .ToList();
        }
        else if (_filterByUserId.HasValue && string.IsNullOrEmpty(_filterState.UserName))
        {
            // User cleared the filter, so clear our userId tracking too
            _filterByUserId = null;
        }

        // Note: Callers must call StateHasChanged() after ApplyFilters() to trigger re-render
    }

    private SpamCheckRecord? GetSpamCheck(long messageId)
    {
        // PERF-APP-1: Use detection results already loaded via Include() instead of separate dictionary
        var wrapper = _allMessages.FirstOrDefault(mw => mw.Message.MessageId == messageId);
        if (wrapper?.DetectionResults.Any() != true)
        {
            // Fallback to dictionary for backward compatibility (messages loaded without detection history)
            _spamChecks.TryGetValue(messageId, out var fallback);
            return fallback;
        }

        // Use latest detection result (already ordered DESC by DetectedAt in repository)
        var latest = wrapper.DetectionResults.First();
        return new SpamCheckRecord(
            Id: latest.Id,
            CheckTimestamp: latest.DetectedAt,
            UserId: latest.UserId,
            ContentHash: wrapper.Message.ContentHash,
            IsSpam: latest.IsSpam,
            Confidence: Math.Abs(latest.NetConfidence),
            Reason: latest.Reason,
            CheckType: latest.DetectionMethod,
            MatchedMessageId: messageId
        );
    }

    private int GetEditCount(long messageId)
    {
        _editCounts.TryGetValue(messageId, out var count);
        return count;
    }

    // Export methods removed - TODO: Add per-chat export in context menu later

    private async Task HandleImageClick(MessageRecord message)
    {
        var parameters = new DialogParameters<ImageViewerDialog>
        {
            { x => x.Message, message }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<ImageViewerDialog>("Image Viewer", parameters, options);
    }

    private async Task HandleViewEdits(MessageRecord message)
    {
        var parameters = new DialogParameters<EditHistoryDialog>
        {
            { x => x.Message, message }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<EditHistoryDialog>("Edit History", parameters, options);
    }

    // Phase 2.7: Spam/Ham action handlers (uses ModerationActionService)
    private async Task HandleMarkAsSpam(MessageRecord message)
    {
        try
        {
            // Get current user ID for audit trail
            // Get executor Actor from authentication state
            Actor executor;
            try
            {
                executor = await AuthHelper.GetCurrentActorAsync();
            }
            catch (InvalidOperationException ex)
            {
                Snackbar.Add(ex.Message, Severity.Error);
                return;
            }

            // Call moderation service (deletes message, bans user globally, creates detection result)
            var result = await ModerationService.MarkAsSpamAndBanAsync(
                message.MessageId,
                message.UserId,
                message.ChatId,
                executor,
                "Manually marked as spam by admin via UI");

            if (result.Success)
            {
                // Refresh detection history for this message in the wrapper
                var history = await DetectionResultsRepository.GetByMessageIdAsync(message.MessageId);
                var messageWrapper = _allMessages.FirstOrDefault(m => m.Message.MessageId == message.MessageId);
                if (messageWrapper != null)
                {
                    messageWrapper.DetectionResults.Clear();
                    messageWrapper.DetectionResults.AddRange(history);
                }

                // Refresh spam check display
                if (history.Any())
                {
                    var latest = history.OrderByDescending(h => h.DetectedAt).First();
                    _spamChecks[message.MessageId] = new SpamCheckRecord(
                        Id: latest.Id,
                        CheckTimestamp: latest.DetectedAt,
                        UserId: message.UserId,
                        ContentHash: null,
                        IsSpam: latest.IsSpam,
                        Confidence: Math.Abs(latest.NetConfidence), // Use absolute net_confidence for display
                        Reason: latest.Reason,
                        CheckType: latest.DetectionMethod,
                        MatchedMessageId: null
                    );
                }

                StateHasChanged();

                Logger.LogInformation(
                    "Message {MessageId} marked as spam: user banned from {ChatsAffected} chats, message deleted: {MessageDeleted}",
                    message.MessageId, result.ChatsAffected, result.MessageDeleted);
            }
            else
            {
                Logger.LogError("Failed to mark message {MessageId} as spam: {Error}", message.MessageId, result.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to mark message {MessageId} as spam", message.MessageId);
        }
    }

    private async Task HandleMarkAsHam(MessageRecord message)
    {
        try
        {
            // Get current user ID for audit trail
            // Get executor Actor from authentication state
            Actor executor;
            try
            {
                executor = await AuthHelper.GetCurrentActorAsync();
            }
            catch (InvalidOperationException ex)
            {
                Snackbar.Add(ex.Message, Severity.Error);
                return;
            }

            // Check if this was previously marked as spam (false positive correction scenario)
            var wasPreviouslySpam = GetSpamCheck(message.MessageId)?.IsSpam == true;

            // 1. Create detection result marked as ham (for training data)
            var reason = wasPreviouslySpam
                ? "Manually marked as ham (not spam) by admin - false positive correction"
                : "Manually added as ham training sample by admin";

            var detectionResult = new DetectionResultRecord
            {
                MessageId = message.MessageId,
                DetectedAt = DateTimeOffset.UtcNow,
                DetectionSource = "manual",
                DetectionMethod = "Manual",
                // IsSpam computed from net_confidence (-100 = strong ham)
                Confidence = 0, // 0% spam (ham)
                Reason = reason,
                AddedBy = executor,
                UserId = message.UserId,
                UsedForTraining = true, // Manual decisions are always training-worthy
                NetConfidence = -100, // Strong ham signal (manual admin decision)
                CheckResultsJson = null,
                EditVersion = 0
            };

            await DetectionResultsRepository.InsertAsync(detectionResult);

            // 2. Only unban and restore trust if this was previously marked as spam (false positive correction)
            if (wasPreviouslySpam)
            {
                var unbanResult = await ModerationService.UnbanUserAsync(
                    message.UserId,
                    executor,
                    "False positive correction - message marked as ham by admin via UI",
                    restoreTrust: true); // Restore trust to bypass future spam checks

                if (unbanResult.Success)
                {
                    Logger.LogInformation(
                        "Message {MessageId} marked as ham (false positive correction): user unbanned from {ChatsAffected} chats, trust restored: {TrustRestored}",
                        message.MessageId, unbanResult.ChatsAffected, unbanResult.TrustRestored);
                }
                else
                {
                    Logger.LogWarning("Message {MessageId} marked as ham but unban failed: {Error}", message.MessageId, unbanResult.ErrorMessage);
                }
            }
            else
            {
                Logger.LogInformation(
                    "Message {MessageId} marked as ham (training sample): detection result created with net_confidence = -100",
                    message.MessageId);
            }

            // Refresh detection history for this message in the wrapper
            var history = await DetectionResultsRepository.GetByMessageIdAsync(message.MessageId);
            var messageWrapper = _allMessages.FirstOrDefault(m => m.Message.MessageId == message.MessageId);
            if (messageWrapper != null)
            {
                messageWrapper.DetectionResults.Clear();
                messageWrapper.DetectionResults.AddRange(history);
            }

            // Refresh spam check display
            if (history.Any())
            {
                var latest = history.OrderByDescending(h => h.DetectedAt).First();
                _spamChecks[message.MessageId] = new SpamCheckRecord(
                    Id: latest.Id,
                    CheckTimestamp: latest.DetectedAt,
                    UserId: message.UserId,
                    ContentHash: null,
                    IsSpam: latest.IsSpam,
                    Confidence: Math.Abs(latest.NetConfidence), // Use absolute net_confidence for display
                    Reason: latest.Reason,
                    CheckType: latest.DetectionMethod,
                    MatchedMessageId: null
                );
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to mark message {MessageId} as ham", message.MessageId);
        }
    }

    private async Task HandleViewDetections(MessageRecord message)
    {
        var history = await DetectionResultsRepository.GetByMessageIdAsync(message.MessageId);

        var parameters = new DialogParameters<DetectionHistoryDialog>
        {
            { x => x.Message, message },
            { x => x.DetectionResults, history }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<DetectionHistoryDialog>("Detection History", parameters, options);
    }

    private void HandleFilterByUser(long userId)
    {
        // Set user filter
        var messageWrapper = _allMessages.FirstOrDefault(mw => mw.Message.UserId == userId);
        if (messageWrapper != null)
        {
            _filterState.UserName = messageWrapper.Message.UserName ?? $"User {userId}";
            ApplyFilters();
            StateHasChanged();
        }
    }

    private void HandleFilterByChat(long chatId)
    {
        // Set chat filter
        var messageWrapper = _allMessages.FirstOrDefault(mw => mw.Message.ChatId == chatId);
        if (messageWrapper != null && !string.IsNullOrEmpty(messageWrapper.Message.ChatName))
        {
            _filterState.ChatName = messageWrapper.Message.ChatName;
            ApplyFilters();
            StateHasChanged();
        }
    }

    private async Task HandleDeleteMessage(MessageRecord message)
    {
        // Confirm deletion
        bool? confirm = await DialogService.ShowMessageBox(
            "Delete Message",
            $"Are you sure you want to delete this message? This will remove it from Telegram (if still present) and mark it as deleted in the database.",
            yesText: "Delete",
            cancelText: "Cancel");

        if (confirm != true)
            return;

        try
        {
            // Get executor Actor from authentication state
            Actor executor;
            try
            {
                executor = await AuthHelper.GetCurrentActorAsync();
            }
            catch (InvalidOperationException ex)
            {
                Snackbar.Add(ex.Message, Severity.Error);
                return;
            }

            // Call moderation service to delete the message (service handles bot client internally)
            var result = await ModerationService.DeleteMessageAsync(
                messageId: message.MessageId,
                chatId: message.ChatId,
                userId: message.UserId,
                deletedBy: executor,
                reason: "Manual deletion from Messages UI");

            if (result.Success)
            {
                // Update the message in place to show it's deleted (don't remove from UI)
                var updatedMessage = await MessageRepository.GetMessageAsync(message.MessageId);
                if (updatedMessage != null)
                {
                    var index = _allMessages.FindIndex(mw => mw.Message.MessageId == message.MessageId);
                    if (index >= 0)
                    {
                        // Preserve existing detection results
                        var existingDetectionResults = _allMessages[index].DetectionResults;
                        _allMessages[index] = new MessageWithDetectionHistory
                        {
                            Message = updatedMessage,
                            DetectionResults = existingDetectionResults
                        };
                        ApplyFilters();
                        StateHasChanged();
                    }
                }

                Logger.LogInformation(
                    "Message {MessageId} marked as deleted, showing DELETED badge in UI",
                    message.MessageId);
            }
            else
            {
                Logger.LogError("Failed to delete message {MessageId}: {Error}", message.MessageId, result.ErrorMessage);

                await DialogService.ShowMessageBox(
                    "Error",
                    $"Failed to delete message: {result.ErrorMessage}",
                    yesText: "OK");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting message {MessageId}", message.MessageId);

            await DialogService.ShowMessageBox(
                "Error",
                $"Failed to delete message: {ex.Message}",
                yesText: "OK");
        }
    }

    private async Task HandleTempBan(MessageRecord message)
    {
        // Show temp ban dialog
        var parameters = new DialogParameters<TempBanDialog>
        {
            { x => x.UserId, message.UserId },
            { x => x.Username, message.UserName ?? message.FirstName ?? $"User {message.UserId}" }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<TempBanDialog>("Temporary Ban", parameters, options);
        var result = await dialog.Result;

        if (result == null || result.Canceled || result.Data is not TempBanDialog.TempBanResult tempBanResult)
            return;

        try
        {
            // Get current user ID for audit trail
            // Get executor Actor from authentication state
            Actor executor;
            try
            {
                executor = await AuthHelper.GetCurrentActorAsync();
            }
            catch (InvalidOperationException ex)
            {
                Snackbar.Add(ex.Message, Severity.Error);
                return;
            }

            // Call moderation service to temp ban the user
            var banResult = await ModerationService.TempBanUserAsync(
                message.UserId,
                message.MessageId,
                executor,
                tempBanResult.Reason,
                tempBanResult.Duration);

            if (banResult.Success)
            {
                var expiryTime = DateTimeOffset.UtcNow.Add(tempBanResult.Duration).LocalDateTime.ToString("yyyy-MM-dd HH:mm:ss");
                await DialogService.ShowMessageBox(
                    "Success",
                    $"User temporarily banned for {FormatDuration(tempBanResult.Duration)}. They will be automatically unbanned at {expiryTime}.",
                    yesText: "OK");

                Logger.LogInformation(
                    "User {UserId} temp banned from {ChatsAffected} chats for {Duration}, expires at {ExpiryTime}",
                    message.UserId, banResult.ChatsAffected, tempBanResult.Duration, expiryTime);
            }
            else
            {
                Logger.LogError("Failed to temp ban user {UserId}: {Error}", message.UserId, banResult.ErrorMessage);

                await DialogService.ShowMessageBox(
                    "Error",
                    $"Failed to temp ban user: {banResult.ErrorMessage}",
                    yesText: "OK");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error temp banning user {UserId}", message.UserId);

            await DialogService.ShowMessageBox(
                "Error",
                $"Failed to temp ban user: {ex.Message}",
                yesText: "OK");
        }
    }

    private static string FormatDuration(TimeSpan duration)
    {
        if (duration.TotalMinutes < 60)
            return $"{(int)duration.TotalMinutes} minute{((int)duration.TotalMinutes == 1 ? "" : "s")}";

        if (duration.TotalHours < 24)
            return $"{(int)duration.TotalHours} hour{((int)duration.TotalHours == 1 ? "" : "s")}";

        var days = (int)duration.TotalDays;
        var hours = duration.Hours;

        if (hours == 0)
            return $"{days} day{(days == 1 ? "" : "s")}";

        return $"{days} day{(days == 1 ? "" : "s")} {hours} hour{(hours == 1 ? "" : "s")}";
    }

    private bool IsCurrentUserMessage(long telegramUserId)
    {
        // Check if message sender matches any of current user's linked Telegram accounts
        return _userTelegramIds.Contains(telegramUserId);
    }

    private async Task ApplyQueryStringFiltersAsync()
    {
        try
        {
            var uri = new Uri(NavigationManager.Uri);
            var query = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(uri.Query);

            // Apply chat filter (from ModerationReportCard: /messages?chat=123&highlight=456)
            if (query.TryGetValue("chat", out var chatIdStr) && long.TryParse(chatIdStr, out var chatIdFilter))
            {
                _selectedChatId = chatIdFilter;
                Logger.LogDebug("Auto-selected chat from query string: {ChatId}", chatIdFilter);
            }

            // Store highlight target (from ModerationReportCard or Users: highlight=456 or messageId=456)
            if (query.TryGetValue("highlight", out var highlightStr) && long.TryParse(highlightStr, out var highlightId))
            {
                _highlightMessageId = highlightId;
                Logger.LogDebug("Will highlight message: {MessageId}", highlightId);
            }
            else if (query.TryGetValue("messageId", out var messageIdStr) && long.TryParse(messageIdStr, out var messageId))
            {
                _highlightMessageId = messageId;
                Logger.LogDebug("Will highlight message: {MessageId}", messageId);
            }

            await Task.CompletedTask; // Satisfy async requirement
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error parsing query string parameters");
        }
    }

    private async Task HandleReplyClick(long targetMessageId)
    {
        try
        {
            // Check if target message is in the loaded list
            var targetMessage = _filteredMessages.FirstOrDefault(mw => mw.Message.MessageId == targetMessageId);

            if (targetMessage == null)
            {
                // Message not loaded yet, load it and scroll to it
                Logger.LogInformation("Target message {MessageId} not in view, loading...", targetMessageId);

                // Load the message from repository
                var message = await MessageRepository.GetMessageAsync(targetMessageId);
                if (message == null)
                {
                    Logger.LogWarning("Target message {MessageId} not found in database", targetMessageId);
                    return;
                }

                // Add to the list if not already there (wrapped in MessageWithDetectionHistory)
                if (_allMessages.All(mw => mw.Message.MessageId != targetMessageId))
                {
                    _allMessages.Add(new MessageWithDetectionHistory { Message = message });
                    ApplyFilters();
                    StateHasChanged();
                }
            }

            // Use JavaScript to scroll to and highlight the message
            await Js.InvokeVoidAsync("scrollToMessage", targetMessageId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to scroll to reply target message {MessageId}", targetMessageId);
        }
    }

    /// <summary>
    /// Detects messages with missing media files and queues them for automatic re-download
    /// Phase 4.X: Media refetch system - handles backup/restore scenarios
    /// Note: Documents are excluded - they're metadata-only and only downloaded by file scanner for security checks
    /// </summary>
    private async Task QueueMissingMediaForRefetchAsync()
    {
        try
        {
            var queuedCount = 0;

            foreach (var msgWrapper in _allMessages)
            {
                var msg = msgWrapper.Message;

                // Check if message has downloadable media but local path is missing
                // Repository validates filesystem and returns null if file doesn't exist
                // IMPORTANT: Exclude Document type - they're metadata-only for security (file scanner handles temporary downloads)
                if (msg.MediaType.HasValue &&
                    msg.MediaType.Value != MediaType.Document &&
                    !string.IsNullOrEmpty(msg.MediaFileId) &&
                    string.IsNullOrEmpty(msg.MediaLocalPath))
                {
                    // Queue for re-download (deduplication handled by queue service)
                    // Real-time UI updates handled by MessageHistoryService.OnMediaUpdated event
                    var wasQueued = await MediaRefetchQueue.EnqueueMediaAsync(msg.MessageId, msg.MediaType.Value);
                    if (wasQueued)
                    {
                        queuedCount++;
                        Logger.LogDebug("Queued missing media: Message {MessageId}, Type {MediaType}",
                            msg.MessageId, msg.MediaType.Value);
                    }
                }
            }

            if (queuedCount > 0)
            {
                Logger.LogInformation("Queued {Count} missing media files for automatic re-download (excluding Documents)", queuedCount);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to queue missing media for refetch");
        }
    }

    /// <summary>
    /// Handle manual translation request for messages that didn't auto-translate
    /// Phase 4.20: Allows users to translate short messages or messages that were below the length threshold
    /// </summary>
    private async Task HandleTranslateMessage(MessageRecord message)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(message.MessageText))
            {
                Snackbar.Add("Cannot translate: message has no text", Severity.Warning);
                return;
            }

            // Call translation service
            var translationResult = await TranslationService.TranslateToEnglishAsync(message.MessageText);

            if (translationResult == null || !translationResult.WasTranslated)
            {
                Snackbar.Add("Message is already in English or translation failed", Severity.Info);
                return;
            }

            // Save translation to database
            var translation = new MessageTranslation(
                Id: 0, // Will be set by INSERT
                MessageId: message.MessageId,
                EditId: null,
                TranslatedText: translationResult.TranslatedText,
                DetectedLanguage: translationResult.DetectedLanguage,
                Confidence: null, // OpenAI doesn't return confidence for translation
                TranslatedAt: DateTimeOffset.UtcNow
            );

            await MessageTranslationService.InsertTranslationAsync(translation);

            // Update the message in memory to include the new translation
            var messageWrapper = _allMessages.FirstOrDefault(mw => mw.Message.MessageId == message.MessageId);
            if (messageWrapper != null)
            {
                // Create a new MessageRecord with the translation (immutable record pattern)
                var updatedMessage = message with { Translation = translation };

                // Replace the message in the wrapper (MessageWithDetectionHistory is a class, not a record)
                var index = _allMessages.IndexOf(messageWrapper);
                if (index >= 0)
                {
                    _allMessages[index] = new MessageWithDetectionHistory
                    {
                        Message = updatedMessage,
                        DetectionResults = messageWrapper.DetectionResults,
                        UserTags = messageWrapper.UserTags,
                        UserNotes = messageWrapper.UserNotes
                    };
                    ApplyFilters(); // Reapply filters to update _filteredMessages
                    StateHasChanged(); // Trigger re-render after all changes complete
                }
            }

            Snackbar.Add($"Translated from {translationResult.DetectedLanguage} to English", Severity.Success);

            Logger.LogInformation(
                "Manually translated message {MessageId} from {Language}",
                message.MessageId,
                translationResult.DetectedLanguage);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to translate message {MessageId}", message.MessageId);
            Snackbar.Add("Translation failed: " + ex.Message, Severity.Error);
        }
    }

    // Scroll state for preserving position when new messages arrive
    private record ScrollState(double ScrollTop, double ScrollHeight, double ClientHeight);

    // ========================================================================
    // Phase 1: Send & Edit Messages as Bot
    // ========================================================================

    /// <summary>
    /// Check if feature is available (bot enabled + user has linked Telegram account)
    /// </summary>
    private async Task CheckFeatureAvailabilityAsync()
    {
        var userId = await AuthHelper.GetCurrentUserIdAsync();
        if (string.IsNullOrEmpty(userId))
        {
            _isFeatureAvailable = false;
            _featureUnavailableReason = "Not authenticated";
            return;
        }

        var result = await WebBotMessagingService.CheckFeatureAvailabilityAsync(userId);
        _isFeatureAvailable = result.IsAvailable;
        _botUserId = result.BotUserId;
        _linkedUsername = result.LinkedUsername;
        _featureUnavailableReason = result.UnavailableReason;
    }

    /// <summary>
    /// Calculate maximum message length accounting for signature
    /// Telegram limit: 4096 characters
    /// Signature format: \n\nâ€”{username} (3 fixed chars + username length)
    /// </summary>
    private int GetMaxMessageLength()
    {
        const int telegramLimit = 4096;

        if (!_isFeatureAvailable || string.IsNullOrEmpty(_linkedUsername))
        {
            return telegramLimit; // No signature, full limit
        }

        var signatureLength = 3 + _linkedUsername.Length; // "\n\nâ€”" + username
        return telegramLimit - signatureLength;
    }

    /// <summary>
    /// Send new message as bot with signature
    /// </summary>
    private async Task SendMessageAsync(string text)
    {
        if (!_selectedChatId.HasValue)
            return;

        var userId = await AuthHelper.GetCurrentUserIdAsync();
        if (string.IsNullOrEmpty(userId))
        {
            Snackbar.Add("Not authenticated", Severity.Error);
            return;
        }

        var result = await WebBotMessagingService.SendMessageAsync(
            userId,
            _selectedChatId.Value,
            text,
            _replyToMessageId);

        if (result.Success)
        {
            _replyToMessageId = null; // Clear reply state
            Snackbar.Add("Message sent", Severity.Success);

            // Refresh messages to show the bot-sent message
            // (Bot doesn't receive updates for its own messages, so manual refresh required)
            await LoadChatMessagesAsync(_selectedChatId.Value);
        }
        else
        {
            Snackbar.Add($"Failed to send message: {result.ErrorMessage}", Severity.Error);
        }
    }

    /// <summary>
    /// Edit existing bot message (no signature)
    /// </summary>
    private async Task EditMessageAsync(string text)
    {
        if (!_isEditingMessageId.HasValue || !_selectedChatId.HasValue)
            return;

        var userId = await AuthHelper.GetCurrentUserIdAsync();
        if (string.IsNullOrEmpty(userId))
        {
            Snackbar.Add("Not authenticated", Severity.Error);
            return;
        }

        var result = await WebBotMessagingService.EditMessageAsync(
            userId,
            _selectedChatId.Value,
            (int)_isEditingMessageId.Value,
            text);

        if (result.Success)
        {
            _isEditingMessageId = null;
            _editingOriginalText = null;
            Snackbar.Add("Message edited", Severity.Success);

            // Refresh messages to show the bot-edited message
            // (Bot doesn't receive updates for its own edits, so manual refresh required)
            await LoadChatMessagesAsync(_selectedChatId.Value);
        }
        else
        {
            Snackbar.Add($"Failed to edit message: {result.ErrorMessage}", Severity.Error);
        }
    }

    /// <summary>
    /// Handle edit button click from MessageBubbleTelegram
    /// </summary>
    private void HandleEditClick(long messageId, string messageText)
    {
        _isEditingMessageId = messageId;
        _editingOriginalText = messageText;
        StateHasChanged();

        Logger.LogDebug("Started editing message {MessageId}", messageId);
    }

    /// <summary>
    /// Handle reply button click from MessageBubbleTelegram
    /// </summary>
    private void HandleReplyToClick(long messageId)
    {
        _replyToMessageId = messageId;
        StateHasChanged();

        Logger.LogDebug("Started reply to message {MessageId}", messageId);
    }

    /// <summary>
    /// Cancel edit mode
    /// </summary>
    private void CancelEdit()
    {
        _isEditingMessageId = null;
        _editingOriginalText = null;
        StateHasChanged();
    }

    /// <summary>
    /// Cancel reply mode
    /// </summary>
    private void CancelReply()
    {
        _replyToMessageId = null;
        StateHasChanged();
    }

    /// <summary>
    /// Get placeholder text based on state
    /// </summary>
    private string GetChatInputPlaceholder()
    {
        if (!_isFeatureAvailable)
            return _featureUnavailableReason ?? "Feature unavailable";

        if (_isEditingMessageId.HasValue)
            return "Edit message...";

        return "Type a message...";
    }

    /// <summary>
    /// Get reply-to user display name
    /// </summary>
    private string? GetReplyToUser()
    {
        if (!_replyToMessageId.HasValue)
            return null;

        var replyMessage = _filteredMessages.FirstOrDefault(mw => mw.Message.MessageId == _replyToMessageId.Value);
        return replyMessage?.Message.UserName ?? replyMessage?.Message.FirstName;
    }

    /// <summary>
    /// Get reply-to message text
    /// </summary>
    private string? GetReplyToText()
    {
        if (!_replyToMessageId.HasValue)
            return null;

        var replyMessage = _filteredMessages.FirstOrDefault(mw => mw.Message.MessageId == _replyToMessageId.Value);
        return replyMessage?.Message.MessageText;
    }

    /// <summary>
    /// Check if message is from the bot
    /// </summary>
    private bool IsBotMessage(long userId)
    {
        return _botUserId.HasValue && userId == _botUserId.Value;
    }
}
