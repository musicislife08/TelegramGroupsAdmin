@page "/messages"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.Extensions.Options
@using Microsoft.JSInterop
@using Telegram.Bot
@using Telegram.Bot.Requests
@using TelegramGroupsAdmin.Auth
@using TelegramGroupsAdmin.Models
@using TelegramGroupsAdmin.Repositories
@using TelegramGroupsAdmin.Services
@using TelegramGroupsAdmin.Services.BackgroundServices
@using TelegramGroupsAdmin.Components.Shared
@using static TelegramGroupsAdmin.Components.Shared.MessageFilters
@inject MessageHistoryRepository MessageRepository
@inject IMessageExportService ExportService
@inject IJSRuntime JS
@inject IDialogService DialogService
@inject IMessageHistoryService MessageHistoryService
@inject AuthenticationStateProvider AuthStateProvider
@inject IDetectionResultsRepository DetectionResultsRepository
@inject IUserActionsRepository UserActionsRepository
@inject IManagedChatsRepository ManagedChatsRepository
@inject Services.Telegram.TelegramBotClientFactory BotClientFactory
@inject IOptions<Configuration.TelegramOptions> TelegramOptions
@inject ILogger<Messages> Logger
@attribute [Authorize]
@implements IDisposable

<PageTitle>Messages - TelegramGroupsAdmin</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">Message History</MudText>

    @* Filters *@
    <MessageFilters Filters="_filterState" OnFiltersChanged="ApplyFilters" />

    @* Actions Bar *@
    <MudPaper Class="pa-3 mb-4" Elevation="1">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
            <MudStack Row="true" Spacing="2">
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           StartIcon="@Icons.Material.Filled.Refresh"
                           OnClick="LoadMessagesAsync"
                           Disabled="_loading">
                    Refresh
                </MudButton>
                @* Export buttons - Admin+ only (permission level >= 1) *@
                @if (_userPermissionLevel >= 1)
                {
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Secondary"
                               StartIcon="@Icons.Material.Filled.Download"
                               OnClick="ExportToCsvAsync"
                               Disabled="_loading || _filteredMessages.Count == 0">
                        Export CSV
                    </MudButton>
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Secondary"
                               StartIcon="@Icons.Material.Filled.DataObject"
                               OnClick="ExportToJsonAsync"
                               Disabled="_loading || _filteredMessages.Count == 0">
                        Export JSON
                    </MudButton>
                }
            </MudStack>
            <MudText Typo="Typo.caption" Color="Color.Secondary">
                Last updated: @_lastUpdate.ToString("HH:mm:ss")
            </MudText>
        </MudStack>
    </MudPaper>

    @* Loading State *@
    @if (_loading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4" />
    }

    @* Message List *@
    @if (_filteredMessages.Any())
    {
        <MudVirtualize Items="_filteredMessages" Context="message" OverscanCount="10">
            <MessageBubble Message="message"
                           SpamCheck="@GetSpamCheck(message.MessageId)"
                           EditCount="@GetEditCount(message.MessageId)"
                           ShowSpamActions="@(_userPermissionLevel >= 1)"
                           DetectionHistory="@GetDetectionHistory(message.MessageId)"
                           OnImageClick="HandleImageClick"
                           OnViewEdits="HandleViewEdits"
                           OnMarkAsSpam="HandleMarkAsSpam"
                           OnMarkAsHam="HandleMarkAsHam"
                           OnViewDetections="HandleViewDetections" />
        </MudVirtualize>
    }
    else if (!_loading)
    {
        <MudPaper Class="pa-8" Elevation="0">
            <MudStack AlignItems="AlignItems.Center" Spacing="3">
                <MudIcon Icon="@Icons.Material.Filled.SearchOff" Size="Size.Large" Color="Color.Secondary" />
                <MudText Typo="Typo.h6" Color="Color.Secondary">No messages found</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">
                    @if (HasActiveFilters())
                    {
                        <text>Try adjusting your filters or refresh the data.</text>
                    }
                    else
                    {
                        <text>HistoryBot hasn't cached any messages yet.</text>
                    }
                </MudText>
            </MudStack>
        </MudPaper>
    }
</MudContainer>

@code {
    private List<MessageRecord> _allMessages = new();
    private List<MessageRecord> _filteredMessages = new();
    private Dictionary<long, SpamCheckRecord> _spamChecks = new();
    private Dictionary<long, int> _editCounts = new();
    private Dictionary<long, List<DetectionResultRecord>> _detectionHistory = new();
    private MessageFilterState _filterState = new();
    private bool _loading = true;
    private DateTime _lastUpdate = DateTime.Now;
    private int _userPermissionLevel = 0; // Default to ReadOnly

    protected override async Task OnInitializedAsync()
    {
        // Get user permission level
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated == true)
        {
            var permissionClaim = user.FindFirst(CustomClaimTypes.PermissionLevel);
            if (permissionClaim != null && int.TryParse(permissionClaim.Value, out var level))
            {
                _userPermissionLevel = level;
            }
        }

        // Subscribe to real-time updates
        MessageHistoryService.OnNewMessage += HandleNewMessage;

        await LoadMessagesAsync();
    }

    public void Dispose()
    {
        // Unsubscribe from events
        MessageHistoryService.OnNewMessage -= HandleNewMessage;
    }

    private async void HandleNewMessage(MessageRecord message)
    {
        // CRITICAL: Must use InvokeAsync because HistoryBot runs on background thread
        await InvokeAsync(async () =>
        {
            // Add to our list
            _allMessages.Insert(0, message); // Add at beginning (most recent first)

            // Load spam check for this new message if it exists
            var messageIds = new[] { message.MessageId };
            var newSpamChecks = await MessageRepository.GetSpamChecksForMessagesAsync(messageIds);
            foreach (var kvp in newSpamChecks)
            {
                _spamChecks[kvp.Key] = kvp.Value;
            }

            // Load edit count for this message
            var newEditCounts = await MessageRepository.GetEditCountsForMessagesAsync(messageIds);
            foreach (var kvp in newEditCounts)
            {
                _editCounts[kvp.Key] = kvp.Value;
            }

            // Reapply filters
            ApplyFilters();
        });
    }

    private async Task LoadMessagesAsync()
    {
        _loading = true;
        StateHasChanged();

        try
        {
            // Load recent messages (last 500)
            _allMessages = await MessageRepository.GetRecentMessagesAsync(500);

            // Load spam checks, edit counts, and detection history for these messages
            if (_allMessages.Any())
            {
                var messageIds = _allMessages.Select(m => m.MessageId);
                _spamChecks = await MessageRepository.GetSpamChecksForMessagesAsync(messageIds);
                _editCounts = await MessageRepository.GetEditCountsForMessagesAsync(messageIds);

                // Load detection history for Admin+ users
                if (_userPermissionLevel >= 1)
                {
                    await LoadDetectionHistoryAsync(messageIds);
                }
            }

            _lastUpdate = DateTime.Now;

            ApplyFilters();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Unexpected error loading messages");
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private void ApplyFilters()
    {
        _filteredMessages = _allMessages
            .Where(m => _filterState.Matches(m, GetSpamCheck(m.MessageId)))
            .ToList();

        StateHasChanged();
    }

    private SpamCheckRecord? GetSpamCheck(long messageId)
    {
        _spamChecks.TryGetValue(messageId, out var check);
        return check;
    }

    private int GetEditCount(long messageId)
    {
        _editCounts.TryGetValue(messageId, out var count);
        return count;
    }

    private List<DetectionResultRecord>? GetDetectionHistory(long messageId)
    {
        _detectionHistory.TryGetValue(messageId, out var history);
        return history;
    }

    private async Task LoadDetectionHistoryAsync(IEnumerable<long> messageIds)
    {
        try
        {
            foreach (var messageId in messageIds)
            {
                var history = await DetectionResultsRepository.GetByMessageIdAsync(messageId);
                if (history.Any())
                {
                    _detectionHistory[messageId] = history;
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load detection history");
        }
    }

    private async Task ExportToCsvAsync()
    {
        try
        {
            var spamChecks = new Dictionary<long, SpamCheckRecord?>();
            var csvBytes = await ExportService.ExportToCsvAsync(_filteredMessages, spamChecks);

            var fileName = $"messages_{DateTime.Now:yyyyMMdd_HHmmss}.csv";
            await DownloadFileAsync(fileName, csvBytes);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Unexpected error exporting messages to CSV");
        }
    }

    private async Task ExportToJsonAsync()
    {
        try
        {
            var spamChecks = new Dictionary<long, SpamCheckRecord?>();
            var jsonBytes = await ExportService.ExportToJsonAsync(_filteredMessages, spamChecks);

            var fileName = $"messages_{DateTime.Now:yyyyMMdd_HHmmss}.json";
            await DownloadFileAsync(fileName, jsonBytes);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Unexpected error exporting messages to JSON");
        }
    }

    private async Task DownloadFileAsync(string fileName, byte[] data)
    {
        // Use native Blazor streaming - more efficient than base64 encoding
        var fileStream = new MemoryStream(data);
        using var streamRef = new DotNetStreamReference(stream: fileStream);
        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    private async Task HandleImageClick(MessageRecord message)
    {
        var parameters = new DialogParameters<ImageViewerDialog>
        {
            { x => x.Message, message }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<ImageViewerDialog>("Image Viewer", parameters, options);
    }

    private async Task HandleViewEdits(MessageRecord message)
    {
        var parameters = new DialogParameters<EditHistoryDialog>
        {
            { x => x.Message, message }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<EditHistoryDialog>("Edit History", parameters, options);
    }

    private bool HasActiveFilters()
    {
        return !string.IsNullOrEmpty(_filterState.SearchText)
               || !string.IsNullOrEmpty(_filterState.UserName)
               || !string.IsNullOrEmpty(_filterState.ChatName)
               || _filterState.SpamFilter != SpamFilterOption.All
               || _filterState.StartDate.HasValue
               || _filterState.EndDate.HasValue
               || _filterState.HasImages.HasValue
               || _filterState.HasLinks.HasValue
               || _filterState.HasEdits.HasValue;
    }

    // Phase 2.6: Spam/Ham action handlers
    private async Task HandleMarkAsSpam(MessageRecord message)
    {
        try
        {
            // Create detection result marked as spam (manual classification)
            var detectionResult = new DetectionResultRecord
            {
                MessageId = message.MessageId,
                DetectedAt = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
                DetectionSource = "manual",
                DetectionMethod = "Manual",
                IsSpam = true,
                Confidence = 100, // Manual classifications are 100% confident
                Reason = "Manually marked as spam by admin",
                AddedBy = (await AuthStateProvider.GetAuthenticationStateAsync()).User.Identity?.Name,
                UsedForTraining = true, // Manual decisions are always training-worthy
                NetConfidence = null, // Manual classifications don't have net confidence
                CheckResultsJson = null,
                EditVersion = 0
            };

            await DetectionResultsRepository.InsertAsync(detectionResult);

            // Refresh detection history for this message
            var history = await DetectionResultsRepository.GetByMessageIdAsync(message.MessageId);
            _detectionHistory[message.MessageId] = history;

            // Refresh spam check display
            if (history.Any())
            {
                var latest = history.OrderByDescending(h => h.DetectedAt).First();
                _spamChecks[message.MessageId] = new SpamCheckRecord(
                    Id: latest.Id,
                    CheckTimestamp: latest.DetectedAt,
                    UserId: message.UserId,
                    ContentHash: null,
                    IsSpam: latest.IsSpam,
                    Confidence: latest.Confidence,
                    Reason: latest.Reason,
                    CheckType: latest.DetectionMethod,
                    MatchedMessageId: null
                );
            }

            StateHasChanged();

            Logger.LogInformation("Message {MessageId} marked as spam by user", message.MessageId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to mark message {MessageId} as spam", message.MessageId);
        }
    }

    private async Task HandleMarkAsHam(MessageRecord message)
    {
        try
        {
            // Create detection result marked as ham/not spam (manual classification)
            var detectionResult = new DetectionResultRecord
            {
                MessageId = message.MessageId,
                DetectedAt = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
                DetectionSource = "manual",
                DetectionMethod = "Manual",
                IsSpam = false, // Mark as NOT spam
                Confidence = 100, // Manual classifications are 100% confident
                Reason = "Manually marked as ham (not spam) by admin - false positive correction",
                AddedBy = (await AuthStateProvider.GetAuthenticationStateAsync()).User.Identity?.Name,
                UsedForTraining = true, // Manual decisions are always training-worthy
                NetConfidence = null,
                CheckResultsJson = null,
                EditVersion = 0
            };

            await DetectionResultsRepository.InsertAsync(detectionResult);

            // Phase 2.7: Implement unban logic if user was auto-banned
            await HandleUnbanIfNeededAsync(message);

            // Refresh detection history for this message
            var history = await DetectionResultsRepository.GetByMessageIdAsync(message.MessageId);
            _detectionHistory[message.MessageId] = history;

            // Refresh spam check display
            if (history.Any())
            {
                var latest = history.OrderByDescending(h => h.DetectedAt).First();
                _spamChecks[message.MessageId] = new SpamCheckRecord(
                    Id: latest.Id,
                    CheckTimestamp: latest.DetectedAt,
                    UserId: message.UserId,
                    ContentHash: null,
                    IsSpam: latest.IsSpam,
                    Confidence: latest.Confidence,
                    Reason: latest.Reason,
                    CheckType: latest.DetectionMethod,
                    MatchedMessageId: null
                );
            }

            StateHasChanged();

            Logger.LogInformation("Message {MessageId} marked as ham by user", message.MessageId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to mark message {MessageId} as ham", message.MessageId);
        }
    }

    private async Task HandleViewDetections(MessageRecord message)
    {
        var history = await DetectionResultsRepository.GetByMessageIdAsync(message.MessageId);

        var parameters = new DialogParameters<DetectionHistoryDialog>
        {
            { x => x.Message, message },
            { x => x.DetectionResults, history }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<DetectionHistoryDialog>("Detection History", parameters, options);
    }

    /// <summary>
    /// Phase 2.7: Handle unban if user was auto-banned (false positive correction)
    /// </summary>
    private async Task HandleUnbanIfNeededAsync(MessageRecord message)
    {
        try
        {
            // Check if user has active bans
            var activeBans = await UserActionsRepository.GetActiveActionsAsync(message.UserId, UserActionType.Ban);

            if (!activeBans.Any())
            {
                Logger.LogInformation("No active bans found for user {UserId} - skipping unban", message.UserId);
                return;
            }

            Logger.LogInformation(
                "Found {BanCount} active ban(s) for user {UserId} - proceeding with unban",
                activeBans.Count,
                message.UserId);

            // Create unban action in database
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var unbanAction = new UserActionRecord(
                Id: 0, // Will be assigned by database
                UserId: message.UserId,
                ActionType: UserActionType.Unban,
                MessageId: message.MessageId,
                IssuedBy: authState.User.Identity?.Name ?? "Admin",
                IssuedAt: DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
                ExpiresAt: null,
                Reason: "False positive correction - message marked as ham by admin"
            );

            await UserActionsRepository.InsertAsync(unbanAction);

            // Deactivate all active bans for this user
            foreach (var ban in activeBans)
            {
                await UserActionsRepository.DeactivateAsync(ban.Id);
            }

            // Unban user across all managed chats via Telegram API
            var managedChats = await ManagedChatsRepository.GetAllChatsAsync();
            var activeChats = managedChats.Where(c => c.IsActive).ToList();
            var botClient = BotClientFactory.GetOrCreate(TelegramOptions.Value.BotToken);

            int successCount = 0;
            int failCount = 0;

            foreach (var chat in activeChats)
            {
                try
                {
                    await botClient.UnbanChatMember(
                        chatId: chat.ChatId,
                        userId: message.UserId,
                        onlyIfBanned: true); // Only unban if user is actually banned

                    successCount++;

                    Logger.LogInformation(
                        "Unbanned user {UserId} from chat {ChatId}",
                        message.UserId,
                        chat.ChatId);
                }
                catch (Exception ex)
                {
                    failCount++;
                    Logger.LogWarning(ex,
                        "Failed to unban user {UserId} from chat {ChatId} (may not be banned in this chat)",
                        message.UserId,
                        chat.ChatId);
                }
            }

            Logger.LogInformation(
                "Unban complete for user {UserId}: {SuccessCount}/{TotalCount} successful, {FailCount} failed",
                message.UserId,
                successCount,
                activeChats.Count,
                failCount);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to handle unban for user {UserId}", message.UserId);
        }
    }
}
