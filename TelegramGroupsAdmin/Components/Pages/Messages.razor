@page "/messages"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.JSInterop
@using TelegramGroupsAdmin.Auth
@using TelegramGroupsAdmin.Services
@using TelegramGroupsAdmin.Components.Shared
@using static TelegramGroupsAdmin.Components.Shared.MessageFilters
@inject MessageHistoryRepository MessageRepository
@inject IMessageExportService ExportService
@inject IJSRuntime JS
@inject IDialogService DialogService
@inject IMessageHistoryService MessageHistoryService
@inject AuthenticationStateProvider AuthStateProvider
@inject IDetectionResultsRepository DetectionResultsRepository
@inject ModerationActionService ModerationService
@inject ITelegramUserMappingRepository TelegramMappingRepository
@inject ILogger<Messages> Logger
@attribute [Authorize]
@implements IDisposable

<PageTitle>Messages - TelegramGroupsAdmin</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">Message History</MudText>

    @* Filters *@
    <MessageFilters Filters="_filterState" OnFiltersChanged="ApplyFilters" />

    @* Actions Bar *@
    <MudPaper Class="pa-3 mb-4" Elevation="1">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
            <MudStack Row="true" Spacing="2">
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           StartIcon="@Icons.Material.Filled.Refresh"
                           OnClick="LoadMessagesAsync"
                           Disabled="_loading">
                    Refresh
                </MudButton>
                @* Export buttons - Admin+ only (permission level >= 1) *@
                @if (_userPermissionLevel >= 1)
                {
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Secondary"
                               StartIcon="@Icons.Material.Filled.Download"
                               OnClick="ExportToCsvAsync"
                               Disabled="_loading || _filteredMessages.Count == 0">
                        Export CSV
                    </MudButton>
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Secondary"
                               StartIcon="@Icons.Material.Filled.DataObject"
                               OnClick="ExportToJsonAsync"
                               Disabled="_loading || _filteredMessages.Count == 0">
                        Export JSON
                    </MudButton>
                }
            </MudStack>
            <MudText Typo="Typo.caption" Color="Color.Secondary">
                Last updated: @_lastUpdate.ToString("HH:mm:ss")
            </MudText>
        </MudStack>
    </MudPaper>

    @* Loading State *@
    @if (_loading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4" />
    }

    @* Message List *@
    @if (_filteredMessages.Any())
    {
        <MudVirtualize Items="_filteredMessages" Context="message" OverscanCount="10">
            <MessageBubbleTelegram Message="message"
                                   SpamCheck="@GetSpamCheck(message.MessageId)"
                                   EditCount="@GetEditCount(message.MessageId)"
                                   ShowSpamActions="@(_userPermissionLevel >= 1)"
                                   DetectionHistory="@GetDetectionHistory(message.MessageId)"
                                   IsCurrentUser="@IsCurrentUserMessage(message.UserId)"
                                   OnImageClick="HandleImageClick"
                                   OnViewEdits="HandleViewEdits"
                                   OnMarkAsSpam="HandleMarkAsSpam"
                                   OnMarkAsHam="HandleMarkAsHam"
                                   OnViewDetections="HandleViewDetections"
                                   OnFilterByUser="HandleFilterByUser"
                                   OnFilterByChat="HandleFilterByChat"
                                   OnDeleteMessage="HandleDeleteMessage"
                                   OnReplyClick="HandleReplyClick" />
        </MudVirtualize>

        @* Load More Button *@
        @if (_hasMore && !HasActiveFilters())
        {
            <MudPaper Class="pa-4 mt-4" Elevation="0">
                <MudStack AlignItems="AlignItems.Center" Spacing="2">
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Primary"
                               OnClick="LoadNextPageAsync"
                               Disabled="_loadingMore"
                               StartIcon="@Icons.Material.Filled.ExpandMore"
                               FullWidth="true">
                        @if (_loadingMore)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <text>Loading...</text>
                        }
                        else
                        {
                            <text>Load More Messages</text>
                        }
                    </MudButton>
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        Showing @_allMessages.Count messages
                    </MudText>
                </MudStack>
            </MudPaper>
        }
    }
    else if (!_loading)
    {
        <MudPaper Class="pa-8" Elevation="0">
            <MudStack AlignItems="AlignItems.Center" Spacing="3">
                <MudIcon Icon="@Icons.Material.Filled.SearchOff" Size="Size.Large" Color="Color.Secondary" />
                <MudText Typo="Typo.h6" Color="Color.Secondary">No messages found</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">
                    @if (HasActiveFilters())
                    {
                        <text>Try adjusting your filters or refresh the data.</text>
                    }
                    else
                    {
                        <text>HistoryBot hasn't cached any messages yet.</text>
                    }
                </MudText>
            </MudStack>
        </MudPaper>
    }
</MudContainer>

@code {
    private List<MessageRecord> _allMessages = new();
    private List<MessageRecord> _filteredMessages = new();
    private Dictionary<long, SpamCheckRecord> _spamChecks = new();
    private Dictionary<long, int> _editCounts = new();
    private Dictionary<long, List<DetectionResultRecord>> _detectionHistory = new();
    private MessageFilterState _filterState = new();
    private bool _loading = true;
    private bool _loadingMore = false;
    private bool _hasMore = true;
    private DateTime _lastUpdate = DateTime.Now;
    private int _userPermissionLevel = 0; // Default to ReadOnly
    private HashSet<long> _userTelegramIds = new(); // Current user's linked Telegram IDs
    private const int PageSize = 50;

    protected override async Task OnInitializedAsync()
    {
        // Get user permission level and ID
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        string? userId = null;

        if (user.Identity?.IsAuthenticated == true)
        {
            userId = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
            var permissionClaim = user.FindFirst(CustomClaimTypes.PermissionLevel);
            if (permissionClaim != null && int.TryParse(permissionClaim.Value, out var level))
            {
                _userPermissionLevel = level;
            }
        }

        // Load current user's linked Telegram accounts for message alignment
        if (!string.IsNullOrEmpty(userId))
        {
            try
            {
                var mappings = await TelegramMappingRepository.GetByUserIdAsync(userId);
                _userTelegramIds = mappings.Select(m => m.TelegramId).ToHashSet();
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to load linked Telegram accounts for user {UserId}", userId);
            }
        }

        // Subscribe to real-time updates
        MessageHistoryService.OnNewMessage += HandleNewMessage;

        await LoadMessagesAsync();
    }

    public void Dispose()
    {
        // Unsubscribe from events
        MessageHistoryService.OnNewMessage -= HandleNewMessage;
    }

    private async void HandleNewMessage(MessageRecord message)
    {
        // CRITICAL: Must use InvokeAsync because HistoryBot runs on background thread
        await InvokeAsync(async () =>
        {
            // Add to our list
            _allMessages.Insert(0, message); // Add at beginning (most recent first)

            // Load spam check for this new message if it exists
            var messageIds = new[] { message.MessageId };
            var newSpamChecks = await MessageRepository.GetSpamChecksForMessagesAsync(messageIds);
            foreach (var kvp in newSpamChecks)
            {
                _spamChecks[kvp.Key] = kvp.Value;
            }

            // Load edit count for this message
            var newEditCounts = await MessageRepository.GetEditCountsForMessagesAsync(messageIds);
            foreach (var kvp in newEditCounts)
            {
                _editCounts[kvp.Key] = kvp.Value;
            }

            // Reapply filters
            ApplyFilters();
        });
    }

    private async Task LoadMessagesAsync()
    {
        _loading = true;
        _hasMore = true;
        _allMessages.Clear();
        _spamChecks.Clear();
        _editCounts.Clear();
        _detectionHistory.Clear();
        StateHasChanged();

        try
        {
            // Load first page of messages (most recent)
            var firstPage = await MessageRepository.GetMessagesBeforeAsync(
                beforeTimestamp: null,
                limit: PageSize);

            _allMessages = firstPage;
            _hasMore = firstPage.Count >= PageSize; // If we got a full page, there might be more

            // Load spam checks, edit counts, and detection history for these messages
            if (_allMessages.Any())
            {
                var messageIds = _allMessages.Select(m => m.MessageId);
                _spamChecks = await MessageRepository.GetSpamChecksForMessagesAsync(messageIds);
                _editCounts = await MessageRepository.GetEditCountsForMessagesAsync(messageIds);

                // Load detection history for Admin+ users
                if (_userPermissionLevel >= 1)
                {
                    await LoadDetectionHistoryAsync(messageIds);
                }
            }

            _lastUpdate = DateTime.Now;

            ApplyFilters();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Unexpected error loading messages");
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private async Task LoadNextPageAsync()
    {
        if (!_hasMore || _loadingMore)
            return;

        _loadingMore = true;
        StateHasChanged();

        try
        {
            // Get the oldest timestamp from current messages
            var oldestTimestamp = _allMessages.Last().Timestamp;

            // Load next page
            var nextPage = await MessageRepository.GetMessagesBeforeAsync(
                beforeTimestamp: oldestTimestamp,
                limit: PageSize);

            if (nextPage.Any())
            {
                // Append to existing messages
                _allMessages.AddRange(nextPage);

                // Check if there are more pages
                _hasMore = nextPage.Count >= PageSize;

                // Load metadata for new messages
                var newMessageIds = nextPage.Select(m => m.MessageId);
                var newSpamChecks = await MessageRepository.GetSpamChecksForMessagesAsync(newMessageIds);
                var newEditCounts = await MessageRepository.GetEditCountsForMessagesAsync(newMessageIds);

                // Merge into existing dictionaries
                foreach (var kvp in newSpamChecks)
                    _spamChecks[kvp.Key] = kvp.Value;
                foreach (var kvp in newEditCounts)
                    _editCounts[kvp.Key] = kvp.Value;

                // Load detection history for Admin+ users
                if (_userPermissionLevel >= 1)
                {
                    await LoadDetectionHistoryAsync(newMessageIds);
                }

                // Reapply filters to include new messages
                ApplyFilters();
            }
            else
            {
                _hasMore = false;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading more messages");
        }
        finally
        {
            _loadingMore = false;
            StateHasChanged();
        }
    }

    private void ApplyFilters()
    {
        _filteredMessages = _allMessages
            .Where(m => _filterState.Matches(m, GetSpamCheck(m.MessageId)))
            .ToList();

        StateHasChanged();
    }

    private SpamCheckRecord? GetSpamCheck(long messageId)
    {
        _spamChecks.TryGetValue(messageId, out var check);
        return check;
    }

    private int GetEditCount(long messageId)
    {
        _editCounts.TryGetValue(messageId, out var count);
        return count;
    }

    private List<DetectionResultRecord>? GetDetectionHistory(long messageId)
    {
        _detectionHistory.TryGetValue(messageId, out var history);
        return history;
    }

    private async Task LoadDetectionHistoryAsync(IEnumerable<long> messageIds)
    {
        try
        {
            foreach (var messageId in messageIds)
            {
                var history = await DetectionResultsRepository.GetByMessageIdAsync(messageId);
                if (history.Any())
                {
                    _detectionHistory[messageId] = history;
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load detection history");
        }
    }

    private async Task ExportToCsvAsync()
    {
        try
        {
            var spamChecks = new Dictionary<long, SpamCheckRecord?>();
            var csvBytes = await ExportService.ExportToCsvAsync(_filteredMessages, spamChecks);

            var fileName = $"messages_{DateTime.Now:yyyyMMdd_HHmmss}.csv";
            await DownloadFileAsync(fileName, csvBytes);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Unexpected error exporting messages to CSV");
        }
    }

    private async Task ExportToJsonAsync()
    {
        try
        {
            var spamChecks = new Dictionary<long, SpamCheckRecord?>();
            var jsonBytes = await ExportService.ExportToJsonAsync(_filteredMessages, spamChecks);

            var fileName = $"messages_{DateTime.Now:yyyyMMdd_HHmmss}.json";
            await DownloadFileAsync(fileName, jsonBytes);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Unexpected error exporting messages to JSON");
        }
    }

    private async Task DownloadFileAsync(string fileName, byte[] data)
    {
        // Use native Blazor streaming - more efficient than base64 encoding
        var fileStream = new MemoryStream(data);
        using var streamRef = new DotNetStreamReference(stream: fileStream);
        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    private async Task HandleImageClick(MessageRecord message)
    {
        var parameters = new DialogParameters<ImageViewerDialog>
        {
            { x => x.Message, message }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<ImageViewerDialog>("Image Viewer", parameters, options);
    }

    private async Task HandleViewEdits(MessageRecord message)
    {
        var parameters = new DialogParameters<EditHistoryDialog>
        {
            { x => x.Message, message }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<EditHistoryDialog>("Edit History", parameters, options);
    }

    private bool HasActiveFilters()
    {
        return !string.IsNullOrEmpty(_filterState.SearchText)
               || !string.IsNullOrEmpty(_filterState.UserName)
               || !string.IsNullOrEmpty(_filterState.ChatName)
               || _filterState.SpamFilter != SpamFilterOption.All
               || _filterState.StartDate.HasValue
               || _filterState.EndDate.HasValue
               || _filterState.HasImages.HasValue
               || _filterState.HasLinks.HasValue
               || _filterState.HasEdits.HasValue;
    }

    // Phase 2.7: Spam/Ham action handlers (uses ModerationActionService)
    private async Task HandleMarkAsSpam(MessageRecord message)
    {
        try
        {
            // Get current user ID for audit trail
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var executorId = authState.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;

            // Call moderation service (deletes message, bans user globally, creates detection result)
            var result = await ModerationService.MarkAsSpamAndBanAsync(
                message.MessageId,
                message.UserId,
                message.ChatId,
                executorId,
                "Manually marked as spam by admin via UI");

            if (result.Success)
            {
                // Refresh detection history for this message
                var history = await DetectionResultsRepository.GetByMessageIdAsync(message.MessageId);
                _detectionHistory[message.MessageId] = history;

                // Refresh spam check display
                if (history.Any())
                {
                    var latest = history.OrderByDescending(h => h.DetectedAt).First();
                    _spamChecks[message.MessageId] = new SpamCheckRecord(
                        Id: latest.Id,
                        CheckTimestamp: latest.DetectedAt,
                        UserId: message.UserId,
                        ContentHash: null,
                        IsSpam: latest.IsSpam,
                        Confidence: Math.Abs(latest.NetConfidence), // Use absolute net_confidence for display
                        Reason: latest.Reason,
                        CheckType: latest.DetectionMethod,
                        MatchedMessageId: null
                    );
                }

                StateHasChanged();

                Logger.LogInformation(
                    "Message {MessageId} marked as spam: user banned from {ChatsAffected} chats, message deleted: {MessageDeleted}",
                    message.MessageId, result.ChatsAffected, result.MessageDeleted);
            }
            else
            {
                Logger.LogError("Failed to mark message {MessageId} as spam: {Error}", message.MessageId, result.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to mark message {MessageId} as spam", message.MessageId);
        }
    }

    private async Task HandleMarkAsHam(MessageRecord message)
    {
        try
        {
            // Get current user ID for audit trail
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var executorId = authState.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;

            // Check if this was previously marked as spam (false positive correction scenario)
            var wasPreviouslySpam = GetSpamCheck(message.MessageId)?.IsSpam == true;

            // 1. Create detection result marked as ham (for training data)
            var reason = wasPreviouslySpam
                ? "Manually marked as ham (not spam) by admin - false positive correction"
                : "Manually added as ham training sample by admin";

            var detectionResult = new DetectionResultRecord
            {
                MessageId = message.MessageId,
                DetectedAt = DateTimeOffset.UtcNow,
                DetectionSource = "manual",
                DetectionMethod = "Manual",
                // IsSpam computed from net_confidence (-100 = strong ham)
                Confidence = 0, // 0% spam (ham)
                Reason = reason,
                AddedBy = executorId,
                UserId = message.UserId,
                UsedForTraining = true, // Manual decisions are always training-worthy
                NetConfidence = -100, // Strong ham signal (manual admin decision)
                CheckResultsJson = null,
                EditVersion = 0
            };

            await DetectionResultsRepository.InsertAsync(detectionResult);

            // 2. Only unban and restore trust if this was previously marked as spam (false positive correction)
            if (wasPreviouslySpam)
            {
                var unbanResult = await ModerationService.UnbanUserAsync(
                    message.UserId,
                    executorId,
                    "False positive correction - message marked as ham by admin via UI",
                    restoreTrust: true); // Restore trust to bypass future spam checks

                if (unbanResult.Success)
                {
                    Logger.LogInformation(
                        "Message {MessageId} marked as ham (false positive correction): user unbanned from {ChatsAffected} chats, trust restored: {TrustRestored}",
                        message.MessageId, unbanResult.ChatsAffected, unbanResult.TrustRestored);
                }
                else
                {
                    Logger.LogWarning("Message {MessageId} marked as ham but unban failed: {Error}", message.MessageId, unbanResult.ErrorMessage);
                }
            }
            else
            {
                Logger.LogInformation(
                    "Message {MessageId} marked as ham (training sample): detection result created with net_confidence = -100",
                    message.MessageId);
            }

            // Refresh detection history for this message
            var history = await DetectionResultsRepository.GetByMessageIdAsync(message.MessageId);
            _detectionHistory[message.MessageId] = history;

            // Refresh spam check display
            if (history.Any())
            {
                var latest = history.OrderByDescending(h => h.DetectedAt).First();
                _spamChecks[message.MessageId] = new SpamCheckRecord(
                    Id: latest.Id,
                    CheckTimestamp: latest.DetectedAt,
                    UserId: message.UserId,
                    ContentHash: null,
                    IsSpam: latest.IsSpam,
                    Confidence: Math.Abs(latest.NetConfidence), // Use absolute net_confidence for display
                    Reason: latest.Reason,
                    CheckType: latest.DetectionMethod,
                    MatchedMessageId: null
                );
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to mark message {MessageId} as ham", message.MessageId);
        }
    }

    private async Task HandleViewDetections(MessageRecord message)
    {
        var history = await DetectionResultsRepository.GetByMessageIdAsync(message.MessageId);

        var parameters = new DialogParameters<DetectionHistoryDialog>
        {
            { x => x.Message, message },
            { x => x.DetectionResults, history }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<DetectionHistoryDialog>("Detection History", parameters, options);
    }

    private void HandleFilterByUser(long userId)
    {
        // Set user filter
        var user = _allMessages.FirstOrDefault(m => m.UserId == userId);
        if (user != null)
        {
            _filterState.UserName = user.UserName ?? $"User {userId}";
            ApplyFilters();
            StateHasChanged();
        }
    }

    private void HandleFilterByChat(long chatId)
    {
        // Set chat filter
        var message = _allMessages.FirstOrDefault(m => m.ChatId == chatId);
        if (message != null && !string.IsNullOrEmpty(message.ChatName))
        {
            _filterState.ChatName = message.ChatName;
            ApplyFilters();
            StateHasChanged();
        }
    }

    private async Task HandleDeleteMessage(MessageRecord message)
    {
        // Confirm deletion
        bool? confirm = await DialogService.ShowMessageBox(
            "Delete Message",
            $"Are you sure you want to delete this message? This will remove it from Telegram (if still present) and mark it as deleted in the database.",
            yesText: "Delete",
            cancelText: "Cancel");

        if (confirm != true)
            return;

        try
        {
            // Call moderation service to delete the message (service handles bot client internally)
            var result = await ModerationService.DeleteMessageAsync(
                message.MessageId,
                message.ChatId);

            if (result.Success)
            {
                // Update the message in place to show it's deleted (don't remove from UI)
                var updatedMessage = await MessageRepository.GetMessageAsync(message.MessageId);
                if (updatedMessage != null)
                {
                    var index = _allMessages.FindIndex(m => m.MessageId == message.MessageId);
                    if (index >= 0)
                    {
                        _allMessages[index] = updatedMessage;
                        ApplyFilters();
                        StateHasChanged();
                    }
                }

                Logger.LogInformation(
                    "Message {MessageId} marked as deleted, showing DELETED badge in UI",
                    message.MessageId);
            }
            else
            {
                Logger.LogError("Failed to delete message {MessageId}: {Error}", message.MessageId, result.ErrorMessage);

                await DialogService.ShowMessageBox(
                    "Error",
                    $"Failed to delete message: {result.ErrorMessage}",
                    yesText: "OK");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting message {MessageId}", message.MessageId);

            await DialogService.ShowMessageBox(
                "Error",
                $"Failed to delete message: {ex.Message}",
                yesText: "OK");
        }
    }

    private bool IsCurrentUserMessage(long telegramUserId)
    {
        // Check if message sender matches any of current user's linked Telegram accounts
        return _userTelegramIds.Contains(telegramUserId);
    }

    private async Task HandleReplyClick(long targetMessageId)
    {
        try
        {
            // Check if target message is in the loaded list
            var targetMessage = _filteredMessages.FirstOrDefault(m => m.MessageId == targetMessageId);

            if (targetMessage == null)
            {
                // Message not loaded yet, load it and scroll to it
                Logger.LogInformation("Target message {MessageId} not in view, loading...", targetMessageId);

                // Load the message from repository
                var message = await MessageRepository.GetMessageAsync(targetMessageId);
                if (message == null)
                {
                    Logger.LogWarning("Target message {MessageId} not found in database", targetMessageId);
                    return;
                }

                // Add to the list if not already there
                if (!_allMessages.Any(m => m.MessageId == targetMessageId))
                {
                    _allMessages.Add(message);
                    ApplyFilters();
                    StateHasChanged();
                }
            }

            // Use JavaScript to scroll to and highlight the message
            await JS.InvokeVoidAsync("scrollToMessage", targetMessageId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to scroll to reply target message {MessageId}", targetMessageId);
        }
    }
}
