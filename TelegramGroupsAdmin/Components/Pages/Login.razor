@page "/login"
@using System.ComponentModel.DataAnnotations
@using System.Security.Claims
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Authentication.Cookies
@using TelegramGroupsAdmin.Auth
@using TelegramGroupsAdmin.Helpers
@using TelegramGroupsAdmin.Services
@using TelegramGroupsAdmin.Services.Auth
@inject IAuthService AuthService
@inject IIntermediateAuthService IntermediateAuthService
@inject IFeatureAvailabilityService FeatureAvailability
@inject IHttpContextAccessor HttpContextAccessor
@inject ILogger<Login> Logger
@inject NavigationManager Navigation
@attribute [AllowAnonymous]
@attribute [ExcludeFromInteractiveRouting]

<PageTitle>Login - Telegram Groups Admin</PageTitle>

<div class="login-container">
    <h1 class="login-title">Telegram Groups Admin</h1>
    <p class="login-subtitle">Sign in to your account</p>

    @if (!string.IsNullOrEmpty(_successMessage))
    {
        <div class="alert-success">@_successMessage</div>
    }

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="alert-error">@_errorMessage</div>
    }

    <EditForm Model="@Model" FormName="login-form" OnValidSubmit="HandleLoginAsync" method="post">
        <DataAnnotationsValidator />

        <div class="form-group">
            <label class="form-label" for="email">Email</label>
            <input type="email"
                   id="email"
                   name="Model.Email"
                   class="form-input"
                   value="@Model!.Email"
                   placeholder="your.email@example.com"
                   required />
            <ValidationMessage For="@(() => Model!.Email)" />
        </div>

        <div class="form-group">
            <label class="form-label" for="password">Password</label>
            <input type="password"
                   id="password"
                   name="Model.Password"
                   class="form-input"
                   value="@Model!.Password"
                   required />
            <ValidationMessage For="@(() => Model!.Password)" />
        </div>

        <button type="submit" class="btn-primary">Sign In</button>
    </EditForm>

    <div class="divider"></div>

    <p class="text-center">
        @if (_isPasswordResetEnabled)
        {
            <span><a href="/forgot-password" style="color: #594ae2;">Forgot your password?</a><br /></span>
            <span>Need to verify your email? <a href="/resend-verification" style="color: #594ae2;">Resend verification email</a><br /></span>
        }
        else
        {
            <div class="alert-info" style="margin-bottom: 1rem;">
                Password reset and email verification are unavailable (email service not configured). Contact your administrator.
            </div>
        }
        Need an invite? Contact your administrator.
    </p>
</div>

@code {
    [SupplyParameterFromForm]
    private LoginModel? Model { get; set; }

    [SupplyParameterFromQuery(Name = "returnUrl")]
    private string? ReturnUrl { get; set; }

    [SupplyParameterFromQuery(Name = "verified")]
    private string? Verified { get; set; }

    private string? _errorMessage;
    private string? _successMessage;
    private bool _isPasswordResetEnabled;

    protected override async Task OnInitializedAsync()
    {
        Model ??= new LoginModel();

        // Check if password reset feature is available
        _isPasswordResetEnabled = await FeatureAvailability.IsPasswordResetEnabledAsync();

        // Redirect to registration if no users exist (first run)
        if (await AuthService.IsFirstRunAsync())
        {
            Navigation.NavigateTo("/register", forceLoad: true);
            return;
        }

        // Handle email verification status messages
        if (!string.IsNullOrEmpty(Verified))
        {
            _successMessage = Verified switch
            {
                "success" => "Email verified successfully! You can now log in.",
                "already" => "Your email is already verified. Please log in.",
                _ => null
            };
        }
    }

    private async Task HandleLoginAsync()
    {
        _errorMessage = null;

        if (Model == null)
        {
            _errorMessage = "Form data is missing.";
            return;
        }

        try
        {
            // Validate and sanitize returnUrl once to prevent open redirect attacks
            var safeReturnUrl = UrlHelpers.GetSafeRedirectUrl(ReturnUrl);

            // Validate credentials server-side
            var result = await AuthService.LoginAsync(Model.Email, Model.Password);

            if (!result.Success)
            {
                _errorMessage = result.ErrorMessage;
                return;
            }

            // Check if user needs to set up TOTP (admin enabled but no secret yet)
            if (result.TotpEnabled && !result.RequiresTotp)
            {
                // SECURITY: Generate intermediate authentication token (valid for 5 minutes)
                var intermediateToken = IntermediateAuthService.CreateToken(result.UserId!);
                var setupUrl = UrlHelpers.BuildSetup2FAUrl(result.UserId, intermediateToken, safeReturnUrl);
                HttpContextAccessor.HttpContext?.Response.Redirect(setupUrl);
                return;
            }

            // If TOTP is required, redirect to verification page
            if (result.RequiresTotp)
            {
                // SECURITY: Generate intermediate authentication token (valid for 5 minutes)
                // This prevents authentication bypass attacks where an attacker could directly
                // access /login/verify?userId=VICTIM_ID and brute-force TOTP codes
                var intermediateToken = IntermediateAuthService.CreateToken(result.UserId!);
                var verifyUrl = UrlHelpers.BuildVerifyUrl(result.UserId, intermediateToken, safeReturnUrl);
                HttpContextAccessor.HttpContext?.Response.Redirect(verifyUrl);
                return;
            }

            // Sign in the user with cookie authentication (works in static SSR)
            var httpContext = HttpContextAccessor.HttpContext;
            if (httpContext == null)
            {
                _errorMessage = "Unable to complete authentication. Please try again.";
                return;
            }

            var claims = new List<Claim>
            {
                new(ClaimTypes.NameIdentifier, result.UserId!),
                new(ClaimTypes.Email, result.Email!),
                new(ClaimTypes.Role, GetRoleName(result.PermissionLevel!.Value)),
                new(CustomClaimTypes.PermissionLevel, result.PermissionLevel.Value.ToString())
            };

            var claimsIdentity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);
            var claimsPrincipal = new ClaimsPrincipal(claimsIdentity);

            var authProperties = new AuthenticationProperties
            {
                IsPersistent = true,
                ExpiresUtc = DateTimeOffset.UtcNow.AddDays(30)
            };

            await httpContext.SignInAsync(
                CookieAuthenticationDefaults.AuthenticationScheme,
                claimsPrincipal,
                authProperties);

            // Redirect using HttpContext (safeReturnUrl validated at top of try block)
            httpContext.Response.Redirect(safeReturnUrl);
        }
        catch (Exception ex)
        {
            _errorMessage = "An error occurred during login. Please try again.";
            Logger.LogError(ex, "Unexpected error during login for email {Email}", Model.Email);
        }
    }

    private static string GetRoleName(int permissionLevel) => permissionLevel switch
    {
        0 => "Admin",
        1 => "GlobalAdmin",
        2 => "Owner",
        _ => "Admin"
    };

    public class LoginModel
    {
        [Required(ErrorMessage = "Email is required")]
        [EmailAddress(ErrorMessage = "Invalid email address")]
        public string Email { get; set; } = string.Empty;

        [Required(ErrorMessage = "Password is required")]
        public string Password { get; set; } = string.Empty;
    }
}
