@using TelegramGroupsAdmin.BackgroundJobs.Services.Backup
@using TelegramGroupsAdmin.BackgroundJobs.Services
@using TelegramGroupsAdmin.Configuration.Models
@using TelegramGroupsAdmin.Core.Utilities
@using TelegramGroupsAdmin.Core.BackgroundJobs
@using TelegramGroupsAdmin.Core.Models.BackgroundJobSettings
@using Microsoft.EntityFrameworkCore
@using TelegramGroupsAdmin.Data
@using System.Text.Json
@inject IBackupService BackupService
@inject IBackgroundJobConfigService JobConfigService
@inject IDbContextFactory<AppDbContext> ContextFactory
@inject ISnackbar Snackbar
@inject IJSRuntime JsRuntime
@inject NavigationManager Navigation
@inject IDialogService DialogService

@if (!_encryptionConfigured)
{
    <!-- Encryption setup required banner -->
    <MudAlert Severity="Severity.Warning" Variant="Variant.Filled" Class="mb-4">
        <MudText Typo="Typo.h6">Backup Encryption Setup Required</MudText>
        <MudText Typo="Typo.body2">
            All backups are encrypted for security. Click the button below to generate your encryption passphrase.
        </MudText>
        <MudButton Variant="Variant.Filled"
                   Color="Color.Warning"
                   StartIcon="@Icons.Material.Filled.Lock"
                   OnClick="@OpenEncryptionSetupDialog"
                   Class="mt-2">
            Set Up Encryption Now
        </MudButton>
    </MudAlert>
}
else
{
    <MudGrid>
        <!-- Create Backup Section -->
        <MudItem xs="12" md="6">
            <MudPaper Class="pa-4" Elevation="0" Outlined="true">
                <MudText Typo="Typo.h6" Class="mb-2">
                    <MudIcon Icon="@Icons.Material.Filled.Backup" Class="mr-2" />
                    Create Encrypted Backup
                </MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
                    Export a complete encrypted backup of all system data
                </MudText>

                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           StartIcon="@Icons.Material.Filled.Backup"
                           OnClick="@CreateManualBackup"
                           Disabled="@_isExporting"
                           FullWidth="true">
                    @if (_isExporting)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        <span>Creating backup...</span>
                    }
                    else
                    {
                        <span>Backup Now</span>
                    }
                </MudButton>

                @if (_lastBackupFilename != null)
                {
                    <MudAlert Severity="Severity.Success" Class="mt-4">
                        Backup saved: <strong>@_lastBackupFilename</strong> (@FormatBytes(_lastBackupSize))
                    </MudAlert>
                }

                <MudAlert Severity="Severity.Info" Class="mt-4" Dense="true">
                    <MudText Typo="Typo.body2">
                        <strong>What's included:</strong> Users, messages, spam config, bans/warnings, Telegram mappings, chats, reports, audit logs
                    </MudText>
                </MudAlert>

                <MudAlert Severity="Severity.Success" Class="mt-2" Dense="true">
                    <MudText Typo="Typo.body2">
                        <strong>Security:</strong> All backups are encrypted with AES-256-GCM. Your passphrase is stored encrypted in the database.
                    </MudText>
                </MudAlert>

                <MudDivider Class="my-4" />

                <MudButton Variant="Variant.Outlined"
                           Color="Color.Secondary"
                           StartIcon="@Icons.Material.Filled.Autorenew"
                           OnClick="@OpenRotatePassphraseDialog"
                           FullWidth="true">
                    Rotate Encryption Passphrase
                </MudButton>
            </MudPaper>
        </MudItem>

        <!-- Restore from Upload Section -->
        <MudItem xs="12" md="6">
            <MudPaper Class="pa-4" Elevation="0" Outlined="true">
                <MudText Typo="Typo.h6" Class="mb-2">
                    <MudIcon Icon="@Icons.Material.Filled.SettingsBackupRestore" Class="mr-2" />
                    Restore from Upload
                </MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
                    Upload a backup file to restore (THIS WILL WIPE ALL CURRENT DATA)
                </MudText>

                @if (_uploadMetadata != null)
                {
                    <MudPaper Class="pa-3 mb-3" Elevation="0" Outlined="true">
                        <MudText Typo="Typo.subtitle2" Class="mb-2">Backup Info</MudText>
                        <MudText Typo="Typo.body2"><strong>Created:</strong> <span class="local-timestamp" data-utc="@_uploadMetadata.CreatedAt.ToString("o")">@_uploadMetadata.CreatedAt.ToLocalTime().ToString("yyyy-MM-dd HH:mm")</span></MudText>
                        <MudText Typo="Typo.body2"><strong>Version:</strong> @_uploadMetadata.Version | <strong>Tables:</strong> @_uploadMetadata.TableCount</MudText>
                        <MudText Typo="Typo.body2"><strong>Size:</strong> @FormatBytes(_selectedFile?.Size ?? 0)</MudText>
                        @if (_uploadIsEncrypted)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Success" Icon="@Icons.Material.Filled.Lock" Class="mt-2">Encrypted</MudChip>
                        }
                    </MudPaper>
                }

                <MudFileUpload T="IBrowserFile" FilesChanged="@OnFileSelected" Accept=".tar.gz,.gz">
                    <ActivatorContent>
                        <MudButton Variant="Variant.Outlined"
                                   Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.Upload"
                                   Disabled="@_isRestoring"
                                   FullWidth="true">
                            Select Backup File
                        </MudButton>
                    </ActivatorContent>
                </MudFileUpload>

                @if (_selectedFile != null)
                {
                    <MudText Typo="Typo.body2" Class="mt-2">
                        <strong>@_selectedFile.Name</strong> (@FormatBytes(_selectedFile.Size))
                    </MudText>
                }

                @if (_backupBytes != null && !_isRestoring)
                {
                    <MudCheckBox @bind-Value="_confirmWipe" Color="Color.Error" Class="mt-3" Dense="true">
                        I understand this will <strong>permanently delete all current data</strong>
                    </MudCheckBox>

                    <MudButton Variant="Variant.Filled"
                               Color="Color.Error"
                               StartIcon="@Icons.Material.Filled.RestoreFromTrash"
                               OnClick="@RestoreFromUpload"
                               Disabled="@(!_confirmWipe)"
                               FullWidth="true"
                               Class="mt-2">
                        WIPE & RESTORE FROM BACKUP
                    </MudButton>
                }

                @if (_isRestoring)
                {
                    <MudProgressLinear Indeterminate="true" Class="mt-3" />
                    <MudText Typo="Typo.body2" Align="Align.Center" Class="mt-2">
                        Restoring... This may take a few minutes.
                    </MudText>
                }

                <MudAlert Severity="Severity.Error" Class="mt-3" Dense="true">
                    <MudText Typo="Typo.body2">
                        <strong>Warning:</strong> Restore wipes ALL data and replaces it with the backup. You will be logged out after restore.
                    </MudText>
                </MudAlert>
            </MudPaper>
        </MudItem>

        <!-- Backup Browser Section -->
        <MudItem xs="12">
            <BackupBrowser BackupDirectory="@_currentBackupDirectory" OnRestoreRequested="RestoreFromBrowser" @ref="_backupBrowser" />
        </MudItem>

        <!-- Backup Configuration Section -->
        <MudItem xs="12">
            <MudPaper Class="pa-4" Elevation="0" Outlined="true">
                <MudStack Spacing="3">
                    <MudText Typo="Typo.h6">
                        <MudIcon Icon="@Icons.Material.Filled.Settings" Class="mr-2" />
                        Backup Configuration
                    </MudText>

                    @if (_backupConfig == null)
                    {
                        <MudProgressLinear Indeterminate="true" />
                    }
                    else
                    {
                        <MudTextField @bind-Value="_editBackupDirectory"
                                     Label="Backup Directory"
                                     Variant="Variant.Outlined"
                                     HelperText="Absolute path where backups are stored"
                                     Placeholder="/data/backups"
                                     Disabled="@_isSavingConfig" />

                        <MudText Typo="Typo.subtitle2">Retention Strategy (Grandfather-Father-Son)</MudText>
                        <MudAlert Severity="Severity.Info" Dense="true">
                            Keeps multiple backup tiers: hourly (short-term), daily, weekly, monthly, yearly (long-term)
                        </MudAlert>

                        <MudNumericField @bind-Value="_editRetainHourlyBackups"
                                       Label="Hourly Backups"
                                       Variant="Variant.Outlined"
                                       Min="0"
                                       Max="168"
                                       HelperText="Keep last N hourly backups (0-168 = 1 week)"
                                       Disabled="@_isSavingConfig" />

                        <MudNumericField @bind-Value="_editRetainDailyBackups"
                                       Label="Daily Backups"
                                       Variant="Variant.Outlined"
                                       Min="0"
                                       Max="31"
                                       HelperText="Keep last N daily backups (0-31)"
                                       Disabled="@_isSavingConfig" />

                        <MudNumericField @bind-Value="_editRetainWeeklyBackups"
                                       Label="Weekly Backups"
                                       Variant="Variant.Outlined"
                                       Min="0"
                                       Max="52"
                                       HelperText="Keep last N weekly backups (0-52)"
                                       Disabled="@_isSavingConfig" />

                        <MudNumericField @bind-Value="_editRetainMonthlyBackups"
                                       Label="Monthly Backups"
                                       Variant="Variant.Outlined"
                                       Min="0"
                                       Max="60"
                                       HelperText="Keep last N monthly backups (0-60 = 5 years)"
                                       Disabled="@_isSavingConfig" />

                        <MudNumericField @bind-Value="_editRetainYearlyBackups"
                                       Label="Yearly Backups"
                                       Variant="Variant.Outlined"
                                       Min="0"
                                       Max="20"
                                       HelperText="Keep last N yearly backups (0-20)"
                                       Disabled="@_isSavingConfig" />

                        <MudStack Row="true" Spacing="2">
                            <MudSwitch @bind-Value="_backupConfig.Enabled"
                                      Color="Color.Success"
                                      Label="@(_backupConfig.Enabled ? "Enabled" : "Disabled")"
                                      Disabled="@_isSavingConfig" />
                            <MudSpacer />
                            <MudButton Variant="Variant.Filled"
                                      Color="Color.Primary"
                                      StartIcon="@Icons.Material.Filled.Save"
                                      OnClick="@SaveBackupConfigAsync"
                                      Disabled="@_isSavingConfig">
                                @if (_isSavingConfig)
                                {
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                    <span>Saving...</span>
                                }
                                else
                                {
                                    <span>Save Configuration</span>
                                }
                            </MudButton>
                        </MudStack>
                    }
                </MudStack>
            </MudPaper>
        </MudItem>
    </MudGrid>
}

@code {
    private bool _encryptionConfigured;
    private bool _isExporting;
    private long _lastBackupSize;
    private string? _lastBackupFilename;

    // Upload restore state
    private IBrowserFile? _selectedFile;
    private BackupMetadata? _uploadMetadata;
    private bool _uploadIsEncrypted;
    private bool _confirmWipe;
    private bool _isRestoring;
    private byte[]? _backupBytes;

    // Backup browser reference
    private BackupBrowser? _backupBrowser;

    // Backup configuration state
    private BackgroundJobConfig? _backupConfig;
    private bool _isSavingConfig;
    private int _editRetainHourlyBackups = 24;
    private int _editRetainDailyBackups = 7;
    private int _editRetainWeeklyBackups = 4;
    private int _editRetainMonthlyBackups = 12;
    private int _editRetainYearlyBackups = 3;
    private string? _editBackupDirectory;
    private string _currentBackupDirectory = "/data/backups"; // Dynamic from config

    protected override async Task OnInitializedAsync()
    {
        await LoadBackupConfigAsync();
        await CheckEncryptionConfigAsync();
    }

    private async Task LoadBackupConfigAsync()
    {
        try
        {
            // Ensure default configs exist
            await JobConfigService.EnsureDefaultConfigsAsync();

            _backupConfig = await JobConfigService.GetJobConfigAsync(BackgroundJobNames.ScheduledBackup);

            if (_backupConfig != null)
            {
                // Load backup-specific settings from typed property
                var settings = _backupConfig.ScheduledBackup ?? new ScheduledBackupSettings();
                _editRetainHourlyBackups = settings.RetainHourlyBackups;
                _editRetainDailyBackups = settings.RetainDailyBackups;
                _editRetainWeeklyBackups = settings.RetainWeeklyBackups;
                _editRetainMonthlyBackups = settings.RetainMonthlyBackups;
                _editRetainYearlyBackups = settings.RetainYearlyBackups;
                _editBackupDirectory = settings.BackupDirectory;
                _currentBackupDirectory = settings.BackupDirectory ?? "/data/backups";
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load backup configuration: {ex.Message}", Severity.Error);
        }
    }

    private async Task SaveBackupConfigAsync()
    {
        if (_backupConfig == null)
            return;

        _isSavingConfig = true;
        StateHasChanged();

        try
        {
            // Update backup-specific settings using typed property
            _backupConfig.ScheduledBackup = new ScheduledBackupSettings
            {
                RetainHourlyBackups = _editRetainHourlyBackups,
                RetainDailyBackups = _editRetainDailyBackups,
                RetainWeeklyBackups = _editRetainWeeklyBackups,
                RetainMonthlyBackups = _editRetainMonthlyBackups,
                RetainYearlyBackups = _editRetainYearlyBackups,
                BackupDirectory = !string.IsNullOrWhiteSpace(_editBackupDirectory)
                    ? _editBackupDirectory
                    : "/data/backups"
            };

            _currentBackupDirectory = _backupConfig.ScheduledBackup.BackupDirectory ?? "/data/backups";

            await JobConfigService.UpdateJobConfigAsync(BackgroundJobNames.ScheduledBackup, _backupConfig);

            Snackbar.Add("Backup configuration saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save configuration: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSavingConfig = false;
            StateHasChanged();
        }
    }

    private async Task CheckEncryptionConfigAsync()
    {
        try
        {
            await using var context = await ContextFactory.CreateDbContextAsync();
            var config = await context.Configs
                .AsNoTracking()
                .Where(c => c.ChatId == 0)
                .FirstOrDefaultAsync();

            if (!string.IsNullOrEmpty(config?.BackupEncryptionConfig))
            {
                var encryptionConfig = JsonSerializer.Deserialize<BackupEncryptionConfig>(config.BackupEncryptionConfig);
                // Check both config enabled and passphrase exists in database column
                _encryptionConfigured = encryptionConfig?.Enabled == true && !string.IsNullOrEmpty(config.PassphraseEncrypted);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to check encryption config: {ex.Message}", Severity.Error);
        }

        StateHasChanged();
    }

    private async Task OpenEncryptionSetupDialog()
    {
        var dialog = await DialogService.ShowAsync<BackupEncryptionSetupDialog>("Enable Backup Encryption");
        var result = await dialog.Result;

        if (result is { Canceled: false })
        {
            _encryptionConfigured = true;
            Snackbar.Add("Backup encryption enabled! You can now create backups.", Severity.Success);
            StateHasChanged();
        }
    }

    private async Task OpenRotatePassphraseDialog()
    {
        var parameters = new DialogParameters
        {
            ["BackupDirectory"] = _currentBackupDirectory
        };

        var dialog = await DialogService.ShowAsync<BackupPassphraseRotationDialog>("Rotate Backup Passphrase", parameters);
        var result = await dialog.Result;

        if (result is { Canceled: false })
        {
            Snackbar.Add("Passphrase rotation in progress! Check logs for status.", Severity.Info);
        }
    }

    private async Task CreateManualBackup()
    {
        _isExporting = true;
        _lastBackupSize = 0;
        _lastBackupFilename = null;
        StateHasChanged();

        try
        {
            // Build retention config
            var retentionConfig = new RetentionConfig
            {
                RetainHourlyBackups = _editRetainHourlyBackups,
                RetainDailyBackups = _editRetainDailyBackups,
                RetainWeeklyBackups = _editRetainWeeklyBackups,
                RetainMonthlyBackups = _editRetainMonthlyBackups,
                RetainYearlyBackups = _editRetainYearlyBackups
            };

            // Create backup with retention (shared logic with ScheduledBackupJob)
            var result = await BackupService.CreateBackupWithRetentionAsync(_currentBackupDirectory, retentionConfig, CancellationToken.None);

            _lastBackupSize = result.SizeBytes;
            _lastBackupFilename = result.Filename;

            var message = $"Backup created: {result.Filename} ({FormatBytes(result.SizeBytes)})";
            if (result.DeletedCount > 0)
            {
                message += $" â€¢ Cleaned up {result.DeletedCount} old backup{(result.DeletedCount > 1 ? "s" : "")}";
            }
            Snackbar.Add(message, Severity.Success);

            // Refresh backup browser to show new file
            if (_backupBrowser != null)
            {
                await _backupBrowser.LoadBackupsAsync();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Backup failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isExporting = false;
            StateHasChanged();
        }
    }

    private async Task OnFileSelected(IBrowserFile? file)
    {
        _selectedFile = file;
        _uploadMetadata = null;
        _uploadIsEncrypted = false;
        _confirmWipe = false;
        StateHasChanged();

        if (file == null)
        {
            return;
        }

        try
        {
            await using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024 * 500); // 500MB max
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            _backupBytes = ms.ToArray();

            // Check if encrypted
            _uploadIsEncrypted = await BackupService.IsEncryptedAsync(_backupBytes);

            // Try to get metadata (only works for unencrypted backups without passphrase)
            if (!_uploadIsEncrypted)
            {
                _uploadMetadata = await BackupService.GetMetadataAsync(_backupBytes);
            }
            else
            {
                // For encrypted backups, we'll prompt for passphrase during restore
                Snackbar.Add("Backup is encrypted. You'll be prompted for the passphrase during restore.", Severity.Info);
            }

            Snackbar.Add("Backup file loaded successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to read backup file: {ex.Message}", Severity.Error);
            _selectedFile = null;
            _backupBytes = null;
        }

        StateHasChanged();
    }

    private async Task RestoreFromUpload()
    {
        if (_backupBytes == null || !_confirmWipe)
            return;

        try
        {
            // Check if backup is encrypted - if so, ALWAYS prompt for passphrase (don't assume DB passphrase matches)
            var isEncrypted = await BackupService.IsEncryptedAsync(_backupBytes);

            if (isEncrypted)
            {
                // Prompt for passphrase
                var dialog = await DialogService.ShowAsync<PassphrasePromptDialog>("Enter Backup Passphrase");
                var dialogResult = await dialog.Result;

            if (dialogResult is null || dialogResult.Canceled || dialogResult.Data == null)
            {
                Snackbar.Add("Restore canceled", Severity.Info);
                return;
            }

            var passphrase = dialogResult.Data as string;
            if (string.IsNullOrWhiteSpace(passphrase))
            {
                Snackbar.Add("Passphrase is required for encrypted backups", Severity.Warning);
                return;
            }

                await PerformRestoreAsync(_backupBytes, passphrase);
            }
            else
            {
                await PerformRestoreAsync(_backupBytes, null);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Restore failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task RestoreFromBrowser(BackupFileInfo backup)
    {
        // Confirm wipe
        bool? confirmResult = await DialogService.ShowMessageBox(
            "Confirm Restore",
            $"Are you sure you want to restore from {backup.FileName}? This will PERMANENTLY DELETE all current data.",
            yesText: "WIPE & RESTORE", cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });

        if (confirmResult != true)
            return;

        try
        {
            var bytes = await File.ReadAllBytesAsync(backup.FilePath);

            // Check if backup is encrypted - if so, ALWAYS prompt for passphrase (don't assume DB passphrase matches)
            var isEncrypted = await BackupService.IsEncryptedAsync(bytes);

            if (isEncrypted)
            {
                // Prompt for passphrase
                var dialog = await DialogService.ShowAsync<PassphrasePromptDialog>("Enter Backup Passphrase");
                var dialogResult = await dialog.Result;

                if (dialogResult is null || dialogResult.Canceled || dialogResult.Data == null)
                {
                    Snackbar.Add("Restore canceled", Severity.Info);
                    return;
                }

                var passphrase = dialogResult.Data as string;
                if (string.IsNullOrWhiteSpace(passphrase))
                {
                    Snackbar.Add("Passphrase is required for encrypted backups", Severity.Warning);
                    return;
                }

                await PerformRestoreAsync(bytes, passphrase);
            }
            else
            {
                await PerformRestoreAsync(bytes, null);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load backup file: {ex.Message}", Severity.Error);
        }
    }

    private async Task PerformRestoreAsync(byte[] backupBytes, string? passphrase)
    {
        _isRestoring = true;
        StateHasChanged();

        try
        {
            // Use explicit passphrase if provided, otherwise auto-detect and use DB passphrase
            if (passphrase != null)
            {
                await BackupService.RestoreAsync(backupBytes, passphrase);
            }
            else
            {
                await BackupService.RestoreAsync(backupBytes);
            }

            Snackbar.Add("System restored successfully! You will be logged out.", Severity.Success);

            await Task.Delay(2000);
            Navigation.NavigateTo("/login", forceLoad: true);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Restore failed: {ex.Message}", Severity.Error);
            _isRestoring = false;
            StateHasChanged();
        }
    }

    private static string FormatBytes(long bytes)
    {
        string[] sizes = ["B", "KB", "MB", "GB"];
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }
}
