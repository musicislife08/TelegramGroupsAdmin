@using TelegramGroupsAdmin.Configuration.Models
@using TelegramGroupsAdmin.Core.Extensions
@using TelegramGroupsAdmin.Core.Models
@using Microsoft.Extensions.Logging
@inject IRuntimeLoggingService RuntimeLoggingService
@inject IAuditService AuditService
@inject ISnackbar Snackbar

<MudStack Spacing="4">
    <!-- Dynamic Log Level Configuration -->
    <MudPaper Class="pa-4">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-4">
            <div>
                <MudText Typo="Typo.h6" GutterBottom="true">Dynamic Log Level Configuration</MudText>
                <MudText Typo="Typo.body2">
                    Adjust log levels in database. Changes save automatically and take effect on next restart.
                </MudText>
            </div>
            <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                @if (_isSaving)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    <MudText Typo="Typo.caption" Color="Color.Secondary">Saving...</MudText>
                }
                <MudButton Color="Color.Secondary" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.Refresh" OnClick="@ResetToDefaults" Disabled="_loading">
                    Reset to Defaults
                </MudButton>
            </MudStack>
        </MudStack>

        @if (_loading)
        {
            <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
        }
        else if (_config != null)
        {
            <MudStack Spacing="3">
                <!-- Default Log Level -->
                <MudSelect T="LogLevel"
                          Value="_config.DefaultLevel"
                          ValueChanged="OnDefaultLevelChanged"
                          Label="Default Log Level"
                          Variant="Variant.Outlined"
                          HelperText="Applied to all namespaces unless overridden"
                          Dense="true">
                    @foreach (var level in RuntimeLoggingService.GetAvailableLogLevels())
                    {
                        <MudSelectItem Value="@level">
                            <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                <MudIcon Icon="@GetLogLevelIcon(level)" Size="Size.Small" Color="@GetLogLevelColor(level)" />
                                <MudText>@level</MudText>
                            </MudStack>
                        </MudSelectItem>
                    }
                </MudSelect>

                <MudDivider Class="my-2" />

                <!-- Namespace Overrides -->
                <MudText Typo="Typo.subtitle2">Namespace-Specific Overrides:</MudText>

                @foreach (var kvp in _config.Overrides.OrderBy(x => x.Key))
                {
                    var ns = kvp.Key;
                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                        <MudText Style="flex: 1;">@ns</MudText>
                        <MudSelect T="LogLevel"
                                  Value="_config.Overrides[ns]"
                                  ValueChanged="@((LogLevel value) => OnOverrideLevelChanged(ns, value))"
                                  Label="Log Level"
                                  Variant="Variant.Outlined"
                                  Dense="true"
                                  Style="min-width: 200px;">
                            @foreach (var availableLevel in RuntimeLoggingService.GetAvailableLogLevels())
                            {
                                <MudSelectItem Value="@availableLevel">
                                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                        <MudIcon Icon="@GetLogLevelIcon(availableLevel)" Size="Size.Small" Color="@GetLogLevelColor(availableLevel)" />
                                        <MudText>@availableLevel</MudText>
                                    </MudStack>
                                </MudSelectItem>
                            }
                        </MudSelect>
                        <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                      Size="Size.Small"
                                      Color="Color.Error"
                                      OnClick="@(() => RemoveOverride(ns))" />
                    </MudStack>
                }

                <!-- Add New Override -->
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center" Class="mt-3">
                    <MudAutocomplete T="string"
                                    @bind-Value="_newNamespace"
                                    Label="Add Namespace Override"
                                    Variant="Variant.Outlined"
                                    Dense="true"
                                    SearchFunc="SearchNamespaces"
                                    CoerceText="false"
                                    CoerceValue="false"
                                    Placeholder="e.g., TelegramGroupsAdmin.Telegram"
                                    Style="flex: 1;" />
                    <MudSelect @bind-Value="_newLogLevel"
                              Label="Log Level"
                              Variant="Variant.Outlined"
                              Dense="true"
                              Style="min-width: 200px;">
                        @foreach (var level in RuntimeLoggingService.GetAvailableLogLevels())
                        {
                            <MudSelectItem Value="@level">
                                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                    <MudIcon Icon="@GetLogLevelIcon(level)" Size="Size.Small" Color="@GetLogLevelColor(level)" />
                                    <MudText>@level</MudText>
                                </MudStack>
                            </MudSelectItem>
                        }
                    </MudSelect>
                    <MudButton Variant="Variant.Filled"
                              Color="Color.Primary"
                              StartIcon="@Icons.Material.Filled.Add"
                              OnClick="@AddOverride"
                              Disabled="string.IsNullOrWhiteSpace(_newNamespace)">
                        Add
                    </MudButton>
                </MudStack>

                @if (_config.LastModified != default)
                {
                    <MudAlert Severity="Severity.Info" Dense="true" Class="mt-3">
                        Last modified: @_config.LastModified.LocalDateTime.ToString("yyyy-MM-dd HH:mm:ss")
                    </MudAlert>
                }

                <MudAlert Severity="Severity.Warning" Dense="true" Class="mt-3">
                    <strong>Note:</strong> Log level changes are saved to the database but require an application restart to take effect.
                    This is a current limitation of the .NET logging system.
                </MudAlert>
            </MudStack>
        }
    </MudPaper>

    <!-- Log Output Configuration -->
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h6" GutterBottom="true">Log Output Configuration</MudText>
        <MudText Typo="Typo.body2" Class="mb-4">
            Configure where logs are written
        </MudText>

        <MudAlert Severity="Severity.Success" Dense="true">
            <strong>Current Log Output:</strong>
            <ul class="my-2" style="margin-left: 20px;">
                <li>Console output (stdout) - captured by Docker logs</li>
                <li>Structured JSON logging via ASP.NET Core</li>
                <li>Compatible with log aggregation tools (Loki, ELK, Seq)</li>
            </ul>
        </MudAlert>

        <MudText Typo="Typo.subtitle2" Class="mt-3">Future Enhancements (Phase 5+):</MudText>
        <ul style="margin-left: 20px;">
            <li>File-based logging with rotation</li>
            <li>Syslog integration</li>
            <li>Direct integration with Loki/Grafana</li>
            <li>Real-time log viewer in web UI</li>
        </ul>
    </MudPaper>

    <!-- Debugging & Troubleshooting -->
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h6" GutterBottom="true">Debugging & Troubleshooting</MudText>
        <MudText Typo="Typo.body2" Class="mb-4">
            Tools for troubleshooting issues
        </MudText>

        <MudAlert Severity="Severity.Info" Dense="true">
            <strong>Current Troubleshooting Tools:</strong>
            <ul class="my-2" style="margin-left: 20px;">
                <li><strong>/health</strong> - API endpoint for system status and bot stats</li>
                <li><strong>Docker logs</strong> - View application logs via <code>docker logs telegram-admin</code></li>
                <li><strong>Audit log page</strong> - Track user actions and authentication events</li>
                <li><strong>Message history</strong> - Review detection history and spam analysis</li>
            </ul>
        </MudAlert>

        <MudText Typo="Typo.subtitle2" Class="mt-3">Useful Log Commands:</MudText>
        <MudPaper Elevation="0" Class="pa-3 mt-2" Style="background-color: #f5f5f5;">
            <code># View all logs</code><br />
            <code>docker logs telegram-admin</code><br /><br />
            <code># Follow logs in real-time</code><br />
            <code>docker logs -f telegram-admin</code><br /><br />
            <code># View last 100 lines</code><br />
            <code>docker logs --tail 100 telegram-admin</code><br /><br />
            <code># Search for errors</code><br />
            <code>docker logs telegram-admin 2>&1 | grep -i error</code>
        </MudPaper>
    </MudPaper>
</MudStack>

@code {
    [CascadingParameter] private WebUserIdentity? WebUser { get; set; }

    private LogConfig? _config;
    private bool _loading = true;
    private bool _isSaving;
    private string _newNamespace = string.Empty;
    private LogLevel _newLogLevel = LogLevel.Information;

    protected override async Task OnInitializedAsync()
    {
        if (WebUser is null) return;

        await LoadConfiguration();
    }

    private async Task LoadConfiguration()
    {
        _loading = true;
        try
        {
            _config = await RuntimeLoggingService.GetCurrentConfigAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading log configuration: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task SaveConfiguration()
    {
        if (_config == null) return;

        _isSaving = true;
        try
        {
            await RuntimeLoggingService.UpdateConfigAsync(_config);

            // Create audit log entry
            var actor = WebUser!.ToActor();
            await AuditService.LogEventAsync(
                AuditEventType.ConfigurationChanged,
                actor,
                actor,
                $"logging:default={_config.DefaultLevel}:overrides={_config.Overrides.Count}");

            Snackbar.Add("Settings saved", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
        }
    }

    private async Task ResetToDefaults()
    {
        try
        {
            await RuntimeLoggingService.ResetToDefaultsAsync();
            await LoadConfiguration();
            Snackbar.Add("Log configuration reset to defaults. Restart application to apply changes.", Severity.Info);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error resetting log configuration: {ex.Message}", Severity.Error);
        }
    }

    private async Task AddOverride()
    {
        if (_config == null || string.IsNullOrWhiteSpace(_newNamespace)) return;

        if (!_config.Overrides.TryAdd(_newNamespace, _newLogLevel))
        {
            Snackbar.Add($"Override for '{_newNamespace}' already exists", Severity.Warning);
            return;
        }

        _newNamespace = string.Empty;
        _newLogLevel = LogLevel.Information;
        await SaveConfiguration();
    }

    private async Task RemoveOverride(string ns)
    {
        if (_config == null) return;

        _config.Overrides.Remove(ns);
        await SaveConfiguration();
    }

    private async Task OnDefaultLevelChanged(LogLevel value)
    {
        if (_config == null) return;
        _config.DefaultLevel = value;
        await SaveConfiguration();
    }

    private async Task OnOverrideLevelChanged(string ns, LogLevel value)
    {
        if (_config == null) return;
        _config.Overrides[ns] = value;
        await SaveConfiguration();
    }

    private Task<IEnumerable<string>> SearchNamespaces(string? value, CancellationToken cancellationToken)
    {
        var commonNamespaces = RuntimeLoggingService.GetCommonNamespaces();

        if (string.IsNullOrWhiteSpace(value))
        {
            return Task.FromResult<IEnumerable<string>>(commonNamespaces);
        }

        var filtered = commonNamespaces
            .Where(ns => ns.Contains(value, StringComparison.OrdinalIgnoreCase))
            .ToList();

        return Task.FromResult<IEnumerable<string>>(filtered);
    }

    private static string GetLogLevelIcon(LogLevel level) => level switch
    {
        LogLevel.Trace => Icons.Material.Filled.BugReport,
        LogLevel.Debug => Icons.Material.Filled.Code,
        LogLevel.Information => Icons.Material.Filled.Info,
        LogLevel.Warning => Icons.Material.Filled.Warning,
        LogLevel.Error => Icons.Material.Filled.Error,
        LogLevel.Critical => Icons.Material.Filled.Report,
        _ => Icons.Material.Filled.Circle
    };

    private static Color GetLogLevelColor(LogLevel level) => level switch
    {
        LogLevel.Trace => Color.Secondary,
        LogLevel.Debug => Color.Info,
        LogLevel.Information => Color.Primary,
        LogLevel.Warning => Color.Warning,
        LogLevel.Error => Color.Error,
        LogLevel.Critical => Color.Error,
        _ => Color.Default
    };
}
