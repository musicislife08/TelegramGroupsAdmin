@using TelegramGroupsAdmin.BackgroundJobs.Services
@using TelegramGroupsAdmin.Telegram.Services.Media
@using TelegramGroupsAdmin.Core.BackgroundJobs
@using TelegramGroupsAdmin.Core.Services
@using TelegramGroupsAdmin.Core.Utilities
@using TelegramGroupsAdmin.Core.JobPayloads
@using TelegramGroupsAdmin.Core.Models.BackgroundJobSettings
@using Microsoft.JSInterop
@using HumanCron.Quartz.Abstractions
@inject IBackgroundJobConfigService JobConfigService
@inject IMediaRefetchQueueService QueueService
@inject IJobTriggerService JobTriggerService
@inject IQuartzScheduleConverter ScheduleConverter
@inject ISnackbar Snackbar
@inject ILogger<BackgroundJobs> Logger
@inject NavigationManager Navigation
@inject IJSRuntime JsRuntime
@implements IDisposable

<MudStack Spacing="4">
    <!-- Media Refetch Queue Status -->
    <MudAlert Severity="Severity.Info" Variant="Variant.Outlined">
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
            <MudIcon Icon="@Icons.Material.Filled.CloudDownload" />
            <MudText>
                <strong>Media Refetch Queue:</strong> @_queueDepth @(_queueDepth == 1 ? "file" : "files") queued for download
            </MudText>
        </MudStack>
    </MudAlert>

    <!-- Background Jobs Table -->
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h6" GutterBottom="true">
            <MudIcon Icon="@Icons.Material.Filled.Schedule" Class="mr-2" />
            Background Jobs
        </MudText>
        <MudText Typo="Typo.body2" Class="mb-4" Color="Color.Secondary">
            Configure and monitor scheduled background tasks
        </MudText>

        @if (_jobs == null)
        {
            <MudProgressLinear Indeterminate="true" />
        }
        else
        {
            <MudTable Items="@_jobs.Values.OrderBy(j => j.DisplayName)" Elevation="0" Dense="true">
                <HeaderContent>
                    <MudTh>Job</MudTh>
                    <MudTh>Status</MudTh>
                    <MudTh>Schedule</MudTh>
                    <MudTh>Last Run</MudTh>
                    <MudTh>Next Run</MudTh>
                    <MudTh Style="text-align: right">Actions</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Job">
                        <MudStack Spacing="1">
                            <MudText Typo="Typo.body2"><strong>@context.DisplayName</strong></MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">@context.Description</MudText>
                        </MudStack>
                    </MudTd>
                    <MudTd DataLabel="Status">
                        <MudChip T="string" Size="Size.Small" Color="@(context.Enabled ? Color.Success : Color.Default)">
                            @(context.Enabled ? "Enabled" : "Disabled")
                        </MudChip>
                    </MudTd>
                    <MudTd DataLabel="Schedule">
                        <MudText Typo="Typo.caption">@(context.Schedule ?? "Not configured")</MudText>
                    </MudTd>
                    <MudTd DataLabel="Last Run">
                        @if (context.LastRunAt.HasValue)
                        {
                            <MudText Typo="Typo.caption">@context.LastRunAt.Value.ToLocalTime().ToString("MMM d, h:mm tt")</MudText>
                        }
                        else
                        {
                            <MudText Typo="Typo.caption" Color="Color.Secondary">Never</MudText>
                        }
                    </MudTd>
                    <MudTd DataLabel="Next Run">
                        @if (context.NextRunAt.HasValue && context.Enabled)
                        {
                            <MudText Typo="Typo.caption">@context.NextRunAt.Value.ToLocalTime().ToString("MMM d, h:mm tt")</MudText>
                        }
                        else
                        {
                            <MudText Typo="Typo.caption" Color="Color.Secondary">—</MudText>
                        }
                    </MudTd>
                    <MudTd DataLabel="Actions" Style="text-align: right">
                        <MudStack Row="true" Justify="Justify.FlexEnd" Spacing="1">
                            <MudSwitch T="bool"
                                      Value="@context.Enabled"
                                      ValueChanged="@(async (bool enabled) => await ToggleJobAsync(context.JobName, enabled))"
                                      Color="Color.Success"
                                      Size="Size.Small" />
                            <MudIconButton Icon="@Icons.Material.Filled.Settings"
                                          Size="Size.Small"
                                          OnClick="@(() => OpenConfigDialog(context))"
                                          title="Configure" />
                            <MudIconButton Icon="@Icons.Material.Filled.PlayArrow"
                                          Size="Size.Small"
                                          Color="Color.Primary"
                                          Disabled="@(!context.Enabled || context.JobName == BackgroundJobNames.MessageCleanup)"
                                          OnClick="@(() => RunNowAsync(context.JobName))"
                                          title="@(context.JobName == BackgroundJobNames.MessageCleanup ? "Background Service (always running)" : "Run Now")" />
                        </MudStack>
                    </MudTd>
                </RowTemplate>
            </MudTable>

            @if (_jobs.Values.Any(j => !string.IsNullOrEmpty(j.LastError)))
            {
                <MudAlert Severity="Severity.Warning" Class="mt-4" Dense="true">
                    <MudText Typo="Typo.body2">One or more jobs have errors. Check the logging page for details.</MudText>
                </MudAlert>
            }
        }
    </MudPaper>
</MudStack>

<!-- Configuration Dialog -->
<MudDialog @bind-Visible="_showConfigDialog" Options="_dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">Configure @_editingJob?.DisplayName</MudText>
    </TitleContent>
    <DialogContent>
        @if (_editingJob != null)
        {
            <MudStack Spacing="3">
                <MudText Typo="Typo.body2" Color="Color.Secondary">@_editingJob.Description</MudText>

                <!-- Schedule Configuration -->
                <MudTextField @bind-Value="_editScheduleInterval"
                             Label="Schedule"
                             Variant="Variant.Outlined"
                             HelperText="Examples: every 30 minutes, every 6 hours, every day at 2pm, every week on sunday, every 2 weeks on monday at 9am"
                             Immediate="true"
                             Error="@(!string.IsNullOrEmpty(_scheduleValidationError))"
                             ErrorText="@_scheduleValidationError"
                             OnBlur="ValidateSchedule" />

                <!-- Job-Specific Settings -->
                @if (_editingJob.JobName == BackgroundJobNames.ScheduledBackup)
                {
                    <MudDivider />
                    <MudAlert Severity="Severity.Info" Dense="true">
                        <strong>Note:</strong> Backup retention and directory settings are configured in <strong>Settings → System → Backup Configuration</strong>
                    </MudAlert>
                }
                else if (_editingJob.JobName == BackgroundJobNames.MessageCleanup)
                {
                    <MudDivider />
                    <MudText Typo="Typo.subtitle2">Retention Settings</MudText>
                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-2">
                        Data older than these thresholds will be deleted. Use formats: 7d, 2w, 1M, 1y
                    </MudText>

                    <MudTextField @bind-Value="_editMessageRetention"
                                 Label="Message History"
                                 Variant="Variant.Outlined"
                                 HelperText="e.g., 30d, 6M, 1y (spam/ham samples kept permanently)"
                                 Error="@(!ValidateRetention(_editMessageRetention))"
                                 ErrorText="Invalid format. Use: 7d, 2w, 1M, 1y" />

                    <MudTextField @bind-Value="_editReportRetention"
                                 Label="Resolved Reports"
                                 Variant="Variant.Outlined"
                                 HelperText="e.g., 30d, 3M, 1y"
                                 Error="@(!ValidateRetention(_editReportRetention))"
                                 ErrorText="Invalid format" />

                    <MudTextField @bind-Value="_editContextRetention"
                                 Label="DM Button Contexts"
                                 Variant="Variant.Outlined"
                                 HelperText="e.g., 7d, 2w (expired callback buttons)"
                                 Error="@(!ValidateRetention(_editContextRetention))"
                                 ErrorText="Invalid format" />

                    <MudTextField @bind-Value="_editNotificationRetention"
                                 Label="Read Web Notifications"
                                 Variant="Variant.Outlined"
                                 HelperText="e.g., 7d, 2w"
                                 Error="@(!ValidateRetention(_editNotificationRetention))"
                                 ErrorText="Invalid format" />
                }
                else if (_editingJob.JobName == BackgroundJobNames.DatabaseMaintenance)
                {
                    <MudDivider />
                    <MudText Typo="Typo.subtitle2">Maintenance Settings</MudText>

                    <MudCheckBox @bind-Value="_editRunVacuum" Color="Color.Primary" Dense="true">
                        Run VACUUM (reclaim storage from deleted rows)
                    </MudCheckBox>

                    <MudCheckBox @bind-Value="_editRunAnalyze" Color="Color.Primary" Dense="true">
                        Run ANALYZE (update query planner statistics)
                    </MudCheckBox>
                }
            </MudStack>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="@CloseConfigDialog">Cancel</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="@SaveConfigAsync">Save</MudButton>
    </DialogActions>
</MudDialog>

@code {
    private Dictionary<string, BackgroundJobConfig>? _jobs;
    private int _queueDepth;
    private Timer? _refreshTimer;

    // Dialog state
    private bool _showConfigDialog;
    private BackgroundJobConfig? _editingJob;

    // Schedule editing state
    private string _editScheduleInterval = "1d"; // Default: daily
    private string? _scheduleValidationError;

    // Database maintenance settings
    private bool _editRunVacuum = true;
    private bool _editRunAnalyze = true;

    // Data Cleanup retention settings (duration strings)
    private string _editMessageRetention = "30d";
    private string _editReportRetention = "30d";
    private string _editContextRetention = "7d";
    private string _editNotificationRetention = "7d";

    private readonly DialogOptions _dialogOptions = new()
    {
        MaxWidth = MaxWidth.Small,
        FullWidth = true
    };

    protected override async Task OnInitializedAsync()
    {
        // Ensure default job configs exist before loading
        await JobConfigService.EnsureDefaultConfigsAsync();

        await LoadJobsAsync();
        UpdateQueueDepth();

        // Subscribe to NextRunAt updates for automatic UI refresh via SignalR
        JobConfigService.JobNextRunAtUpdated += OnJobNextRunAtUpdated;

        // Refresh queue depth every 5 seconds
        _refreshTimer = new Timer(_ =>
        {
            UpdateQueueDepth();
            InvokeAsync(StateHasChanged);
        }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
    }

    private void OnJobNextRunAtUpdated(string jobName)
    {
        // Reload the specific job and refresh UI (runs on SignalR thread, marshal to UI thread)
        InvokeAsync(async () =>
        {
            var updatedJob = await JobConfigService.GetJobConfigAsync(jobName);
            if (updatedJob != null && _jobs != null)
            {
                _jobs[jobName] = updatedJob;
                StateHasChanged();
            }
        });
    }

    private async Task LoadJobsAsync()
    {
        _jobs = await JobConfigService.GetAllJobsAsync();
    }

    private void UpdateQueueDepth()
    {
        _queueDepth = QueueService.GetQueueDepth();
    }

    private async Task ToggleJobAsync(string jobName, bool enabled)
    {
        if (_jobs == null || !_jobs.TryGetValue(jobName, out var job))
            return;

        job.Enabled = enabled;
        await JobConfigService.UpdateJobConfigAsync(jobName, job);

        Snackbar.Add($"{job.DisplayName} {(enabled ? "enabled" : "disabled")}",
            enabled ? Severity.Success : Severity.Info);
    }

    private async Task RunNowAsync(string jobName)
    {
        if (_jobs == null || !_jobs.TryGetValue(jobName, out var job))
            return;

        try
        {
            // Build payload based on job type using typed settings
            object payload = jobName switch
            {
                BackgroundJobNames.ScheduledBackup => BuildBackupPayload(job),
                BackgroundJobNames.DatabaseMaintenance => BuildMaintenancePayload(job),
                BackgroundJobNames.UserPhotoRefresh => BuildUserPhotoRefreshPayload(job),
                BackgroundJobNames.BlocklistSync => BuildBlocklistSyncPayload(),
                _ => new { } // Empty object for jobs without payloads
            };

            // Trigger job immediately via Quartz.NET
            var triggerId = await JobTriggerService.TriggerNowAsync(jobName, payload);
            Snackbar.Add($"{job.DisplayName} queued for execution", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to trigger job: {ex.Message}", Severity.Error);
            Logger.LogError(ex, "Failed to trigger job {JobName}", jobName);
        }
    }

    private void OpenConfigDialog(BackgroundJobConfig job)
    {
        _editingJob = job;
        _editScheduleInterval = job.Schedule ?? "1d"; // Default to daily if not set

        // Load job-specific settings from typed properties
        if (job.JobName == BackgroundJobNames.DatabaseMaintenance)
        {
            var settings = job.DatabaseMaintenance ?? new DatabaseMaintenanceSettings();
            _editRunVacuum = settings.RunVacuum;
            _editRunAnalyze = settings.RunAnalyze;
        }
        else if (job.JobName == BackgroundJobNames.MessageCleanup)
        {
            var settings = job.DataCleanup ?? new DataCleanupSettings();
            _editMessageRetention = settings.MessageRetention;
            _editReportRetention = settings.ReportRetention;
            _editContextRetention = settings.CallbackContextRetention;
            _editNotificationRetention = settings.WebNotificationRetention;
        }

        _showConfigDialog = true;
    }

    private static bool ValidateRetention(string value)
        => !string.IsNullOrWhiteSpace(value) && TimeSpanUtilities.TryParseDuration(value, out _);

    private void CloseConfigDialog()
    {
        _showConfigDialog = false;
        _editingJob = null;
    }

    private async Task SaveConfigAsync()
    {
        if (_editingJob == null || _jobs == null)
            return;

        try
        {
            // Validate schedule using NaturalCron converter
            var parseResult = ScheduleConverter.ToQuartzSchedule(_editScheduleInterval);

            if (parseResult is HumanCron.Models.ParseResult<Quartz.IScheduleBuilder>.Error error)
            {
                Snackbar.Add($"Invalid schedule: {error.Message}", Severity.Error);
                return;
            }

            // Store natural language schedule directly
            _editingJob.Schedule = _editScheduleInterval;

            // Update job-specific settings using typed properties
            if (_editingJob.JobName == BackgroundJobNames.DatabaseMaintenance)
            {
                _editingJob.DatabaseMaintenance = new DatabaseMaintenanceSettings
                {
                    RunVacuum = _editRunVacuum,
                    RunAnalyze = _editRunAnalyze
                };
            }
            else if (_editingJob.JobName == BackgroundJobNames.MessageCleanup)
            {
                // Validate all retention values before saving
                if (!ValidateRetention(_editMessageRetention) ||
                    !ValidateRetention(_editReportRetention) ||
                    !ValidateRetention(_editContextRetention) ||
                    !ValidateRetention(_editNotificationRetention))
                {
                    Snackbar.Add("Invalid retention format. Use formats like: 7d, 2w, 1M, 1y", Severity.Error);
                    return;
                }

                _editingJob.DataCleanup = new DataCleanupSettings
                {
                    MessageRetention = _editMessageRetention,
                    ReportRetention = _editReportRetention,
                    CallbackContextRetention = _editContextRetention,
                    WebNotificationRetention = _editNotificationRetention
                };
            }

            var jobName = _editingJob.JobName;
            await JobConfigService.UpdateJobConfigAsync(jobName, _editingJob);

            // NextRunAt will be populated by QuartzSchedulingSyncService asynchronously
            // and will be visible on next page refresh or when the job list reloads
            await LoadJobsAsync();

            Snackbar.Add($"{_editingJob.DisplayName} configuration saved", Severity.Success);
            CloseConfigDialog();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save configuration: {ex.Message}", Severity.Error);
        }
    }

    private static ScheduledBackupPayload BuildBackupPayload(BackgroundJobConfig job)
    {
        var settings = job.ScheduledBackup ?? new ScheduledBackupSettings();

        return new ScheduledBackupPayload
        {
            RetainHourlyBackups = settings.RetainHourlyBackups,
            RetainDailyBackups = settings.RetainDailyBackups,
            RetainWeeklyBackups = settings.RetainWeeklyBackups,
            RetainMonthlyBackups = settings.RetainMonthlyBackups,
            RetainYearlyBackups = settings.RetainYearlyBackups,
            BackupDirectory = settings.BackupDirectory
        };
    }

    private static DatabaseMaintenancePayload BuildMaintenancePayload(BackgroundJobConfig job)
    {
        var settings = job.DatabaseMaintenance ?? new DatabaseMaintenanceSettings();

        return new DatabaseMaintenancePayload
        {
            RunVacuum = settings.RunVacuum,
            RunAnalyze = settings.RunAnalyze,
            RunVacuumFull = false
        };
    }

    private static RefreshUserPhotosPayload BuildUserPhotoRefreshPayload(BackgroundJobConfig job)
    {
        var settings = job.UserPhotoRefresh ?? new UserPhotoRefreshSettings();

        return new RefreshUserPhotosPayload
        {
            DaysBack = settings.DaysBack
        };
    }

    private static BlocklistSyncJobPayload BuildBlocklistSyncPayload()
    {
        return new BlocklistSyncJobPayload(
            SubscriptionId: null, // Sync all
            ChatId: 0, // Global
            ForceRebuild: false
        );
    }

    /// <summary>
    /// Validate natural language schedule
    /// </summary>
    private void ValidateSchedule()
    {
        if (string.IsNullOrWhiteSpace(_editScheduleInterval))
        {
            _scheduleValidationError = null;
            return;
        }

        // Validate using converter
        var parseResult = ScheduleConverter.ToQuartzSchedule(_editScheduleInterval);

        _scheduleValidationError = parseResult is HumanCron.Models.ParseResult<Quartz.IScheduleBuilder>.Error error
            ? error.Message
            : null;
    }

    public void Dispose()
    {
        JobConfigService.JobNextRunAtUpdated -= OnJobNextRunAtUpdated;
        _refreshTimer?.Dispose();
    }
}
