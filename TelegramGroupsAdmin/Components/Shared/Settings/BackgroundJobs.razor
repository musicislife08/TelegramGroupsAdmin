@using TelegramGroupsAdmin.Services
@using TelegramGroupsAdmin.Services.Media
@using TelegramGroupsAdmin.Core.BackgroundJobs
@using TelegramGroupsAdmin.Core.Utilities
@using TelegramGroupsAdmin.Telegram.Abstractions
@using TelegramGroupsAdmin.Telegram.Abstractions.Jobs
@using System.Text.Json
@inject IBackgroundJobConfigService JobConfigService
@inject IMediaRefetchQueueService QueueService
@inject IServiceProvider ServiceProvider
@inject ISnackbar Snackbar
@inject ILogger<BackgroundJobs> Logger
@inject NavigationManager Navigation
@implements IDisposable

<MudStack Spacing="4">
    <!-- Media Refetch Queue Status -->
    <MudAlert Severity="Severity.Info" Variant="Variant.Outlined">
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
            <MudIcon Icon="@Icons.Material.Filled.CloudDownload" />
            <MudText>
                <strong>Media Refetch Queue:</strong> @_queueDepth @(_queueDepth == 1 ? "file" : "files") queued for download
            </MudText>
        </MudStack>
    </MudAlert>

    <!-- Background Jobs Table -->
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h6" GutterBottom="true">
            <MudIcon Icon="@Icons.Material.Filled.Schedule" Class="mr-2" />
            Background Jobs
        </MudText>
        <MudText Typo="Typo.body2" Class="mb-4" Color="Color.Secondary">
            Configure and monitor scheduled background tasks
        </MudText>

        @if (_jobs == null)
        {
            <MudProgressLinear Indeterminate="true" />
        }
        else
        {
            <MudTable Items="@_jobs.Values.OrderBy(j => j.DisplayName)" Elevation="0" Dense="true">
                <HeaderContent>
                    <MudTh>Job</MudTh>
                    <MudTh>Status</MudTh>
                    <MudTh>Schedule</MudTh>
                    <MudTh>Last Run</MudTh>
                    <MudTh>Next Run</MudTh>
                    <MudTh Style="text-align: right">Actions</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Job">
                        <MudStack Spacing="1">
                            <MudText Typo="Typo.body2"><strong>@context.DisplayName</strong></MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">@context.Description</MudText>
                        </MudStack>
                    </MudTd>
                    <MudTd DataLabel="Status">
                        <MudChip T="string" Size="Size.Small" Color="@(context.Enabled ? Color.Success : Color.Default)">
                            @(context.Enabled ? "Enabled" : "Disabled")
                        </MudChip>
                    </MudTd>
                    <MudTd DataLabel="Schedule">
                        <!-- TODO: Reimplement schedule display with friendly format → cron conversion -->
                        <MudText Typo="Typo.caption">@FormatCronSchedule(context.CronExpression)</MudText>
                    </MudTd>
                    <MudTd DataLabel="Last Run">
                        @if (context.LastRunAt.HasValue)
                        {
                            <MudText Typo="Typo.caption">@context.LastRunAt.Value.ToLocalTime().ToString("MMM d, h:mm tt")</MudText>
                        }
                        else
                        {
                            <MudText Typo="Typo.caption" Color="Color.Secondary">Never</MudText>
                        }
                    </MudTd>
                    <MudTd DataLabel="Next Run">
                        @if (context.NextRunAt.HasValue && context.Enabled)
                        {
                            <MudText Typo="Typo.caption">@context.NextRunAt.Value.ToLocalTime().ToString("MMM d, h:mm tt")</MudText>
                        }
                        else
                        {
                            <MudText Typo="Typo.caption" Color="Color.Secondary">—</MudText>
                        }
                    </MudTd>
                    <MudTd DataLabel="Actions" Style="text-align: right">
                        <MudStack Row="true" Justify="Justify.FlexEnd" Spacing="1">
                            <MudSwitch T="bool"
                                      Value="@context.Enabled"
                                      ValueChanged="@(async (bool enabled) => await ToggleJobAsync(context.JobName, enabled))"
                                      Color="Color.Success"
                                      Size="Size.Small" />
                            <MudIconButton Icon="@Icons.Material.Filled.Settings"
                                          Size="Size.Small"
                                          OnClick="@(() => OpenConfigDialog(context))"
                                          title="Configure" />
                            <MudIconButton Icon="@Icons.Material.Filled.PlayArrow"
                                          Size="Size.Small"
                                          Color="Color.Primary"
                                          Disabled="@(!context.Enabled || context.JobName == BackgroundJobNames.MessageCleanup)"
                                          OnClick="@(() => RunNowAsync(context.JobName))"
                                          title="@(context.JobName == BackgroundJobNames.MessageCleanup ? "Background Service (always running)" : "Run Now")" />
                        </MudStack>
                    </MudTd>
                </RowTemplate>
            </MudTable>

            @if (_jobs.Values.Any(j => !string.IsNullOrEmpty(j.LastError)))
            {
                <MudAlert Severity="Severity.Warning" Class="mt-4" Dense="true">
                    <MudText Typo="Typo.body2">One or more jobs have errors. Check the logging page for details.</MudText>
                </MudAlert>
            }
        }
    </MudPaper>
</MudStack>

<!-- Configuration Dialog -->
<MudDialog @bind-Visible="_showConfigDialog" Options="_dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">Configure @_editingJob?.DisplayName</MudText>
    </TitleContent>
    <DialogContent>
        @if (_editingJob != null)
        {
            <MudStack Spacing="3">
                <MudText Typo="Typo.body2" Color="Color.Secondary">@_editingJob.Description</MudText>

                <!-- TODO: Reimplement schedule UI with friendly format → cron conversion -->
                <MudTextField @bind-Value="_editCronExpression"
                             Label="Cron Expression"
                             Variant="Variant.Outlined"
                             ReadOnly="true"
                             HelperText="Schedule editing temporarily disabled - cron expression shown as readonly"
                             Placeholder="0 2 * * *" />

                <MudAlert Severity="Severity.Info" Dense="true">
                    Schedule editing UI will be reimplemented in a future update with a friendly format that converts to cron expressions.
                </MudAlert>

                <!-- Job-Specific Settings -->
                @if (_editingJob.JobName == BackgroundJobNames.ScheduledBackup)
                {
                    <MudDivider />
                    <MudText Typo="Typo.subtitle2">Backup Settings</MudText>

                    <MudAlert Severity="Severity.Info" Dense="true">
                        <strong>Grandfather-Father-Son Retention Strategy</strong><br/>
                        Keeps multiple backup tiers: hourly (short-term), daily, weekly, monthly, yearly (long-term)
                    </MudAlert>

                    <MudNumericField @bind-Value="_editRetainHourlyBackups"
                                   Label="Hourly Backups"
                                   Variant="Variant.Outlined"
                                   Min="0"
                                   Max="168"
                                   HelperText="Keep last N hourly backups (0-168 = 1 week)" />

                    <MudNumericField @bind-Value="_editRetainDailyBackups"
                                   Label="Daily Backups"
                                   Variant="Variant.Outlined"
                                   Min="0"
                                   Max="31"
                                   HelperText="Keep last N daily backups (0-31)" />

                    <MudNumericField @bind-Value="_editRetainWeeklyBackups"
                                   Label="Weekly Backups"
                                   Variant="Variant.Outlined"
                                   Min="0"
                                   Max="52"
                                   HelperText="Keep last N weekly backups (0-52)" />

                    <MudNumericField @bind-Value="_editRetainMonthlyBackups"
                                   Label="Monthly Backups"
                                   Variant="Variant.Outlined"
                                   Min="0"
                                   Max="60"
                                   HelperText="Keep last N monthly backups (0-60 = 5 years)" />

                    <MudNumericField @bind-Value="_editRetainYearlyBackups"
                                   Label="Yearly Backups"
                                   Variant="Variant.Outlined"
                                   Min="0"
                                   Max="20"
                                   HelperText="Keep last N yearly backups (0-20)" />

                    <MudTextField @bind-Value="_editBackupDirectory"
                                Label="Backup Directory"
                                Variant="Variant.Outlined"
                                HelperText="Leave empty for default (/data/backups)"
                                Placeholder="/data/backups" />
                }
                else if (_editingJob.JobName == BackgroundJobNames.DatabaseMaintenance)
                {
                    <MudDivider />
                    <MudText Typo="Typo.subtitle2">Maintenance Settings</MudText>

                    <MudCheckBox @bind-Value="_editRunVacuum" Color="Color.Primary" Dense="true">
                        Run VACUUM (reclaim storage from deleted rows)
                    </MudCheckBox>

                    <MudCheckBox @bind-Value="_editRunAnalyze" Color="Color.Primary" Dense="true">
                        Run ANALYZE (update query planner statistics)
                    </MudCheckBox>

                    <MudAlert Severity="Severity.Info" Dense="true">
                        <strong>Note:</strong> This job is currently a stub. Full implementation requires direct PostgreSQL connection.
                    </MudAlert>
                }
            </MudStack>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="@CloseConfigDialog">Cancel</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="@SaveConfigAsync">Save</MudButton>
    </DialogActions>
</MudDialog>

@code {
    private Dictionary<string, BackgroundJobConfig>? _jobs;
    private int _queueDepth;
    private Timer? _refreshTimer;

    // Dialog state
    private bool _showConfigDialog;
    private BackgroundJobConfig? _editingJob;
    private string? _editCronExpression;

    // Granular backup retention settings (5-tier)
    private int _editRetainHourlyBackups = 24;
    private int _editRetainDailyBackups = 7;
    private int _editRetainWeeklyBackups = 4;
    private int _editRetainMonthlyBackups = 12;
    private int _editRetainYearlyBackups = 3;
    private string? _editBackupDirectory;

    private bool _editRunVacuum = true;
    private bool _editRunAnalyze = true;

    private readonly DialogOptions _dialogOptions = new()
    {
        MaxWidth = MaxWidth.Small,
        FullWidth = true
    };

    protected override async Task OnInitializedAsync()
    {
        // Ensure default job configs exist before loading
        await JobConfigService.EnsureDefaultConfigsAsync();

        await LoadJobsAsync();
        UpdateQueueDepth();

        // Refresh queue depth every 5 seconds
        _refreshTimer = new Timer(_ =>
        {
            UpdateQueueDepth();
            InvokeAsync(StateHasChanged);
        }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
    }

    private async Task LoadJobsAsync()
    {
        _jobs = await JobConfigService.GetAllJobsAsync();
    }

    private void UpdateQueueDepth()
    {
        _queueDepth = QueueService.GetQueueDepth();
    }

    private async Task ToggleJobAsync(string jobName, bool enabled)
    {
        if (_jobs == null || !_jobs.TryGetValue(jobName, out var job))
            return;

        job.Enabled = enabled;
        await JobConfigService.UpdateJobConfigAsync(jobName, job);

        Snackbar.Add($"{job.DisplayName} {(enabled ? "enabled" : "disabled")}",
            enabled ? Severity.Success : Severity.Info);
    }

    private async Task RunNowAsync(string jobName)
    {
        if (_jobs == null || !_jobs.TryGetValue(jobName, out var job))
            return;

        try
        {
            // Build payload based on job type
            object payload = jobName switch
            {
                BackgroundJobNames.ScheduledBackup => BuildBackupPayload(job),
                BackgroundJobNames.DatabaseMaintenance => BuildMaintenancePayload(job),
                BackgroundJobNames.UserPhotoRefresh => BuildUserPhotoRefreshPayload(job),
                BackgroundJobNames.BlocklistSync => BuildBlocklistSyncPayload(),
                _ => new { } // Empty object for jobs without payloads
            };

            // Enqueue job via TickerQ utility
            var jobId = await TickerQUtilities.ScheduleJobAsync(
                ServiceProvider,
                Logger,
                jobName,
                payload,
                delaySeconds: 0); // Run immediately

            if (jobId.HasValue)
            {
                Snackbar.Add($"{job.DisplayName} queued for execution", Severity.Success);
            }
            else
            {
                Snackbar.Add($"Failed to queue {job.DisplayName}", Severity.Warning);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to queue job: {ex.Message}", Severity.Error);
        }
    }

    private void OpenConfigDialog(BackgroundJobConfig job)
    {
        // Redirect to backup page for backup job configuration
        if (job.JobName == BackgroundJobNames.ScheduledBackup)
        {
            Navigation.NavigateTo("/settings/backup");
            return;
        }

        _editingJob = job;
        _editCronExpression = job.CronExpression;

        // Load job-specific settings
        if (job.Settings != null)
        {
            if (job.JobName == BackgroundJobNames.ScheduledBackup)
            {
                // Load granular retention settings
                if (job.Settings.TryGetValue(BackgroundJobSettings.RetainHourlyBackups, out var hourly))
                    _editRetainHourlyBackups = Convert.ToInt32(((JsonElement)hourly).GetInt32());
                if (job.Settings.TryGetValue(BackgroundJobSettings.RetainDailyBackups, out var daily))
                    _editRetainDailyBackups = Convert.ToInt32(((JsonElement)daily).GetInt32());
                if (job.Settings.TryGetValue(BackgroundJobSettings.RetainWeeklyBackups, out var weekly))
                    _editRetainWeeklyBackups = Convert.ToInt32(((JsonElement)weekly).GetInt32());
                if (job.Settings.TryGetValue(BackgroundJobSettings.RetainMonthlyBackups, out var monthly))
                    _editRetainMonthlyBackups = Convert.ToInt32(((JsonElement)monthly).GetInt32());
                if (job.Settings.TryGetValue(BackgroundJobSettings.RetainYearlyBackups, out var yearly))
                    _editRetainYearlyBackups = Convert.ToInt32(((JsonElement)yearly).GetInt32());
                if (job.Settings.TryGetValue(BackgroundJobSettings.BackupDirectory, out var dir))
                    _editBackupDirectory = ((JsonElement)dir).GetString();
            }
            else if (job.JobName == BackgroundJobNames.DatabaseMaintenance)
            {
                if (job.Settings.TryGetValue(BackgroundJobSettings.RunVacuum, out var vacuum))
                    _editRunVacuum = ((JsonElement)vacuum).GetBoolean();
                if (job.Settings.TryGetValue(BackgroundJobSettings.RunAnalyze, out var analyze))
                    _editRunAnalyze = ((JsonElement)analyze).GetBoolean();
            }
        }

        _showConfigDialog = true;
    }

    private void CloseConfigDialog()
    {
        _showConfigDialog = false;
        _editingJob = null;
    }

    private async Task SaveConfigAsync()
    {
        if (_editingJob == null || _jobs == null)
            return;

        try
        {
            // TODO: Reimplement schedule validation with friendly format → cron conversion
            // Schedule editing is currently disabled - cron expression is readonly

            // Update job-specific settings
            _editingJob.Settings ??= new Dictionary<string, object>();

            if (_editingJob.JobName == BackgroundJobNames.ScheduledBackup)
            {
                // Save granular retention settings
                _editingJob.Settings[BackgroundJobSettings.RetainHourlyBackups] = _editRetainHourlyBackups;
                _editingJob.Settings[BackgroundJobSettings.RetainDailyBackups] = _editRetainDailyBackups;
                _editingJob.Settings[BackgroundJobSettings.RetainWeeklyBackups] = _editRetainWeeklyBackups;
                _editingJob.Settings[BackgroundJobSettings.RetainMonthlyBackups] = _editRetainMonthlyBackups;
                _editingJob.Settings[BackgroundJobSettings.RetainYearlyBackups] = _editRetainYearlyBackups;
                if (!string.IsNullOrWhiteSpace(_editBackupDirectory))
                    _editingJob.Settings[BackgroundJobSettings.BackupDirectory] = _editBackupDirectory;
            }
            else if (_editingJob.JobName == BackgroundJobNames.DatabaseMaintenance)
            {
                _editingJob.Settings[BackgroundJobSettings.RunVacuum] = _editRunVacuum;
                _editingJob.Settings[BackgroundJobSettings.RunAnalyze] = _editRunAnalyze;
            }

            await JobConfigService.UpdateJobConfigAsync(_editingJob.JobName, _editingJob);
            await LoadJobsAsync(); // Refresh

            Snackbar.Add($"{_editingJob.DisplayName} configuration saved", Severity.Success);
            CloseConfigDialog();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save configuration: {ex.Message}", Severity.Error);
        }
    }

    private object BuildBackupPayload(BackgroundJobConfig job)
    {
        // Granular retention settings (5-tier)
        var retainHourly = 24;
        var retainDaily = 7;
        var retainWeekly = 4;
        var retainMonthly = 12;
        var retainYearly = 3;
        string? backupDir = null;

        if (job.Settings != null)
        {
            if (job.Settings.TryGetValue(BackgroundJobSettings.RetainHourlyBackups, out var hourly))
                retainHourly = Convert.ToInt32(((JsonElement)hourly).GetInt32());
            if (job.Settings.TryGetValue(BackgroundJobSettings.RetainDailyBackups, out var daily))
                retainDaily = Convert.ToInt32(((JsonElement)daily).GetInt32());
            if (job.Settings.TryGetValue(BackgroundJobSettings.RetainWeeklyBackups, out var weekly))
                retainWeekly = Convert.ToInt32(((JsonElement)weekly).GetInt32());
            if (job.Settings.TryGetValue(BackgroundJobSettings.RetainMonthlyBackups, out var monthly))
                retainMonthly = Convert.ToInt32(((JsonElement)monthly).GetInt32());
            if (job.Settings.TryGetValue(BackgroundJobSettings.RetainYearlyBackups, out var yearly))
                retainYearly = Convert.ToInt32(((JsonElement)yearly).GetInt32());
            if (job.Settings.TryGetValue(BackgroundJobSettings.BackupDirectory, out var dir))
                backupDir = ((JsonElement)dir).GetString();
        }

        return new ScheduledBackupPayload
        {
            RetainHourlyBackups = retainHourly,
            RetainDailyBackups = retainDaily,
            RetainWeeklyBackups = retainWeekly,
            RetainMonthlyBackups = retainMonthly,
            RetainYearlyBackups = retainYearly,
            BackupDirectory = backupDir
        };
    }

    private object BuildMaintenancePayload(BackgroundJobConfig job)
    {
        var runVacuum = true;
        var runAnalyze = true;

        if (job.Settings != null)
        {
            if (job.Settings.TryGetValue(BackgroundJobSettings.RunVacuum, out var vacuum))
                runVacuum = ((JsonElement)vacuum).GetBoolean();
            if (job.Settings.TryGetValue(BackgroundJobSettings.RunAnalyze, out var analyze))
                runAnalyze = ((JsonElement)analyze).GetBoolean();
        }

        return new DatabaseMaintenancePayload
        {
            RunVacuum = runVacuum,
            RunAnalyze = runAnalyze,
            RunVacuumFull = false
        };
    }

    private object BuildUserPhotoRefreshPayload(BackgroundJobConfig job)
    {
        var daysBack = 7;

        if (job.Settings != null)
        {
            if (job.Settings.TryGetValue(BackgroundJobSettings.DaysBack, out var days))
                daysBack = Convert.ToInt32(((JsonElement)days).GetInt32());
        }

        return new RefreshUserPhotosPayload
        {
            DaysBack = daysBack
        };
    }

    private object BuildBlocklistSyncPayload()
    {
        return new BlocklistSyncJobPayload(
            SubscriptionId: null, // Sync all
            ChatId: 0, // Global
            ForceRebuild: false
        );
    }

    private static string FormatCronSchedule(string? cron)
    {
        if (string.IsNullOrEmpty(cron))
            return "Not configured";

        // Parse common cron patterns for user-friendly display
        return cron switch
        {
            "0 2 * * *" => "Daily at 2:00 AM",
            "0 3 * * *" => "Daily at 3:00 AM",
            "0 4 * * *" => "Daily at 4:00 AM",
            "0 0 * * *" => "Daily at midnight",
            "0 3 * * 0" => "Sundays at 3:00 AM",
            "0 4 * * 0" => "Sundays at 4:00 AM",
            "0 */6 * * *" => "Every 6 hours",
            "0 */12 * * *" => "Every 12 hours",
            "0 0 1 * *" => "First of month at midnight",
            _ => cron
        };
    }


    public void Dispose()
    {
        _refreshTimer?.Dispose();
    }
}
