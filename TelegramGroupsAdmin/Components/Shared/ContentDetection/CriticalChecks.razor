@using TelegramGroupsAdmin.Configuration
@using TelegramGroupsAdmin.Configuration.Models.ContentDetection
@using TelegramGroupsAdmin.Configuration.Services
@using TelegramGroupsAdmin.Auth
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@inject IConfigService ConfigService
@inject ISnackbar Snackbar
@inject AuthenticationStateProvider AuthStateProvider

<MudGrid>
    <MudItem xs="12">
        <MudAlert Severity="Severity.Info" Variant="Variant.Filled" Class="mb-4">
            <MudText Typo="Typo.subtitle2"><strong>Critical Checks</strong></MudText>
            <MudText Typo="Typo.body2">
                Critical checks run for <strong>ALL users</strong>, including trusted users and admins.
                When a critical check flags a message, it is deleted and the user is notified, but NO ban or warning is applied.
                Use this for security policies that must apply universally (malicious URLs, malware, etc.).
            </MudText>
        </MudAlert>
    </MudItem>

    @if (_loading)
    {
        <MudItem xs="12">
            <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
        </MudItem>
    }
    else
    {
        <!-- Security Checks Group -->
        <MudItem xs="12" md="6">
            <MudPaper Class="pa-4" Elevation="1">
                <MudStack Spacing="3">
                    <MudText Typo="Typo.h6" Color="Color.Primary">
                        <MudIcon Icon="@Icons.Material.Filled.Security" Class="mr-2" />
                        Security Checks
                    </MudText>

                    @foreach (var check in _securityChecks)
                    {
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                            <MudSwitch T="bool"
                                      Value="@check.AlwaysRun"
                                      ValueChanged="@(v => OnAlwaysRunChanged(check, v))"
                                      Color="@(check.AlwaysRun ? Color.Success : Color.Default)"
                                      Label="@check.DisplayName"
                                      Disabled="@(!_canEdit)" />
                            @if (check.AlwaysRun)
                            {
                                <MudChip T="string" Size="Size.Small" Color="Color.Success" Variant="Variant.Filled">Always Run</MudChip>
                            }
                        </MudStack>
                        <MudText Typo="Typo.caption" Class="ml-10">@check.Description</MudText>

                        @if (check is { Enabled: false, AlwaysRun: true })
                        {
                            <MudAlert Severity="Severity.Warning" Dense="true" Class="ml-10">
                                This check is marked as critical but is <strong>disabled</strong>. It will not run.
                            </MudAlert>
                        }
                    }
                </MudStack>
            </MudPaper>
        </MudItem>

        <!-- Spam Detection Algorithms Group -->
        <MudItem xs="12">
            <MudPaper Class="pa-4" Elevation="1">
                <MudStack Spacing="3">
                    <MudText Typo="Typo.h6" Color="Color.Primary">
                        <MudIcon Icon="@Icons.Material.Filled.FilterAlt" Class="mr-2" />
                        Spam Detection Algorithms
                    </MudText>
                    <MudText Typo="Typo.body2" Color="Color.Default">
                        Generally, spam checks should NOT be marked as "always run" since they're content moderation (not security).
                        However, you can enable this if you want certain algorithms to apply even to trusted users/admins.
                    </MudText>

                    <MudGrid>
                        @foreach (var check in _contentChecks)
                        {
                            <MudItem xs="12" sm="6" md="4">
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                    <MudSwitch T="bool"
                                              Value="@check.AlwaysRun"
                                              ValueChanged="@(v => OnAlwaysRunChanged(check, v))"
                                              Color="@(check.AlwaysRun ? Color.Success : Color.Default)"
                                              Label="@check.DisplayName"
                                              Disabled="@(!_canEdit)" />
                                    @if (check.AlwaysRun)
                                    {
                                        <MudChip T="string" Size="Size.Small" Color="Color.Success" Variant="Variant.Filled">Always Run</MudChip>
                                    }
                                </MudStack>
                                <MudText Typo="Typo.caption" Class="ml-10">@check.Description</MudText>

                                @if (check is { Enabled: false, AlwaysRun: true })
                                {
                                    <MudAlert Severity="Severity.Warning" Dense="true" Class="ml-10">
                                        This check is marked as critical but is <strong>disabled</strong>. It will not run.
                                    </MudAlert>
                                }
                            </MudItem>
                        }
                    </MudGrid>
                </MudStack>
            </MudPaper>
        </MudItem>

        <!-- Save Button -->
        <MudItem xs="12">
            <MudStack Row="true" Spacing="2">
                <MudButton Variant="Variant.Filled"
                          Color="Color.Primary"
                          OnClick="@SaveChanges"
                          Disabled="@(!_canEdit || _saving)">
                    @if (_saving)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                        <text>&nbsp;Saving...</text>
                    }
                    else
                    {
                        <text>Save Changes</text>
                    }
                </MudButton>
                <MudButton Variant="Variant.Outlined"
                          OnClick="@LoadConfiguration"
                          Disabled="@_saving">
                    Reset
                </MudButton>
            </MudStack>
        </MudItem>

        @if (HasDisabledCriticalChecks)
        {
            <MudItem xs="12">
                <MudAlert Severity="Severity.Warning" Variant="Variant.Filled">
                    <strong>Warning:</strong> You have disabled one or more critical security checks.
                    This may expose your chat to malicious content (URLs, files, etc.).
                    Only disable critical checks if you understand the security implications.
                </MudAlert>
            </MudItem>
        }
    }
</MudGrid>

@code {
    private bool _loading = true;
    private bool _saving;
    private bool _canEdit;
    private ContentDetectionConfig _config = new();
    private List<CheckViewModel> _securityChecks = [];
    private List<CheckViewModel> _contentChecks = [];
    private bool HasDisabledCriticalChecks => _securityChecks.Any(c => !c.AlwaysRun);

    protected override async Task OnInitializedAsync()
    {
        // Check if user is Admin or Owner (only they can modify critical checks)
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        var permissionClaim = user.FindFirst(CustomClaimTypes.PermissionLevel);
        var permissionLevel = permissionClaim != null && int.TryParse(permissionClaim.Value, out var level)
            ? (PermissionLevel)level
            : PermissionLevel.Admin;
        _canEdit = permissionLevel >= PermissionLevel.GlobalAdmin;

        await LoadConfiguration();
    }

    private async Task LoadConfiguration()
    {
        try
        {
            _loading = true;
            StateHasChanged();

            // Load global content detection config (chat_id = 0)
            _config = await ConfigService.GetEffectiveAsync<ContentDetectionConfig>(ConfigType.ContentDetection, 0)
                      ?? new ContentDetectionConfig();

            // Build view models from config sub-configs
            _securityChecks =
            [
                new() { CheckName = "UrlBlocklist", DisplayName = "URL Filtering", Description = "Block malicious domains from 540K+ blocklists (hard-block mode)", Category = "Security", Enabled = _config.UrlBlocklist.Enabled, AlwaysRun = _config.UrlBlocklist.AlwaysRun },
                new() { CheckName = "ThreatIntel", DisplayName = "Threat Intelligence", Description = "VirusTotal URL scanning for malware detection", Category = "Security", Enabled = _config.ThreatIntel.Enabled, AlwaysRun = _config.ThreatIntel.AlwaysRun },
                new() { CheckName = "FileScanning", DisplayName = "File Scanning", Description = "ClamAV + VirusTotal malware scanning for uploaded files", Category = "Security", Enabled = _config.FileScanning.Enabled, AlwaysRun = _config.FileScanning.AlwaysRun }
            ];

            _contentChecks =
            [
                new() { CheckName = "StopWords", DisplayName = "Stop Words", Description = "Pattern matching against banned keywords/phrases", Category = "Spam", Enabled = _config.StopWords.Enabled, AlwaysRun = _config.StopWords.AlwaysRun },
                new() { CheckName = "ImageSpam", DisplayName = "Image Spam (Vision)", Description = "OpenAI Vision API image content analysis", Category = "Spam", Enabled = _config.ImageSpam.Enabled, AlwaysRun = _config.ImageSpam.AlwaysRun },
                new() { CheckName = "VideoSpam", DisplayName = "Video Spam", Description = "Video content analysis for spam detection", Category = "Spam", Enabled = _config.VideoSpam.Enabled, AlwaysRun = _config.VideoSpam.AlwaysRun },
                new() { CheckName = "Cas", DisplayName = "CAS (Combot)", Description = "Check against Combot Anti-Spam database", Category = "Spam", Enabled = _config.Cas.Enabled, AlwaysRun = _config.Cas.AlwaysRun },
                new() { CheckName = "Similarity", DisplayName = "Similarity (TF-IDF)", Description = "Detect duplicate/similar spam messages", Category = "Spam", Enabled = _config.Similarity.Enabled, AlwaysRun = _config.Similarity.AlwaysRun },
                new() { CheckName = "Bayes", DisplayName = "Bayesian Filter", Description = "Statistical spam classification", Category = "Spam", Enabled = _config.Bayes.Enabled, AlwaysRun = _config.Bayes.AlwaysRun },
                new() { CheckName = "Translation", DisplayName = "Multi-Language", Description = "Detect excessive language mixing", Category = "Spam", Enabled = _config.Translation.Enabled, AlwaysRun = _config.Translation.AlwaysRun },
                new() { CheckName = "Spacing", DisplayName = "Spacing Check", Description = "Detect excessive spacing/formatting abuse", Category = "Spam", Enabled = _config.Spacing.Enabled, AlwaysRun = _config.Spacing.AlwaysRun },
                new() { CheckName = "InvisibleChars", DisplayName = "Invisible Characters", Description = "Detect hidden Unicode characters", Category = "Spam", Enabled = _config.InvisibleChars.Enabled, AlwaysRun = _config.InvisibleChars.AlwaysRun },
                new() { CheckName = "SeoScraping", DisplayName = "SEO Scraping", Description = "Detect SEO spam and scraping patterns", Category = "Spam", Enabled = _config.SeoScraping.Enabled, AlwaysRun = _config.SeoScraping.AlwaysRun }
            ];
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load critical checks configuration: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private void OnAlwaysRunChanged(CheckViewModel check, bool newValue)
    {
        check.AlwaysRun = newValue;

        // Update the corresponding sub-config in _config
        switch (check.CheckName)
        {
            case "UrlBlocklist": _config.UrlBlocklist.AlwaysRun = newValue; break;
            case "ThreatIntel": _config.ThreatIntel.AlwaysRun = newValue; break;
            case "FileScanning": _config.FileScanning.AlwaysRun = newValue; break;
            case "ImageSpam": _config.ImageSpam.AlwaysRun = newValue; break;
            case "VideoSpam": _config.VideoSpam.AlwaysRun = newValue; break;
            case "StopWords": _config.StopWords.AlwaysRun = newValue; break;
            case "Cas": _config.Cas.AlwaysRun = newValue; break;
            case "Similarity": _config.Similarity.AlwaysRun = newValue; break;
            case "Bayes": _config.Bayes.AlwaysRun = newValue; break;
            case "Translation": _config.Translation.AlwaysRun = newValue; break;
            case "Spacing": _config.Spacing.AlwaysRun = newValue; break;
            case "InvisibleChars": _config.InvisibleChars.AlwaysRun = newValue; break;
            case "SeoScraping": _config.SeoScraping.AlwaysRun = newValue; break;
        }

        StateHasChanged();
    }

    private async Task SaveChanges()
    {
        if (!_canEdit)
        {
            Snackbar.Add("You don't have permission to modify critical checks", Severity.Error);
            return;
        }

        try
        {
            _saving = true;
            StateHasChanged();

            // Save the entire config (which now includes AlwaysRun in each sub-config)
            await ConfigService.SaveAsync(ConfigType.ContentDetection, 0, _config);

            Snackbar.Add("Critical checks configuration saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save configuration: {ex.Message}", Severity.Error);
        }
        finally
        {
            _saving = false;
            StateHasChanged();
        }
    }

    private class CheckViewModel
    {
        public string CheckName { get; init; } = string.Empty;
        public string DisplayName { get; init; } = string.Empty;
        public string Description { get; init; } = string.Empty;
        public string Category { get; init; } = string.Empty;
        public bool Enabled { get; init; }
        public bool AlwaysRun { get; set; }
    }
}
