@using TelegramGroupsAdmin.ContentDetection.Repositories
@using TelegramGroupsAdmin.ContentDetection.Models
@using TelegramGroupsAdmin.ContentDetection.Services.Blocklists
@using Microsoft.AspNetCore.Components.Authorization
@inject IBlocklistSubscriptionsRepository BlocklistRepo
@inject IDomainFiltersRepository DomainFiltersRepo
@inject IBlocklistSyncService BlocklistSync
@inject IConfigService ConfigService
@inject ISnackbar Snackbar
@inject AuthenticationStateProvider AuthStateProvider
@implements IDisposable

<MudGrid>
    <!-- URL Blocklist Feature Toggle -->
    <MudItem xs="12">
        <MudPaper Class="pa-4" Elevation="2">
            <MudStack Spacing="3">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudIcon Icon="@Icons.Material.Filled.ToggleOn" Color="Color.Primary" />
                    <MudText Typo="Typo.h6">URL Blocklist Detection</MudText>
                </MudStack>

                <MudAlert Severity="Severity.Info" Dense="true">
                    Enable or disable URL blocklist checking. When enabled, messages containing URLs from blocklists below will be flagged as spam.
                </MudAlert>

                <MudSwitch T="bool" Value="_urlBlocklistConfig.Enabled"
                          ValueChanged="OnUrlBlocklistEnabledChanged"
                          Label="Enable URL Blocklist Check"
                          Color="Color.Primary" />

                @if (_urlBlocklistConfig.Enabled)
                {
                    <MudNumericField Value="@((int)_urlBlocklistConfig.CacheDuration.TotalHours)"
                                    ValueChanged="@((int val) => OnCacheDurationChanged(val))"
                                    Label="Cache Duration (hours)"
                                    Min="1" Max="168"
                                    HelperText="How long to cache blocklist entries (1-168 hours)" />
                }
            </MudStack>
        </MudPaper>
    </MudItem>
</MudGrid>

<MudGrid>
    <!-- Left Panel: Hard Block (Pre-Detection) -->
    <MudItem xs="12" md="4">
        <MudPaper Class="pa-4" Elevation="2" Style="height: 100%">
            <MudStack Spacing="3">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <MudText Typo="Typo.h6" Color="Color.Error">
                            <MudIcon Icon="@Icons.Material.Filled.Block" Class="mr-2" />
                            Hard Block
                        </MudText>
                        <HelpTooltip Text="Hard Block = Instant ban with no appeal. Message deleted, user banned immediately, no OpenAI verification. Use for known malicious domains (malware, phishing, scams). Runs BEFORE spam detection pipeline." />
                    </MudStack>
                    <MudChip T="string" Size="Size.Small" Color="Color.Error">Instant Ban</MudChip>
                </MudStack>

                <ConceptualAlert Severity="Severity.Error" Dense="true" Class="mb-2">
                    Hard Block domains trigger <strong>immediate ban</strong> without confidence voting or OpenAI veto. Use only for confirmed malicious domains where false positives are impossible (e.g., known phishing sites).
                </ConceptualAlert>

                @if (_loading)
                {
                    <MudProgressLinear Indeterminate="true" Color="Color.Primary" />
                }
                else
                {
                    <!-- Built-in Blocklists -->
                    <MudText Typo="Typo.subtitle2" Class="mt-2">Block List Project Subscriptions</MudText>
                    @foreach (var blocklist in _builtInBlocklists)
                    {
                        <MudCheckBox T="bool"
                                    Value="@IsBlocklistEnabled(blocklist, BlockMode.Hard)"
                                    ValueChanged="@(async (bool enabled) => await ToggleBlocklist(blocklist, BlockMode.Hard, enabled))"
                                    Label="@blocklist.Name"
                                    Color="Color.Primary"
                                    Dense="true">
                            @if (blocklist.EntryCount.HasValue)
                            {
                                <MudText Typo="Typo.caption" Class="ml-2">(@blocklist.EntryCount.Value.ToString("N0") domains)</MudText>
                            }
                        </MudCheckBox>
                    }

                    <!-- Custom URLs -->
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mt-4">
                        <MudText Typo="Typo.subtitle2">Custom Blocklist URLs (one per line)</MudText>
                        <HelpTooltip Text="URLs to external blocklists (one domain per line format). Synced hourly. Example: abuse.ch URLhaus, PhishTank. Must be publicly accessible HTTP(S) endpoints returning newline-separated domains." />
                    </MudStack>
                    <MudTextField @bind-Value="_hardBlockCustomUrls"
                                 Lines="6"
                                 Variant="Variant.Outlined"
                                 Placeholder="https://example.com/blocklist.txt"
                                 HelperText="External blocklists (newline format)" />

                    <!-- Manual Domains -->
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mt-4">
                        <MudText Typo="Typo.subtitle2">Manual Domains (one per line)</MudText>
                        <HelpTooltip Text="Wildcard syntax: Use *.example.com to match all subdomains (test.example.com, api.example.com). Use example.com to match exact domain only. One domain per line." />
                    </MudStack>
                    <MudTextField @bind-Value="_hardBlockManualDomains"
                                 Lines="6"
                                 Variant="Variant.Outlined"
                                 Placeholder="evil.com&#10;spam.net&#10;*.scam.org"
                                 HelperText="Manually blocked domains (supports wildcards)" />

                    <MudButton Variant="Variant.Filled"
                              Color="Color.Error"
                              StartIcon="@Icons.Material.Filled.Save"
                              OnClick="@(() => SaveConfiguration(BlockMode.Hard))"
                              Disabled="@_saving"
                              FullWidth="true">
                        Save Hard Block Rules
                    </MudButton>
                }
            </MudStack>
        </MudPaper>
    </MudItem>

    <!-- Center Panel: Global Whitelist -->
    <MudItem xs="12" md="4">
        <MudPaper Class="pa-4" Elevation="2" Style="height: 100%">
            <MudStack Spacing="3">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <MudText Typo="Typo.h6" Color="Color.Success">
                            <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Class="mr-2" />
                            Whitelist
                        </MudText>
                        <HelpTooltip Text="Whitelist = Complete bypass of all URL filtering (both hard and soft blocks). Whitelisted domains are always allowed, even if they appear in blocklists. Use for legitimate domains that trigger false positives (e.g., URL shorteners, your own sites)." />
                    </MudStack>
                    <MudChip T="string" Size="Size.Small" Color="Color.Success">Bypass All</MudChip>
                </MudStack>

                <ConceptualAlert Severity="Severity.Success" Dense="true" Class="mb-2">
                    Whitelisted domains <strong>bypass all blocking</strong> (hard and soft). Takes highest priority. Use for false positive prevention (e.g., bit.ly, yourdomain.com).
                </ConceptualAlert>

                @if (_loading)
                {
                    <MudProgressLinear Indeterminate="true" Color="Color.Primary" />
                }
                else
                {
                    <MudText Typo="Typo.subtitle2" Class="mt-2">Trusted Domains (one per line)</MudText>
                    <MudTextField @bind-Value="_whitelistDomains"
                                 Lines="20"
                                 Variant="Variant.Outlined"
                                 Placeholder="trusted.com&#10;legitimate.org&#10;*.safe-domain.net"
                                 HelperText="Whitelisted domains (supports wildcards)" />

                    <MudButton Variant="Variant.Filled"
                              Color="Color.Success"
                              StartIcon="@Icons.Material.Filled.Save"
                              OnClick="@SaveWhitelist"
                              Disabled="@_saving"
                              FullWidth="true">
                        Save Whitelist
                    </MudButton>
                }
            </MudStack>
        </MudPaper>
    </MudItem>

    <!-- Right Panel: Soft Block (Confidence Voting) -->
    <MudItem xs="12" md="4">
        <MudPaper Class="pa-4" Elevation="2" Style="height: 100%">
            <MudStack Spacing="3">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <MudText Typo="Typo.h6" Color="Color.Warning">
                            <MudIcon Icon="@Icons.Material.Filled.Warning" Class="mr-2" />
                            Soft Block
                        </MudText>
                        <HelpTooltip Text="Soft Block = Contributes to spam confidence voting (adds ~70-85 confidence). Message may be deleted if total confidence exceeds threshold, but OpenAI can veto false positives. Use for suspicious domains (URL shorteners, newly registered domains, SEO spam). Runs DURING spam detection pipeline." />
                    </MudStack>
                    <MudChip T="string" Size="Size.Small" Color="Color.Warning">OpenAI Veto</MudChip>
                </MudStack>

                <ConceptualAlert Severity="Severity.Warning" Dense="true" Class="mb-2">
                    Soft Block domains add confidence to spam score but <strong>can be vetoed by OpenAI</strong>. Message deleted only if combined confidence â‰¥ threshold. Safer for questionable domains that might have legitimate uses.
                </ConceptualAlert>

                @if (_loading)
                {
                    <MudProgressLinear Indeterminate="true" Color="Color.Primary" />
                }
                else
                {
                    <!-- Built-in Blocklists -->
                    <MudText Typo="Typo.subtitle2" Class="mt-2">Block List Project Subscriptions</MudText>
                    @foreach (var blocklist in _builtInBlocklists)
                    {
                        <MudCheckBox T="bool"
                                    Value="@IsBlocklistEnabled(blocklist, BlockMode.Soft)"
                                    ValueChanged="@(async (bool enabled) => await ToggleBlocklist(blocklist, BlockMode.Soft, enabled))"
                                    Label="@blocklist.Name"
                                    Color="Color.Primary"
                                    Dense="true">
                            @if (blocklist.EntryCount.HasValue)
                            {
                                <MudText Typo="Typo.caption" Class="ml-2">(@blocklist.EntryCount.Value.ToString("N0") domains)</MudText>
                            }
                        </MudCheckBox>
                    }

                    <!-- Custom URLs -->
                    <MudText Typo="Typo.subtitle2" Class="mt-4">Custom Blocklist URLs (one per line)</MudText>
                    <MudTextField @bind-Value="_softBlockCustomUrls"
                                 Lines="6"
                                 Variant="Variant.Outlined"
                                 Placeholder="https://example.com/blocklist.txt"
                                 HelperText="External blocklists (newline format)" />

                    <!-- Manual Domains -->
                    <MudText Typo="Typo.subtitle2" Class="mt-4">Manual Domains (one per line)</MudText>
                    <MudTextField @bind-Value="_softBlockManualDomains"
                                 Lines="6"
                                 Variant="Variant.Outlined"
                                 Placeholder="suspicious.com&#10;questionable.net"
                                 HelperText="Manually blocked domains (supports wildcards)" />

                    <MudButton Variant="Variant.Filled"
                              Color="Color.Warning"
                              StartIcon="@Icons.Material.Filled.Save"
                              OnClick="@(() => SaveConfiguration(BlockMode.Soft))"
                              Disabled="@_saving"
                              FullWidth="true">
                        Save Soft Block Rules
                    </MudButton>
                }
            </MudStack>
        </MudPaper>
    </MudItem>
</MudGrid>

<!-- Sync Button -->
@if (!_loading)
{
    <MudStack Row="true" Justify="Justify.Center" Class="mt-4">
        <MudButton Variant="Variant.Outlined"
                  Color="Color.Primary"
                  StartIcon="@Icons.Material.Filled.Sync"
                  OnClick="@SyncAllBlocklists"
                  Disabled="@_syncing">
            @if (_syncing)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <text>Syncing all blocklists...</text>
            }
            else
            {
                <text>Sync All Blocklists Now</text>
            }
        </MudButton>
    </MudStack>
}

@code {
    [Parameter]
    public long ChatId { get; set; } // 0 = global, non-zero = chat-specific

    private List<BlocklistSubscription> _builtInBlocklists = [];
    private List<BlocklistSubscription> _customSubscriptions = [];
    private List<DomainFilter> _manualFilters = [];

    private bool _loading = true;
    private bool _saving;
    private bool _syncing;
    private CancellationTokenSource? _reloadCts;

    // URL Blocklist feature configuration
    private UrlBlocklistConfig _urlBlocklistConfig = new();
    private ContentDetectionConfig _globalSpamConfig = new();

    // Hard Block state
    private string _hardBlockCustomUrls = string.Empty;
    private string _hardBlockManualDomains = string.Empty;

    // Whitelist state
    private string _whitelistDomains = string.Empty;

    // Soft Block state
    private string _softBlockCustomUrls = string.Empty;
    private string _softBlockManualDomains = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await LoadDataAsync();
        await LoadUrlBlocklistConfigAsync();
    }

    private async Task LoadUrlBlocklistConfigAsync()
    {
        try
        {
            _globalSpamConfig = await ConfigService.GetAsync<ContentDetectionConfig>(ConfigType.ContentDetection, 0)
                                ?? new ContentDetectionConfig();
            _urlBlocklistConfig = _globalSpamConfig.UrlBlocklist;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading URL blocklist configuration: {ex.Message}", Severity.Error);
            _urlBlocklistConfig = new UrlBlocklistConfig();
        }
    }

    private async Task OnUrlBlocklistEnabledChanged(bool enabled)
    {
        _urlBlocklistConfig.Enabled = enabled;
        await SaveUrlBlocklistConfigAsync();
    }

    private async Task OnCacheDurationChanged(int hours)
    {
        _urlBlocklistConfig.CacheDuration = TimeSpan.FromHours(hours);
        await SaveUrlBlocklistConfigAsync();
    }

    private async Task SaveUrlBlocklistConfigAsync()
    {
        try
        {
            _globalSpamConfig.UrlBlocklist = _urlBlocklistConfig;
            await ConfigService.SaveAsync(ConfigType.ContentDetection, 0, _globalSpamConfig);
            Snackbar.Add("URL blocklist configuration saved", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving URL blocklist configuration: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadDataAsync()
    {
        _loading = true;
        try
        {
            var allSubscriptions = await BlocklistRepo.GetAllAsync(ChatId);
            _builtInBlocklists = allSubscriptions.Where(s => s.IsBuiltIn).ToList();
            _customSubscriptions = allSubscriptions.Where(s => !s.IsBuiltIn).ToList();

            _manualFilters = await DomainFiltersRepo.GetAllAsync(ChatId);

            // Load Hard Block custom URLs
            var hardCustomSubs = _customSubscriptions.Where(s => s.BlockMode == BlockMode.Hard).ToList();
            _hardBlockCustomUrls = string.Join(Environment.NewLine, hardCustomSubs.Select(s => s.Url));

            // Load Hard Block manual domains
            var hardManualDomains = _manualFilters
                .Where(f => f is { FilterType: DomainFilterType.Blacklist, BlockMode: BlockMode.Hard, Enabled: true })
                .Select(f => f.Domain);
            _hardBlockManualDomains = string.Join(Environment.NewLine, hardManualDomains);

            // Load Whitelist domains
            var whitelistDomains = _manualFilters
                .Where(f => f is { FilterType: DomainFilterType.Whitelist, Enabled: true })
                .Select(f => f.Domain);
            _whitelistDomains = string.Join(Environment.NewLine, whitelistDomains);

            // Load Soft Block custom URLs
            var softCustomSubs = _customSubscriptions.Where(s => s.BlockMode == BlockMode.Soft).ToList();
            _softBlockCustomUrls = string.Join(Environment.NewLine, softCustomSubs.Select(s => s.Url));

            // Load Soft Block manual domains
            var softManualDomains = _manualFilters
                .Where(f => f is { FilterType: DomainFilterType.Blacklist, BlockMode: BlockMode.Soft, Enabled: true })
                .Select(f => f.Domain);
            _softBlockManualDomains = string.Join(Environment.NewLine, softManualDomains);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading URL filters: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private bool IsBlocklistEnabled(BlocklistSubscription blocklist, BlockMode mode)
    {
        return blocklist.Enabled && blocklist.BlockMode == mode;
    }

    private async Task ToggleBlocklist(BlocklistSubscription blocklist, BlockMode newMode, bool enabled)
    {
        // Cancel any pending reload
        if (_reloadCts != null)
        {
            await _reloadCts.CancelAsync();
        }
        _reloadCts = new CancellationTokenSource();
        var currentCts = _reloadCts;

        try
        {
            var updated = blocklist with
            {
                BlockMode = enabled ? newMode : BlockMode.Disabled,
                Enabled = enabled
            };

            await BlocklistRepo.UpdateAsync(updated, currentCts.Token);

            // Debounce reload - wait 500ms before reloading to batch multiple changes
            await Task.Delay(500, currentCts.Token);

            // Only reload if this is still the latest change
            if (!currentCts.IsCancellationRequested)
            {
                await LoadDataAsync();
            }

            Snackbar.Add($"{blocklist.Name} {(enabled ? "enabled" : "disabled")} for {newMode} blocking", Severity.Success);
        }
        catch (OperationCanceledException)
        {
            // Debounce was canceled by a newer change, this is expected
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error toggling blocklist: {ex.Message}", Severity.Error);
        }
    }

    private async Task SaveConfiguration(BlockMode mode)
    {
        _saving = true;
        try
        {
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var userId = authState.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
            var userEmail = authState.User.FindFirst(System.Security.Claims.ClaimTypes.Email)?.Value;
            var actor = !string.IsNullOrEmpty(userId) && Guid.TryParse(userId, out _)
                ? Actor.FromWebUser(userId, userEmail)
                : Actor.FromSystem("unknown");

            if (mode == BlockMode.Hard)
            {
                await SaveHardBlockConfigurationAsync(actor);
            }
            else if (mode == BlockMode.Soft)
            {
                await SaveSoftBlockConfigurationAsync(actor);
            }

            await BlocklistSync.RebuildCacheAsync(ChatId);
            await LoadDataAsync();

            Snackbar.Add($"{mode} block configuration saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving configuration: {ex.Message}", Severity.Error);
        }
        finally
        {
            _saving = false;
        }
    }

    private async Task SaveHardBlockConfigurationAsync(Actor actor)
    {
        // Save custom URLs
        var urls = _hardBlockCustomUrls
            .Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries)
            .Select(u => u.Trim())
            .Where(u => !string.IsNullOrWhiteSpace(u))
            .ToList();

        // Remove old custom hard block subscriptions
        var oldCustomHard = _customSubscriptions.Where(s => s.BlockMode == BlockMode.Hard).ToList();
        foreach (var old in oldCustomHard)
        {
            await BlocklistRepo.DeleteAsync(old.Id);
        }

        // Add new custom subscriptions
        foreach (var url in urls)
        {
            var subscription = new BlocklistSubscription(
                Id: 0,
                ChatId: ChatId,
                Name: $"Custom: {url}",
                Url: url,
                Format: BlocklistFormat.NewlineDomains,
                BlockMode: BlockMode.Hard,
                IsBuiltIn: false,
                Enabled: true,
                LastFetched: null,
                EntryCount: null,
                RefreshIntervalHours: 24,
                AddedBy: actor,
                AddedDate: DateTimeOffset.UtcNow,
                Notes: "Custom hard block URL"
            );
            await BlocklistRepo.InsertAsync(subscription);
        }

        // Save manual domains
        await SaveManualDomainsAsync(_hardBlockManualDomains, DomainFilterType.Blacklist, BlockMode.Hard, actor);
    }

    private async Task SaveSoftBlockConfigurationAsync(Actor actor)
    {
        // Save custom URLs
        var urls = _softBlockCustomUrls
            .Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries)
            .Select(u => u.Trim())
            .Where(u => !string.IsNullOrWhiteSpace(u))
            .ToList();

        // Remove old custom soft block subscriptions
        var oldCustomSoft = _customSubscriptions.Where(s => s.BlockMode == BlockMode.Soft).ToList();
        foreach (var old in oldCustomSoft)
        {
            await BlocklistRepo.DeleteAsync(old.Id);
        }

        // Add new custom subscriptions
        foreach (var url in urls)
        {
            var subscription = new BlocklistSubscription(
                Id: 0,
                ChatId: ChatId,
                Name: $"Custom: {url}",
                Url: url,
                Format: BlocklistFormat.NewlineDomains,
                BlockMode: BlockMode.Soft,
                IsBuiltIn: false,
                Enabled: true,
                LastFetched: null,
                EntryCount: null,
                RefreshIntervalHours: 24,
                AddedBy: actor,
                AddedDate: DateTimeOffset.UtcNow,
                Notes: "Custom soft block URL"
            );
            await BlocklistRepo.InsertAsync(subscription);
        }

        // Save manual domains
        await SaveManualDomainsAsync(_softBlockManualDomains, DomainFilterType.Blacklist, BlockMode.Soft, actor);
    }

    private async Task SaveWhitelist()
    {
        _saving = true;
        try
        {
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var userId = authState.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
            var userEmail = authState.User.FindFirst(System.Security.Claims.ClaimTypes.Email)?.Value;
            var actor = !string.IsNullOrEmpty(userId) && Guid.TryParse(userId, out _)
                ? Actor.FromWebUser(userId, userEmail)
                : Actor.FromSystem("unknown");

            await SaveManualDomainsAsync(_whitelistDomains, DomainFilterType.Whitelist, BlockMode.Disabled, actor);
            await BlocklistSync.RebuildCacheAsync(ChatId);
            await LoadDataAsync();

            Snackbar.Add("Whitelist saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving whitelist: {ex.Message}", Severity.Error);
        }
        finally
        {
            _saving = false;
        }
    }

    private async Task SaveManualDomainsAsync(string domainsText, DomainFilterType filterType, BlockMode blockMode, Actor actor)
    {
        var domains = domainsText
            .Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries)
            .Select(d => d.Trim().ToLowerInvariant())
            .Where(d => !string.IsNullOrWhiteSpace(d))
            .ToHashSet();

        // Remove old filters of this type and mode
        var oldFilters = _manualFilters
            .Where(f => f.FilterType == filterType && f.BlockMode == blockMode)
            .ToList();

        foreach (var old in oldFilters)
        {
            await DomainFiltersRepo.DeleteAsync(old.Id);
        }

        // Add new filters
        foreach (var domain in domains)
        {
            var filter = new DomainFilter(
                Id: 0,
                ChatId: ChatId,
                Domain: domain,
                FilterType: filterType,
                BlockMode: blockMode,
                Enabled: true,
                AddedBy: actor,
                AddedDate: DateTimeOffset.UtcNow,
                Notes: null
            );
            await DomainFiltersRepo.InsertAsync(filter);
        }
    }

    private async Task SyncAllBlocklists()
    {
        _syncing = true;
        try
        {
            await BlocklistSync.SyncAllAsync();
            await LoadDataAsync();
            Snackbar.Add("All blocklists synced successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error syncing blocklists: {ex.Message}", Severity.Error);
        }
        finally
        {
            _syncing = false;
        }
    }

    public void Dispose()
    {
        _reloadCts?.Cancel();
        _reloadCts?.Dispose();
    }
}
