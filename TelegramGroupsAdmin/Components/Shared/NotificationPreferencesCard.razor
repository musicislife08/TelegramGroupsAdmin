@using TelegramGroupsAdmin.Core.Repositories
@using TelegramGroupsAdmin.Core.Models
@using TelegramGroupsAdmin.Telegram.Repositories
@inject INotificationPreferencesRepository PreferencesRepo
@inject ITelegramUserMappingRepository TelegramMappingRepo
@inject ISnackbar Snackbar

<MudPaper Class="pa-4" Elevation="2">
    <MudText Typo="Typo.h6" Class="mb-3">
        <MudIcon Icon="@Icons.Material.Filled.Notifications" Class="mr-2" />
        Notification Preferences
    </MudText>

    @if (_loading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
    }
    else if (_config != null)
    {
        <MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-4">
            @foreach (var channel in Enum.GetValues<NotificationChannel>())
            {
                var isConfigured = IsChannelConfigured(channel);
                <MudTabPanel Text="@GetChannelDisplayName(channel)"
                             Icon="@GetChannelIcon(channel)"
                             Disabled="@(!isConfigured)"
                             ToolTip="@(isConfigured ? null : GetSetupTooltip(channel))">
                    @if (!isConfigured)
                    {
                        <MudAlert Severity="Severity.Info" Class="mt-2">
                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                <MudText>This channel is not configured.</MudText>
                                <MudLink Href="@GetSetupLink(channel)">Set it up</MudLink>
                            </MudStack>
                        </MudAlert>
                    }
                    else
                    {
                        <MudText Typo="Typo.subtitle2" Class="mb-3">
                            Select which events should send notifications via @GetChannelDisplayName(channel):
                        </MudText>

                        <MudStack Spacing="1">
                            @foreach (var eventType in GetVisibleEventTypes())
                            {
                                var channelPref = _config.GetOrCreateChannel(channel);
                                var isEnabled = channelPref.EnabledEvents.Contains(eventType);
                                <MudCheckBox T="bool"
                                             Value="@isEnabled"
                                             ValueChanged="@(enabled => ToggleEvent(channel, eventType, enabled))"
                                             Label="@GetEventDisplayName(eventType)"
                                             Color="@GetEventColor(eventType)"
                                             Dense="true" />
                            }
                        </MudStack>

                        @* Email-specific: digest interval *@
                        @if (channel == NotificationChannel.Email)
                        {
                            <MudDivider Class="my-3" />
                            <MudNumericField T="int"
                                             Value="@GetDigestMinutes()"
                                             ValueChanged="@SetDigestMinutes"
                                             Label="Digest Interval (minutes)"
                                             Variant="Variant.Outlined"
                                             Min="0"
                                             Max="1440"
                                             HelperText="0 = send immediately, otherwise batch notifications" />
                        }
                    }
                </MudTabPanel>
            }
        </MudTabs>

        @* Save Button *@
        <MudStack Row="true" Justify="Justify.FlexEnd" Class="mt-4">
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       OnClick="@SavePreferences"
                       Disabled="@_saving">
                @if (_saving)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <span>Saving...</span>
                }
                else
                {
                    <MudIcon Icon="@Icons.Material.Filled.Save" Class="mr-2" />
                    <span>Save Preferences</span>
                }
            </MudButton>
        </MudStack>

        @* Info Alert *@
        <MudAlert Severity="Severity.Info" Dense="true" Class="mt-3">
            <strong>Note:</strong> Chat-specific events (spam, bans, reports) notify admins of those specific chats.
            System events (backup failures, health warnings) notify Owners only.
        </MudAlert>
    }
</MudPaper>

@code {
    [Parameter]
    public string UserId { get; set; } = string.Empty;

    [Parameter]
    public int UserPermissionLevel { get; set; }

    private NotificationConfig? _config;
    private bool _hasTelegramLinked;
    private bool _loading = true;
    private bool _saving;

    protected override async Task OnInitializedAsync()
    {
        await LoadPreferences();
    }

    private async Task LoadPreferences()
    {
        try
        {
            _loading = true;
            _config = await PreferencesRepo.GetOrCreateAsync(UserId);

            // Check if user has a linked Telegram account
            var mappings = await TelegramMappingRepo.GetByUserIdAsync(UserId);
            _hasTelegramLinked = mappings.Any();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load notification preferences: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private void ToggleEvent(NotificationChannel channel, NotificationEventType eventType, bool enabled)
    {
        if (_config == null) return;

        var channelPref = _config.GetOrCreateChannel(channel);
        if (enabled && !channelPref.EnabledEvents.Contains(eventType))
        {
            channelPref.EnabledEvents.Add(eventType);
        }
        else if (!enabled)
        {
            channelPref.EnabledEvents.Remove(eventType);
        }
    }

    private int GetDigestMinutes()
    {
        if (_config == null) return 0;
        var emailPref = _config.Channels.FirstOrDefault(c => c.Channel == NotificationChannel.Email);
        return emailPref?.DigestMinutes ?? 0;
    }

    private void SetDigestMinutes(int value)
    {
        if (_config == null) return;
        var emailPref = _config.GetOrCreateChannel(NotificationChannel.Email);
        emailPref.DigestMinutes = value;
    }

    private async Task SavePreferences()
    {
        if (_config == null) return;

        try
        {
            _saving = true;
            await PreferencesRepo.SaveAsync(UserId, _config);
            Snackbar.Add("Notification preferences saved successfully!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save preferences: {ex.Message}", Severity.Error);
        }
        finally
        {
            _saving = false;
        }
    }

    private bool IsChannelConfigured(NotificationChannel channel) => channel switch
    {
        NotificationChannel.TelegramDm => _hasTelegramLinked,
        NotificationChannel.Email => true,  // Always available (uses account email)
        NotificationChannel.WebPush => true,  // Always available (in-app)
        _ => false
    };

    private string GetSetupLink(NotificationChannel channel) => channel switch
    {
        NotificationChannel.TelegramDm => "/profile",
        _ => "#"
    };

    private string GetSetupTooltip(NotificationChannel channel) => channel switch
    {
        NotificationChannel.TelegramDm => "Link your Telegram account in Profile to enable",
        _ => null
    } ?? "";

    private static string GetChannelDisplayName(NotificationChannel channel) => channel switch
    {
        NotificationChannel.TelegramDm => "Telegram DM",
        NotificationChannel.Email => "Email",
        NotificationChannel.WebPush => "In-App",
        _ => channel.ToString()
    };

    private static string GetChannelIcon(NotificationChannel channel) => channel switch
    {
        NotificationChannel.TelegramDm => Icons.Custom.Brands.Telegram,
        NotificationChannel.Email => Icons.Material.Filled.Email,
        NotificationChannel.WebPush => Icons.Material.Filled.Notifications,
        _ => Icons.Material.Filled.QuestionMark
    };

    private IEnumerable<NotificationEventType> GetVisibleEventTypes()
    {
        foreach (var eventType in Enum.GetValues<NotificationEventType>())
        {
            // Owner-only events hidden for non-owners
            if (IsOwnerOnlyEvent(eventType) && UserPermissionLevel < 2)
                continue;
            yield return eventType;
        }
    }

    private static bool IsOwnerOnlyEvent(NotificationEventType eventType)
        => eventType is NotificationEventType.BackupFailed
                     or NotificationEventType.ChatHealthWarning
                     or NotificationEventType.ChatAdminChanged;

    private static string GetEventDisplayName(NotificationEventType eventType) => eventType switch
    {
        NotificationEventType.SpamDetected => "Spam Detected",
        NotificationEventType.SpamAutoDeleted => "Spam Auto-Deleted",
        NotificationEventType.UserBanned => "User Banned",
        NotificationEventType.MessageReported => "Message Reported",
        NotificationEventType.MalwareDetected => "Malware Detected",
        NotificationEventType.ChatAdminChanged => "Chat Admin Changed (Owners)",
        NotificationEventType.ChatHealthWarning => "Chat Health Warning (Owners)",
        NotificationEventType.BackupFailed => "Backup Failed (Owners)",
        _ => eventType.ToString()
    };

    private static Color GetEventColor(NotificationEventType eventType) => eventType switch
    {
        NotificationEventType.SpamDetected => Color.Warning,
        NotificationEventType.SpamAutoDeleted => Color.Warning,
        NotificationEventType.UserBanned => Color.Error,
        NotificationEventType.MessageReported => Color.Info,
        NotificationEventType.MalwareDetected => Color.Error,
        NotificationEventType.ChatAdminChanged => Color.Info,
        NotificationEventType.ChatHealthWarning => Color.Warning,
        NotificationEventType.BackupFailed => Color.Error,
        _ => Color.Default
    };
}
